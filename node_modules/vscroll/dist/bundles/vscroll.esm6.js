/**
 * vscroll (https://github.com/dhilt/vscroll) FESM2015
 * Version: 1.2.0 (2021-07-14T23:49:13.136Z)
 * Author: Denis Hilt
 * License: MIT
 */

class Reactive {
  constructor(value, options) {
    this.id = 0;
    if (value !== void 0) {
      this.value = value;
      this.initialValue = value;
    }
    this.options = options || {};
    this.subscriptions = new Map();
  }
  set(value) {
    if (this.value === value && !this.options.emitEqual) {
      return;
    }
    this.value = value;
    for (const [, sub] of this.subscriptions) {
      sub.emit(value);
      if (this.value !== value) {
        break;
      }
    }
  }
  get() {
    return this.value;
  }
  on(func) {
    const id = this.id++;
    const subscription = {
      emit: func,
      off: () => {
        subscription.emit = () => null;
        this.subscriptions.delete(id);
      }
    };
    this.subscriptions.set(id, subscription);
    if (this.options.emitOnSubscribe) {
      subscription.emit(this.value);
    }
    return () => subscription.off();
  }
  once(func) {
    const off = this.on(v => {
      off();
      func(v);
    });
    return off;
  }
  reset() {
    this.set(this.initialValue);
  }
  dispose() {
    this.subscriptions.forEach(sub => sub.off());
  }
}

var AdapterPropName;
(function (AdapterPropName) {
  AdapterPropName["id"] = "id";
  AdapterPropName["mock"] = "mock";
  AdapterPropName["augmented"] = "augmented";
  AdapterPropName["version"] = "version";
  AdapterPropName["init"] = "init";
  AdapterPropName["init$"] = "init$";
  AdapterPropName["packageInfo"] = "packageInfo";
  AdapterPropName["itemsCount"] = "itemsCount";
  AdapterPropName["bufferInfo"] = "bufferInfo";
  AdapterPropName["isLoading"] = "isLoading";
  AdapterPropName["isLoading$"] = "isLoading$";
  AdapterPropName["loopPending"] = "loopPending";
  AdapterPropName["loopPending$"] = "loopPending$";
  AdapterPropName["firstVisible"] = "firstVisible";
  AdapterPropName["firstVisible$"] = "firstVisible$";
  AdapterPropName["lastVisible"] = "lastVisible";
  AdapterPropName["lastVisible$"] = "lastVisible$";
  AdapterPropName["bof"] = "bof";
  AdapterPropName["bof$"] = "bof$";
  AdapterPropName["eof"] = "eof";
  AdapterPropName["eof$"] = "eof$";
  AdapterPropName["reset"] = "reset";
  AdapterPropName["reload"] = "reload";
  AdapterPropName["append"] = "append";
  AdapterPropName["prepend"] = "prepend";
  AdapterPropName["check"] = "check";
  AdapterPropName["remove"] = "remove";
  AdapterPropName["clip"] = "clip";
  AdapterPropName["insert"] = "insert";
  AdapterPropName["replace"] = "replace";
  AdapterPropName["update"] = "update";
  AdapterPropName["fix"] = "fix";
  AdapterPropName["relax"] = "relax";
  AdapterPropName["showLog"] = "showLog";
})(AdapterPropName || (AdapterPropName = {}));
var AdapterPropType;
(function (AdapterPropType) {
  AdapterPropType[AdapterPropType["Scalar"] = 0] = "Scalar";
  AdapterPropType[AdapterPropType["Reactive"] = 1] = "Reactive";
  AdapterPropType[AdapterPropType["WorkflowRunner"] = 2] = "WorkflowRunner";
  AdapterPropType[AdapterPropType["Function"] = 3] = "Function";
})(AdapterPropType || (AdapterPropType = {}));
const Name = AdapterPropName;
const Type = AdapterPropType;
const noop = () => null;
const methodPreResult = {
  immediate: true,
  success: true,
  details: 'Adapter is not initialized'
};
const noopWF = () => Promise.resolve(methodPreResult);
const emptyPackageInfo = {
  core: {
    name: '',
    version: ''
  },
  consumer: {
    name: '',
    version: ''
  }
};
const bufferInfoDefault = {
  firstIndex: NaN,
  lastIndex: NaN,
  minIndex: NaN,
  maxIndex: NaN,
  absMinIndex: -Infinity,
  absMaxIndex: +Infinity,
  defaultSize: NaN,
};
const EMPTY_ITEM = {
  data: {},
  element: {}
};
const getDefaultAdapterProps = () => [
  {
    type: Type.Scalar,
    name: Name.id,
    value: 0,
    permanent: true
  },
  {
    type: Type.Scalar,
    name: Name.mock,
    value: true,
    permanent: true
  },
  {
    type: Type.Scalar,
    name: Name.augmented,
    value: false,
    permanent: true
  },
  {
    type: Type.Scalar,
    name: Name.version,
    value: '',
    permanent: true
  },
  {
    type: Type.Scalar,
    name: Name.init,
    value: false,
    reactive: Name.init$
  },
  {
    type: Type.Scalar,
    name: Name.packageInfo,
    value: emptyPackageInfo,
    onDemand: true
  },
  {
    type: Type.Scalar,
    name: Name.itemsCount,
    value: 0,
    onDemand: true
  },
  {
    type: Type.Scalar,
    name: Name.bufferInfo,
    value: bufferInfoDefault,
    onDemand: true
  },
  {
    type: Type.Scalar,
    name: Name.isLoading,
    value: false,
    reactive: Name.isLoading$
  },
  {
    type: Type.Scalar,
    name: Name.loopPending,
    value: false,
    reactive: Name.loopPending$
  },
  {
    type: Type.Scalar,
    name: Name.firstVisible,
    value: EMPTY_ITEM,
    reactive: Name.firstVisible$,
    wanted: true
  },
  {
    type: Type.Scalar,
    name: Name.lastVisible,
    value: EMPTY_ITEM,
    reactive: Name.lastVisible$,
    wanted: true
  },
  {
    type: Type.Scalar,
    name: Name.bof,
    value: false,
    reactive: Name.bof$
  },
  {
    type: Type.Scalar,
    name: Name.eof,
    value: false,
    reactive: Name.eof$
  },
  {
    type: Type.WorkflowRunner,
    name: Name.reset,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.reload,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.append,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.prepend,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.check,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.remove,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.clip,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.insert,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.replace,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.update,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.fix,
    value: noopWF
  },
  {
    type: Type.Function,
    name: Name.relax,
    value: noop
  },
  {
    type: Type.Function,
    name: Name.showLog,
    value: noop
  },
  {
    type: Type.Reactive,
    name: Name.init$,
    value: new Reactive()
  },
  {
    type: Type.Reactive,
    name: Name.isLoading$,
    value: new Reactive()
  },
  {
    type: Type.Reactive,
    name: Name.loopPending$,
    value: new Reactive()
  },
  {
    type: Type.Reactive,
    name: Name.firstVisible$,
    value: new Reactive(EMPTY_ITEM, { emitOnSubscribe: true })
  },
  {
    type: Type.Reactive,
    name: Name.lastVisible$,
    value: new Reactive(EMPTY_ITEM, { emitOnSubscribe: true })
  },
  {
    type: Type.Reactive,
    name: Name.bof$,
    value: new Reactive()
  },
  {
    type: Type.Reactive,
    name: Name.eof$,
    value: new Reactive()
  }
];
const reactiveConfigStorage = new Map();

var core = {
  name: 'vscroll',
  version: '1.2.0'
};

let instanceCount$1 = 0;
class AdapterContext {
  constructor(config) {
    const { mock, reactive } = config;
    const id = ++instanceCount$1;
    const conf = { configurable: true };
    const reactivePropsStore = {};
    // set up permanent props
    Object.defineProperty(this, AdapterPropName.id, Object.assign({ get: () => id }, conf));
    Object.defineProperty(this, AdapterPropName.mock, Object.assign({ get: () => mock }, conf));
    Object.defineProperty(this, AdapterPropName.augmented, Object.assign({ get: () => false }, conf));
    Object.defineProperty(this, AdapterPropName.version, Object.assign({ get: () => core.version }, conf));
    // set up default props, they will be reassigned during the Adapter instantiation
    getDefaultAdapterProps()
      .filter(({ permanent }) => !permanent)
      .forEach(({ name, value, type }) => {
      // reactive props might be reconfigured by the vscroll consumer
      if (reactive && type === AdapterPropType.Reactive) {
        const react = reactive[name];
        if (react) {
          // here we have a configured reactive property that came from the outer config
          // this prop must be exposed via Adapter, but at the same time we need to
          // persist the original default value as it will be used by the Adapter internally
          reactivePropsStore[name] = Object.assign(Object.assign({}, react), { default: value // persisting the default native Reactive prop
           });
          value = react.source; // exposing the configured prop instead of the default one
        }
      }
      Object.defineProperty(this, name, Object.assign({ get: () => value }, conf));
    });
    if (reactive) { // save both configured and default reactive props in the store
      reactiveConfigStorage.set(id, reactivePropsStore);
    }
  }
}

class DatasourceGeneric {
  constructor(datasource, config) {
    this.get = datasource.get;
    if (datasource.settings) {
      this.settings = datasource.settings;
    }
    if (datasource.devSettings) {
      this.devSettings = datasource.devSettings;
    }
    const adapterContext = new AdapterContext(config || { mock: false });
    this.adapter = adapterContext;
  }
  dispose() {
    reactiveConfigStorage.delete(this.adapter.id);
  }
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
const makeDatasource = (getConfig) => class extends DatasourceGeneric {
  constructor(datasource) {
    const config = typeof getConfig === 'function' ? getConfig() : void 0;
    super(datasource, config);
  }
};
const Datasource = makeDatasource();

var Direction;
(function (Direction) {
  Direction["forward"] = "forward";
  Direction["backward"] = "backward";
})(Direction || (Direction = {}));
var SizeStrategy;
(function (SizeStrategy) {
  SizeStrategy["Average"] = "average";
  SizeStrategy["Constant"] = "constant";
  SizeStrategy["Frequent"] = "frequent";
})(SizeStrategy || (SizeStrategy = {}));

var ValidatorType;
(function (ValidatorType) {
  ValidatorType["number"] = "must be a number";
  ValidatorType["integer"] = "must be an integer";
  ValidatorType["integerUnlimited"] = "must be an integer or infinity";
  ValidatorType["moreOrEqual"] = "must be a number greater than (or equal to) {arg1}";
  ValidatorType["itemList"] = "must be an array of items {arg1}";
  ValidatorType["boolean"] = "must be a boolean";
  ValidatorType["object"] = "must be an object";
  ValidatorType["element"] = "must be an html element";
  ValidatorType["function"] = "must be a function";
  ValidatorType["funcOfxArguments"] = "must have {arg1} argument(s)";
  ValidatorType["funcOfxAndMoreArguments"] = "must have at least {arg1} argument(s)";
  ValidatorType["funcOfXToYArguments"] = "must have {arg1} to {arg2} arguments";
  ValidatorType["oneOfCan"] = "can be present as only one item of {arg1} list";
  ValidatorType["oneOfMust"] = "must be present as only one item of {arg1} list";
  ValidatorType["or"] = "must satisfy at least 1 validator from {arg1} list";
  ValidatorType["enum"] = "must belong to {arg1} list";
})(ValidatorType || (ValidatorType = {}));
const getError = (msg, args) => (args || ['']).reduce((acc, arg, index) => acc.replace(`{arg${index + 1}}`, arg), msg);
const getNumber = (value) => typeof value === 'number' || (typeof value === 'string' && value !== '')
  ? Number(value)
  : NaN;
const onNumber = (value) => {
  const parsedValue = getNumber(value);
  const errors = [];
  if (Number.isNaN(parsedValue)) {
    errors.push(ValidatorType.number);
  }
  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };
};
const onInteger = (value) => {
  const errors = [];
  value = getNumber(value);
  const parsedValue = parseInt(String(value), 10);
  if (value !== parsedValue) {
    errors.push(ValidatorType.integer);
  }
  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };
};
const onIntegerUnlimited = (value) => {
  let parsedValue = value;
  const errors = [];
  value = getNumber(value);
  if (!Number.isFinite(value)) {
    parsedValue = value;
  }
  else {
    parsedValue = parseInt(String(value), 10);
  }
  if (value !== parsedValue) {
    errors.push(ValidatorType.integerUnlimited);
  }
  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };
};
const onMoreOrEqual = (limit, fallback) => (value) => {
  const result = onNumber(value);
  if (!result.isValid) {
    return result;
  }
  let parsedValue = result.value;
  const errors = [];
  if (parsedValue < limit) {
    if (!fallback) {
      errors.push(getError(ValidatorType.moreOrEqual, [String(limit)]));
    }
    else {
      parsedValue = limit;
    }
  }
  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };
};
const onBoolean = (value) => {
  const errors = [];
  let parsedValue = value;
  if (value === 'true') {
    parsedValue = true;
  }
  else if (value === 'false') {
    parsedValue = false;
  }
  if (typeof parsedValue !== 'boolean') {
    errors.push(ValidatorType.boolean);
  }
  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };
};
const onObject = (value) => {
  const errors = [];
  if (Object.prototype.toString.call(value) !== '[object Object]') {
    errors.push(ValidatorType.object);
  }
  return { value, isSet: true, isValid: !errors.length, errors };
};
const onHtmlElement = (value) => {
  const errors = [];
  if (!(value instanceof Element) && !(value instanceof HTMLDocument)) {
    errors.push(ValidatorType.element);
  }
  return { value, isSet: true, isValid: !errors.length, errors };
};
const onItemList = (value) => {
  let parsedValue = value;
  const errors = [];
  if (!Array.isArray(value)) {
    errors.push(ValidatorType.itemList);
    parsedValue = [];
  }
  else if (!value.length) {
    errors.push(getError(ValidatorType.itemList, ['with at least 1 item']));
  }
  else if (value.length > 1) {
    const type = typeof value[0];
    if (value.some((v) => typeof v !== type)) {
      errors.push(getError(ValidatorType.itemList, ['of items of the same type']));
    }
  }
  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };
};
const onFunction = (value) => {
  const errors = [];
  if (typeof value !== 'function') {
    errors.push(ValidatorType.function);
  }
  return { value: value, isSet: true, isValid: !errors.length, errors };
};
const onFunctionWithXArguments = (argsCount) => (value) => {
  const result = onFunction(value);
  if (!result.isValid) {
    return result;
  }
  value = result.value;
  const errors = [];
  if (value.length !== argsCount) {
    errors.push(getError(ValidatorType.funcOfxArguments, [String(argsCount)]));
  }
  return { value: value, isSet: true, isValid: !errors.length, errors };
};
const onFunctionWithXAndMoreArguments = (argsCount) => (value) => {
  const result = onFunction(value);
  if (!result.isValid) {
    return result;
  }
  value = result.value;
  const errors = [];
  if (value.length < argsCount) {
    errors.push(getError(ValidatorType.funcOfxArguments, [String(argsCount)]));
  }
  return { value: value, isSet: true, isValid: !errors.length, errors };
};
const onFunctionWithXToYArguments = (from, to) => (value) => {
  const result = onFunction(value);
  if (!result.isValid) {
    return result;
  }
  value = result.value;
  const errors = [];
  if (value.length < from || value.length > to) {
    errors.push(getError(ValidatorType.funcOfXToYArguments, [String(from), String(to)]));
  }
  return { value: value, isSet: true, isValid: !errors.length, errors };
};
const onOneOf = (tokens, must) => (value, context) => {
  const errors = [];
  const isSet = value !== void 0;
  let noOneIsPresent = !isSet;
  const err = must ? ValidatorType.oneOfMust : ValidatorType.oneOfCan;
  if (!Array.isArray(tokens) || !tokens.length) {
    errors.push(getError(err, ['undefined']));
  }
  else {
    for (let i = tokens.length - 1; i >= 0; i--) {
      const token = tokens[i];
      if (typeof token !== 'string') {
        errors.push(getError(err, [tokens.join('", "')]) + ' (non-string token)');
        break;
      }
      const isAnotherPresent = context && Object.prototype.hasOwnProperty.call(context, token);
      if (isSet && isAnotherPresent) {
        errors.push(getError(err, [tokens.join('", "')]) + ` (${token} is present)`);
        break;
      }
      if (noOneIsPresent && isAnotherPresent) {
        noOneIsPresent = false;
      }
    }
    if (must && noOneIsPresent) {
      errors.push(getError(err, [tokens.join('", "')]));
    }
  }
  return { value, isSet, isValid: !errors.length, errors };
};
const onOr = (validators) => (value) => {
  const errors = [];
  if (validators.every(validator => !validator.method(value).isValid)) {
    errors.push(validators.map(v => v.type).join(' OR '));
  }
  return { value, isSet: true, isValid: !errors.length, errors };
};
const onEnum = (list) => (value) => {
  const errors = [];
  const values = Object.keys(list).filter(k => isNaN(Number(k))).map(k => list[k]);
  if (!values.some(item => item === value)) {
    errors.push(getError(ValidatorType.enum, ['[' + values.join(',') + ']']));
  }
  return { value, isSet: true, isValid: !errors.length, errors };
};
const VALIDATORS = {
  NUMBER: {
    type: ValidatorType.number,
    method: onNumber
  },
  INTEGER: {
    type: ValidatorType.integer,
    method: onInteger
  },
  INTEGER_UNLIMITED: {
    type: ValidatorType.integerUnlimited,
    method: onIntegerUnlimited
  },
  MORE_OR_EQUAL: (limit, fallback) => ({
    type: ValidatorType.moreOrEqual,
    method: onMoreOrEqual(limit, fallback)
  }),
  BOOLEAN: {
    type: ValidatorType.boolean,
    method: onBoolean
  },
  OBJECT: {
    type: ValidatorType.object,
    method: onObject
  },
  ITEM_LIST: {
    type: ValidatorType.itemList,
    method: onItemList
  },
  ELEMENT: {
    type: ValidatorType.element,
    method: onHtmlElement
  },
  FUNC: {
    type: ValidatorType.function,
    method: onFunction
  },
  FUNC_WITH_X_ARGUMENTS: (count) => ({
    type: ValidatorType.funcOfxArguments,
    method: onFunctionWithXArguments(count)
  }),
  FUNC_WITH_X_AND_MORE_ARGUMENTS: (count) => ({
    type: ValidatorType.funcOfxAndMoreArguments,
    method: onFunctionWithXAndMoreArguments(count)
  }),
  FUNC_WITH_X_TO_Y_ARGUMENTS: (from, to) => ({
    type: ValidatorType.funcOfXToYArguments,
    method: onFunctionWithXToYArguments(from, to)
  }),
  ONE_OF_CAN: (list) => ({
    type: ValidatorType.oneOfCan,
    method: onOneOf(list, false)
  }),
  ONE_OF_MUST: (list) => ({
    type: ValidatorType.oneOfMust,
    method: onOneOf(list, true)
  }),
  OR: (list) => ({
    type: ValidatorType.or,
    method: onOr(list)
  }),
  ENUM: (list) => ({
    type: ValidatorType.enum,
    method: onEnum(list)
  })
};
class ValidatedData {
  constructor(context) {
    this.params = {};
    this.contextErrors = [];
    this.errors = [];
    this.isValid = true;
    this.setContext(context);
  }
  setContext(context) {
    if (!context || Object.prototype.toString.call(context) !== '[object Object]') {
      this.setCommonError('context is not an object');
      this.isValidContext = false;
    }
    else {
      this.isValidContext = true;
    }
    this.context = context;
  }
  setValidity() {
    this.errors = Object.keys(this.params).reduce((acc, key) => [
      ...acc, ...this.params[key].errors
    ], []);
    this.isValid = !this.errors.length;
  }
  setCommonError(error) {
    this.contextErrors.push(error);
    this.errors.push(error);
    this.isValid = false;
  }
  setParam(token, value) {
    if (!value.isValid) {
      value.errors = !value.isSet
        ? [`"${token}" must be set`]
        : value.errors.map((err) => `"${token}" ${err}`);
    }
    this.params[token] = value;
    this.setValidity();
  }
  showErrors() {
    return this.errors.length
      ? 'validation failed: ' + this.errors.join(', ')
      : '';
  }
}
const runValidator = (current, validator, context) => {
  const { value, errors } = current;
  const result = validator.method(value, context);
  const _errors = [...errors, ...result.errors];
  return {
    value: result.value,
    isSet: result.isSet,
    isValid: !_errors.length,
    errors: _errors
  };
};
const getDefault = (value, prop) => {
  const empty = value === void 0;
  const auto = !prop.mandatory && prop.defaultValue !== void 0;
  return {
    value: !empty ? value : (auto ? prop.defaultValue : void 0),
    isSet: !empty || auto,
    isValid: !empty || !prop.mandatory,
    errors: []
  };
};
const validateOne = (context, name, prop) => {
  const result = getDefault(context[name], prop);
  if (!result.isSet) {
    const oneOfMust = prop.validators.find(v => v.type === ValidatorType.oneOfMust);
    if (oneOfMust) {
      return runValidator(result, oneOfMust, context);
    }
  }
  else {
    for (const validator of Object.values(prop.validators)) {
      const current = runValidator(result, validator, context);
      if (!current.isValid && prop.defaultValue !== void 0) {
        return {
          value: prop.defaultValue,
          isSet: true,
          isValid: true,
          errors: []
        };
      }
      Object.assign(result, current);
    }
  }
  return result;
};
const validate = (context, params) => {
  const data = new ValidatedData(context);
  Object.entries(params).forEach(([key, prop]) => data.setParam(key, data.isValidContext
    ? validateOne(data.context, key, prop)
    : getDefault(void 0, prop)));
  return data;
};

const { OBJECT: OBJECT$1, FUNC_WITH_X_AND_MORE_ARGUMENTS: FUNC_WITH_X_AND_MORE_ARGUMENTS$1 } = VALIDATORS;
var DatasourceProps;
(function (DatasourceProps) {
  DatasourceProps["get"] = "get";
  DatasourceProps["settings"] = "settings";
  DatasourceProps["devSettings"] = "devSettings";
})(DatasourceProps || (DatasourceProps = {}));
const DATASOURCE = {
  [DatasourceProps.get]: {
    validators: [FUNC_WITH_X_AND_MORE_ARGUMENTS$1(2)],
    mandatory: true
  },
  [DatasourceProps.settings]: {
    validators: [OBJECT$1]
  },
  [DatasourceProps.devSettings]: {
    validators: [OBJECT$1]
  }
};

const { NUMBER, INTEGER: INTEGER$1, INTEGER_UNLIMITED: INTEGER_UNLIMITED$1, MORE_OR_EQUAL, BOOLEAN: BOOLEAN$1, ELEMENT, FUNC, OR: OR$1, ENUM } = VALIDATORS;
var Settings$1;
(function (Settings) {
  Settings["adapter"] = "adapter";
  Settings["startIndex"] = "startIndex";
  Settings["minIndex"] = "minIndex";
  Settings["maxIndex"] = "maxIndex";
  Settings["itemSize"] = "itemSize";
  Settings["bufferSize"] = "bufferSize";
  Settings["padding"] = "padding";
  Settings["infinite"] = "infinite";
  Settings["horizontal"] = "horizontal";
  Settings["windowViewport"] = "windowViewport";
  Settings["viewportElement"] = "viewportElement";
  Settings["inverse"] = "inverse";
  Settings["onBeforeClip"] = "onBeforeClip";
  Settings["sizeStrategy"] = "sizeStrategy";
})(Settings$1 || (Settings$1 = {}));
var DevSettings;
(function (DevSettings) {
  DevSettings["debug"] = "debug";
  DevSettings["immediateLog"] = "immediateLog";
  DevSettings["logProcessRun"] = "logProcessRun";
  DevSettings["logTime"] = "logTime";
  DevSettings["throttle"] = "throttle";
  DevSettings["initDelay"] = "initDelay";
  DevSettings["initWindowDelay"] = "initWindowDelay";
  DevSettings["cacheData"] = "cacheData";
  DevSettings["cacheOnReload"] = "cacheOnReload";
  DevSettings["changeOverflow"] = "changeOverflow";
  DevSettings["dismissOverflowAnchor"] = "dismissOverflowAnchor";
})(DevSettings || (DevSettings = {}));
const MIN = {
  [Settings$1.itemSize]: 1,
  [Settings$1.bufferSize]: 1,
  [Settings$1.padding]: 0.01,
  [DevSettings.throttle]: 0,
  [DevSettings.initDelay]: 0,
  [DevSettings.initWindowDelay]: 0,
};
const SETTINGS = {
  [Settings$1.adapter]: {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  [Settings$1.startIndex]: {
    validators: [INTEGER$1],
    defaultValue: 1
  },
  [Settings$1.minIndex]: {
    validators: [INTEGER_UNLIMITED$1],
    defaultValue: -Infinity
  },
  [Settings$1.maxIndex]: {
    validators: [INTEGER_UNLIMITED$1],
    defaultValue: Infinity
  },
  [Settings$1.itemSize]: {
    validators: [INTEGER$1, MORE_OR_EQUAL(MIN[Settings$1.itemSize], true)],
    defaultValue: NaN
  },
  [Settings$1.bufferSize]: {
    validators: [INTEGER$1, MORE_OR_EQUAL(MIN[Settings$1.bufferSize], true)],
    defaultValue: 5
  },
  [Settings$1.padding]: {
    validators: [NUMBER, MORE_OR_EQUAL(MIN[Settings$1.padding], true)],
    defaultValue: 0.5
  },
  [Settings$1.infinite]: {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  [Settings$1.horizontal]: {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  [Settings$1.windowViewport]: {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  [Settings$1.viewportElement]: {
    validators: [OR$1([ELEMENT, FUNC])],
    defaultValue: null
  },
  [Settings$1.inverse]: {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  [Settings$1.onBeforeClip]: {
    validators: [FUNC],
    defaultValue: null
  },
  [Settings$1.sizeStrategy]: {
    validators: [ENUM(SizeStrategy)],
    defaultValue: SizeStrategy.Average
  },
};
const DEV_SETTINGS = {
  [DevSettings.debug]: {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  [DevSettings.immediateLog]: {
    validators: [BOOLEAN$1],
    defaultValue: true
  },
  [DevSettings.logProcessRun]: {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  [DevSettings.logTime]: {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  [DevSettings.throttle]: {
    validators: [INTEGER$1, MORE_OR_EQUAL(MIN[DevSettings.throttle], true)],
    defaultValue: 40
  },
  [DevSettings.initDelay]: {
    validators: [INTEGER$1, MORE_OR_EQUAL(MIN[DevSettings.initDelay], true)],
    defaultValue: 1
  },
  [DevSettings.initWindowDelay]: {
    validators: [INTEGER$1, MORE_OR_EQUAL(MIN[DevSettings.initWindowDelay], true)],
    defaultValue: 40
  },
  [DevSettings.cacheData]: {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  [DevSettings.cacheOnReload]: {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  [DevSettings.changeOverflow]: {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  [DevSettings.dismissOverflowAnchor]: {
    validators: [BOOLEAN$1],
    defaultValue: true
  },
};

var CommonProcess;
(function (CommonProcess) {
  CommonProcess["init"] = "init";
  CommonProcess["scroll"] = "scroll";
  CommonProcess["start"] = "start";
  CommonProcess["preFetch"] = "preFetch";
  CommonProcess["fetch"] = "fetch";
  CommonProcess["postFetch"] = "postFetch";
  CommonProcess["render"] = "render";
  CommonProcess["preClip"] = "preClip";
  CommonProcess["clip"] = "clip";
  CommonProcess["adjust"] = "adjust";
  CommonProcess["end"] = "end";
})(CommonProcess || (CommonProcess = {}));
var AdapterProcess;
(function (AdapterProcess) {
  AdapterProcess["reset"] = "adapter.reset";
  AdapterProcess["reload"] = "adapter.reload";
  AdapterProcess["append"] = "adapter.append";
  AdapterProcess["prepend"] = "adapter.prepend";
  AdapterProcess["check"] = "adapter.check";
  AdapterProcess["remove"] = "adapter.remove";
  AdapterProcess["replace"] = "adapter.replace";
  AdapterProcess["update"] = "adapter.update";
  AdapterProcess["clip"] = "adapter.clip";
  AdapterProcess["insert"] = "adapter.insert";
  AdapterProcess["fix"] = "adapter.fix";
})(AdapterProcess || (AdapterProcess = {}));
var ProcessStatus;
(function (ProcessStatus) {
  ProcessStatus["start"] = "start";
  ProcessStatus["next"] = "next";
  ProcessStatus["done"] = "done";
  ProcessStatus["error"] = "error";
})(ProcessStatus || (ProcessStatus = {}));

const { INTEGER, INTEGER_UNLIMITED, BOOLEAN, OBJECT, ITEM_LIST, FUNC_WITH_X_ARGUMENTS, FUNC_WITH_X_AND_MORE_ARGUMENTS, FUNC_WITH_X_TO_Y_ARGUMENTS, ONE_OF_MUST, ONE_OF_CAN, OR, } = VALIDATORS;
var AdapterNoParams;
(function (AdapterNoParams) {
})(AdapterNoParams || (AdapterNoParams = {}));
const NO_METHOD_PARAMS = {};
const RESET_METHOD_PARAMS = {
  [DatasourceProps.get]: {
    validators: [FUNC_WITH_X_AND_MORE_ARGUMENTS(2)]
  },
  [DatasourceProps.settings]: {
    validators: [OBJECT]
  },
  [DatasourceProps.devSettings]: {
    validators: [OBJECT]
  },
};
var AdapterReloadParams;
(function (AdapterReloadParams) {
  AdapterReloadParams["reloadIndex"] = "reloadIndex";
})(AdapterReloadParams || (AdapterReloadParams = {}));
const RELOAD_METHOD_PARAMS = {
  [AdapterReloadParams.reloadIndex]: {
    validators: [INTEGER]
  },
};
var AdapterAppendParams;
(function (AdapterAppendParams) {
  AdapterAppendParams["items"] = "items";
  AdapterAppendParams["bof"] = "bof";
  AdapterAppendParams["eof"] = "eof";
})(AdapterAppendParams || (AdapterAppendParams = {}));
const APPEND_METHOD_PARAMS = {
  [AdapterAppendParams.items]: {
    validators: [ITEM_LIST],
    mandatory: true
  },
  [AdapterAppendParams.bof]: {
    validators: [BOOLEAN, ONE_OF_CAN([AdapterAppendParams.eof])]
  },
  [AdapterAppendParams.eof]: {
    validators: [BOOLEAN, ONE_OF_CAN([AdapterAppendParams.bof])]
  },
};
var AdapterRemoveParams;
(function (AdapterRemoveParams) {
  AdapterRemoveParams["predicate"] = "predicate";
  AdapterRemoveParams["indexes"] = "indexes";
  AdapterRemoveParams["increase"] = "increase";
})(AdapterRemoveParams || (AdapterRemoveParams = {}));
const REMOVE_METHOD_PARAMS = {
  [AdapterRemoveParams.predicate]: {
    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterRemoveParams.indexes])]
  },
  [AdapterRemoveParams.indexes]: {
    validators: [ITEM_LIST, ONE_OF_MUST([AdapterRemoveParams.predicate])]
  },
  [AdapterRemoveParams.increase]: {
    validators: [BOOLEAN],
    defaultValue: false
  },
};
var AdapterClipParams;
(function (AdapterClipParams) {
  AdapterClipParams["backwardOnly"] = "backwardOnly";
  AdapterClipParams["forwardOnly"] = "forwardOnly";
})(AdapterClipParams || (AdapterClipParams = {}));
const CLIP_METHOD_PARAMS = {
  [AdapterClipParams.backwardOnly]: {
    validators: [BOOLEAN, ONE_OF_CAN([AdapterClipParams.forwardOnly])],
    defaultValue: false
  },
  [AdapterClipParams.forwardOnly]: {
    validators: [BOOLEAN, ONE_OF_CAN([AdapterClipParams.backwardOnly])],
    defaultValue: false
  },
};
var AdapterInsertParams;
(function (AdapterInsertParams) {
  AdapterInsertParams["items"] = "items";
  AdapterInsertParams["before"] = "before";
  AdapterInsertParams["after"] = "after";
  AdapterInsertParams["decrease"] = "decrease";
})(AdapterInsertParams || (AdapterInsertParams = {}));
const INSERT_METHOD_PARAMS = {
  [AdapterInsertParams.items]: {
    validators: [ITEM_LIST],
    mandatory: true
  },
  [AdapterInsertParams.before]: {
    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterInsertParams.after])]
  },
  [AdapterInsertParams.after]: {
    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterInsertParams.before])]
  },
  [AdapterInsertParams.decrease]: {
    validators: [BOOLEAN],
    defaultValue: false
  },
};
var AdapterReplaceParams;
(function (AdapterReplaceParams) {
  AdapterReplaceParams["items"] = "items";
  AdapterReplaceParams["predicate"] = "predicate";
  AdapterReplaceParams["fixRight"] = "fixRight";
})(AdapterReplaceParams || (AdapterReplaceParams = {}));
const REPLACE_METHOD_PARAMS = {
  [AdapterInsertParams.items]: {
    validators: [ITEM_LIST],
    mandatory: true
  },
  [AdapterReplaceParams.predicate]: {
    validators: [FUNC_WITH_X_ARGUMENTS(1)],
    mandatory: true
  },
  [AdapterReplaceParams.fixRight]: {
    validators: [BOOLEAN],
    defaultValue: false
  }
};
var AdapterUpdateParams;
(function (AdapterUpdateParams) {
  AdapterUpdateParams["predicate"] = "predicate";
  AdapterUpdateParams["fixRight"] = "fixRight";
})(AdapterUpdateParams || (AdapterUpdateParams = {}));
const UPDATE_METHOD_PARAMS = {
  [AdapterUpdateParams.predicate]: {
    validators: [FUNC_WITH_X_ARGUMENTS(1)],
    mandatory: true
  },
  [AdapterUpdateParams.fixRight]: {
    validators: [BOOLEAN],
    defaultValue: false
  },
};
var AdapterFixParams;
(function (AdapterFixParams) {
  AdapterFixParams["scrollPosition"] = "scrollPosition";
  AdapterFixParams["minIndex"] = "minIndex";
  AdapterFixParams["maxIndex"] = "maxIndex";
  AdapterFixParams["updater"] = "updater";
  AdapterFixParams["scrollToItem"] = "scrollToItem";
  AdapterFixParams["scrollToItemOpt"] = "scrollToItemOpt";
})(AdapterFixParams || (AdapterFixParams = {}));
const FIX_METHOD_PARAMS = {
  [AdapterFixParams.scrollPosition]: {
    validators: [INTEGER_UNLIMITED]
  },
  [AdapterFixParams.minIndex]: {
    validators: [INTEGER_UNLIMITED]
  },
  [AdapterFixParams.maxIndex]: {
    validators: [INTEGER_UNLIMITED]
  },
  [AdapterFixParams.updater]: {
    validators: [FUNC_WITH_X_TO_Y_ARGUMENTS(1, 2)]
  },
  [AdapterFixParams.scrollToItem]: {
    validators: [FUNC_WITH_X_ARGUMENTS(1)]
  },
  [AdapterFixParams.scrollToItemOpt]: {
    validators: [OR([BOOLEAN, OBJECT])]
  },
};
const AdapterMethods = {
  [AdapterProcess.reset]: DatasourceProps,
  [AdapterProcess.reload]: AdapterReloadParams,
  [AdapterProcess.append]: AdapterAppendParams,
  [AdapterProcess.prepend]: AdapterAppendParams,
  [AdapterProcess.check]: AdapterNoParams,
  [AdapterProcess.remove]: AdapterRemoveParams,
  [AdapterProcess.clip]: AdapterClipParams,
  [AdapterProcess.insert]: AdapterInsertParams,
  [AdapterProcess.replace]: AdapterReplaceParams,
  [AdapterProcess.update]: AdapterUpdateParams,
  [AdapterProcess.fix]: AdapterFixParams,
};
const ADAPTER_METHODS = {
  [AdapterProcess.reset]: RESET_METHOD_PARAMS,
  [AdapterProcess.reload]: RELOAD_METHOD_PARAMS,
  [AdapterProcess.append]: APPEND_METHOD_PARAMS,
  [AdapterProcess.prepend]: APPEND_METHOD_PARAMS,
  [AdapterProcess.check]: NO_METHOD_PARAMS,
  [AdapterProcess.remove]: REMOVE_METHOD_PARAMS,
  [AdapterProcess.clip]: CLIP_METHOD_PARAMS,
  [AdapterProcess.insert]: INSERT_METHOD_PARAMS,
  [AdapterProcess.replace]: REPLACE_METHOD_PARAMS,
  [AdapterProcess.update]: UPDATE_METHOD_PARAMS,
  [AdapterProcess.fix]: FIX_METHOD_PARAMS,
};

class Settings {
  constructor(settings, devSettings, instanceIndex) {
    this.parseInput(settings, SETTINGS);
    this.parseInput(devSettings, DEV_SETTINGS);
    this.instanceIndex = instanceIndex;
    this.initializeDelay = this.getInitializeDelay();
    this.viewport = this.getViewport();
    // todo: min/max indexes must be ignored if infinite mode is enabled ??
  }
  parseInput(input, props) {
    const result = validate(input, props);
    if (!result.isValid) {
      throw new Error('Invalid settings');
    }
    Object.entries(result.params).forEach(([key, par]) => Object.assign(this, { [key]: par.value }));
  }
  getInitializeDelay() {
    let result = 0;
    if (this.windowViewport && this.initWindowDelay && !('scrollRestoration' in history)) {
      result = this.initWindowDelay;
    }
    if (this.initDelay > 0) {
      result = Math.max(result, this.initDelay);
    }
    return result;
  }
  getViewport() {
    if (typeof this.viewportElement !== 'function') {
      return this.viewportElement;
    }
    const value = this.viewportElement();
    const result = validateOne({ value }, 'value', { validators: [VALIDATORS.ELEMENT] });
    if (!result.isValid) {
      return null; // fallback to default (null) if Function didn't return HTML element synchronously
    }
    return result.value;
  }
}

const BaseProcessFactory = (process) => { var _a; return _a = class BaseProcess {
  },
  _a.process = process,
  _a; };
const BaseAdapterProcessFactory = (process) => { var _a; return _a = class BaseAdapterProcess extends BaseProcessFactory(process) {
    static parseInput(scroller, options, ignoreErrors = false) {
      const result = {
        data: validate(options, ADAPTER_METHODS[process])
      };
      if (result.data.isValid) {
        result.params = Object.entries(result.data.params)
          .reduce((acc, [key, { value }]) => (Object.assign(Object.assign({}, acc), { [key]: value })), {});
      }
      else {
        scroller.logger.log(() => result.data.showErrors());
        if (!ignoreErrors) {
          scroller.workflow.call({
            process,
            status: ProcessStatus.error,
            payload: { error: `Wrong argument of the "${process}" method call` }
          });
        }
      }
      return result;
    }
  },
  _a.process = process,
  _a; };

const initProcesses = [CommonProcess.init, AdapterProcess.reset, AdapterProcess.reload];
class Init extends BaseProcessFactory(CommonProcess.init) {
  static run(scroller, process) {
    const { state: { cycle }, workflow } = scroller;
    const isInitial = initProcesses.includes(process);
    scroller.logger.logCycle(true);
    cycle.start(isInitial, process);
    workflow.call({
      process: Init.process,
      status: ProcessStatus.next
    });
  }
}

class Scroll extends BaseProcessFactory(CommonProcess.scroll) {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static run(scroller, payload) {
    const { workflow, viewport } = scroller;
    const position = viewport.scrollPosition;
    if (Scroll.onSynthetic(scroller, position)) {
      return;
    }
    Scroll.onThrottle(scroller, position, () => Scroll.onScroll(scroller, workflow));
  }
  static onSynthetic(scroller, position) {
    const { scrollState } = scroller.state;
    const synthPos = scrollState.syntheticPosition;
    if (synthPos !== null) {
      if (scrollState.syntheticFulfill) {
        scrollState.syntheticPosition = null;
      }
      if (!scrollState.syntheticFulfill || synthPos === position) {
        scroller.logger.log(() => [
          'skipping scroll', position, `[${scrollState.syntheticFulfill ? '' : 'pre-'}synthetic]`
        ]);
        return true;
      }
      scroller.logger.log(() => [
        'synthetic scroll has been fulfilled:', position, position < synthPos ? '<' : '>', synthPos
      ]);
    }
    return false;
  }
  static onThrottle(scroller, position, done) {
    const { state: { scrollState }, settings: { throttle }, logger } = scroller;
    scrollState.current = Scroll.getScrollEvent(position, scrollState.previous);
    const { direction, time } = scrollState.current;
    const timeDiff = scrollState.previous ? time - scrollState.previous.time : Infinity;
    const delta = throttle - timeDiff;
    const shouldDelay = isFinite(delta) && delta > 0;
    const alreadyDelayed = !!scrollState.scrollTimer;
    logger.log(() => [
      direction === Direction.backward ? '\u2934' : '\u2935',
      position,
      shouldDelay ? (timeDiff + 'ms') : '0ms',
      shouldDelay ? (alreadyDelayed ? 'delayed' : `/ ${delta}ms delay`) : ''
    ]);
    if (!shouldDelay) {
      if (scrollState.scrollTimer) {
        clearTimeout(scrollState.scrollTimer);
        scrollState.scrollTimer = null;
      }
      done();
      return;
    }
    if (!alreadyDelayed) {
      scrollState.scrollTimer = setTimeout(() => {
        logger.log(() => {
          const curr = Scroll.getScrollEvent(scroller.viewport.scrollPosition, scrollState.current);
          return [
            curr.direction === Direction.backward ? '\u2934' : '\u2935',
            curr.position,
            (curr.time - time) + 'ms',
            'triggered by timer set on',
            position
          ];
        });
        scrollState.scrollTimer = null;
        done();
      }, delta);
    }
  }
  static getScrollEvent(position, previous) {
    const time = Number(new Date());
    let direction = Direction.forward;
    if (previous) {
      if (position === previous.position) {
        direction = previous.direction;
      }
      else if (position < previous.position) {
        direction = Direction.backward;
      }
    }
    return { position, direction, time };
  }
  static onScroll(scroller, workflow) {
    const { state: { scrollState, cycle } } = scroller;
    scrollState.previous = Object.assign({}, scrollState.current);
    scrollState.current = null;
    if (cycle.busy.get()) {
      scroller.logger.log(() => ['skipping scroll', scrollState.previous.position, '[pending]']);
      return;
    }
    workflow.call({
      process: Scroll.process,
      status: ProcessStatus.next
    });
  }
}

class Reset extends BaseAdapterProcessFactory(AdapterProcess.reset) {
  static run(scroller, options) {
    const { datasource, buffer, viewport: { paddings }, state: { cycle } } = scroller;
    if (options) {
      const { data } = Reset.parseInput(scroller, options);
      if (!data.isValid) {
        return;
      }
      const constructed = options instanceof Datasource;
      Object.keys(DatasourceProps).forEach(key => {
        const param = data.params[key];
        const ds = datasource;
        if (param.isSet || (constructed && ds[key])) {
          ds[key] = param.value;
        }
      });
    }
    buffer.reset(true);
    paddings.backward.reset();
    paddings.forward.reset();
    const payload = { datasource };
    if (cycle.busy.get()) {
      payload.finalize = true;
      cycle.interrupter = Reset.process;
    }
    scroller.workflow.call({
      process: Reset.process,
      status: ProcessStatus.next,
      payload
    });
  }
}

class Reload extends BaseAdapterProcessFactory(AdapterProcess.reload) {
  static run(scroller, reloadIndex) {
    const { viewport, state, buffer } = scroller;
    const { params } = Reload.parseInput(scroller, { reloadIndex }, true);
    buffer.reset(false, params ? params.reloadIndex : void 0);
    viewport.reset(buffer.startIndex);
    const payload = {};
    if (state.cycle.busy.get()) {
      state.scrollState.cleanupTimers();
      payload.finalize = true;
      state.cycle.interrupter = Reload.process;
    }
    scroller.workflow.call({
      process: Reload.process,
      status: ProcessStatus.next,
      payload
    });
  }
}

class Item {
  constructor($index, data, routines) {
    this.container = {
      $index,
      data
    };
    this.nodeId = String($index);
    this.routines = routines;
    this.invisible = true;
    this.toRemove = false;
    this.toInsert = false;
  }
  get $index() {
    return this.container.$index;
  }
  set $index(value) {
    this.container.$index = value;
  }
  get data() {
    return this.container.data;
  }
  set data(value) {
    this.container.data = value;
  }
  get element() {
    return this.container.element;
  }
  set element(value) {
    this.container.element = value;
  }
  dispose() {
    delete this.container.element;
  }
  setSize() {
    this.size = this.routines.getSize(this.element);
  }
  hide() {
    if (this.element) {
      this.routines.hideElement(this.element);
    }
  }
  scrollTo(argument) {
    if (this.element) {
      this.routines.scrollTo(this.element, argument);
    }
  }
  updateIndex(index) {
    this.$index = index;
    this.nodeId = String(index);
  }
  get() {
    return this.container;
  }
}

class Append extends BaseAdapterProcessFactory(AdapterProcess.append) {
  static run(scroller, { process, options }) {
    const { params } = Append.parseInput(scroller, options);
    if (!params) {
      return;
    }
    const { items, bof, eof } = params;
    const prepend = process !== AdapterProcess.append;
    const _eof = !!(prepend ? bof : eof);
    // virtual prepend case: shift abs min index and update viewport params
    if ((prepend && _eof && !scroller.buffer.bof.get()) ||
      (!prepend && _eof && !scroller.buffer.eof.get())) {
      Append.doVirtualize(scroller, items, prepend);
      scroller.workflow.call({
        process: Append.process,
        status: ProcessStatus.done
      });
      return;
    }
    Append.simulateFetch(scroller, items, _eof, prepend);
    scroller.workflow.call({
      process: Append.process,
      status: ProcessStatus.next
    });
  }
  static doVirtualize(scroller, items, prepend) {
    const { buffer, viewport: { paddings } } = scroller;
    const bufferToken = prepend ? 'absMinIndex' : 'absMaxIndex';
    if (isFinite(buffer[bufferToken])) {
      const size = items.length * buffer.defaultSize;
      const padding = prepend ? paddings.backward : paddings.forward;
      buffer[bufferToken] += (prepend ? -1 : 1) * items.length;
      padding.size += size;
      if (prepend) {
        scroller.viewport.scrollPosition += size;
      }
      scroller.logger.log(() => `buffer.${[bufferToken]} value is set to ${buffer[bufferToken]}`);
      scroller.logger.stat(`after virtual ${prepend ? 'prepend' : 'append'}`);
    }
  }
  static simulateFetch(scroller, items, eof, prepend) {
    const { buffer, state: { fetch } } = scroller;
    const bufferToken = prepend ? 'absMinIndex' : 'absMaxIndex';
    let indexToAdd = buffer.getIndexToAdd(eof, prepend);
    let bufferLimit = buffer[bufferToken];
    const newItems = [];
    for (let i = 0; i < items.length; i++) {
      const itemToAdd = new Item(indexToAdd, items[i], scroller.routines);
      if (isFinite(bufferLimit) && ((prepend && indexToAdd < bufferLimit) ||
        (!prepend && indexToAdd > bufferLimit))) {
        bufferLimit += (prepend ? -1 : 1);
      }
      (prepend ? Array.prototype.unshift : Array.prototype.push).apply(newItems, [itemToAdd]);
      // (prepend ? newItems.unshift : newItems.push)(itemToAdd);
      indexToAdd += (prepend ? -1 : 1);
    }
    if (bufferLimit !== buffer[bufferToken]) {
      buffer[bufferToken] = bufferLimit;
      scroller.logger.log(() => `buffer.${bufferToken} value is set to ${buffer[bufferToken]}`);
    }
    (prepend ? fetch.prepend : fetch.append).call(fetch, newItems);
    (prepend ? buffer.prepend : buffer.append).call(buffer, newItems);
    fetch.first.indexBuffer = !isNaN(buffer.firstIndex) ? buffer.firstIndex : indexToAdd;
    fetch.last.indexBuffer = !isNaN(buffer.lastIndex) ? buffer.lastIndex : indexToAdd;
    return true;
  }
}

class Check extends BaseAdapterProcessFactory(AdapterProcess.check) {
  static run(scroller) {
    const { workflow, buffer, state: { fetch }, viewport } = scroller;
    let min = Infinity, max = -Infinity;
    buffer.items.forEach(item => {
      const size = item.size;
      item.setSize();
      if (item.size !== size) {
        buffer.cacheItem(item);
        min = Math.min(min, item.$index);
        max = Math.max(max, item.$index);
      }
    });
    if (Number.isFinite(min)) {
      fetch.first.indexBuffer = buffer.firstIndex;
      fetch.last.indexBuffer = buffer.lastIndex;
      const { index: firstIndex, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);
      fetch.firstVisibleIndex = firstIndex;
      if (!isNaN(firstIndex)) {
        fetch.firstVisibleItemDelta = -buffer.getSizeByIndex(firstIndex) + diff;
      }
      fetch.check(buffer.items.filter(item => item.$index >= min && item.$index <= max));
    }
    scroller.logger.stat('check');
    workflow.call({
      process: Check.process,
      status: Number.isFinite(min) ? ProcessStatus.next : ProcessStatus.done
    });
  }
}

class Remove extends BaseAdapterProcessFactory(AdapterProcess.remove) {
  static run(scroller, options) {
    const { params } = Remove.parseInput(scroller, options);
    if (!params) {
      return;
    }
    const shouldRemove = Remove.doRemove(scroller, params);
    scroller.workflow.call({
      process: Remove.process,
      status: shouldRemove ? ProcessStatus.next : ProcessStatus.done
    });
  }
  static doRemove(scroller, params, sequenceOnly = false) {
    const { fetch } = scroller.state;
    fetch.firstVisibleIndex = NaN;
    const bufferRemoveList = Remove.removeBufferedItems(scroller, params);
    if (params.indexes && params.indexes.length) { // to avoid duplicate buffer-virtual removals
      params.indexes = params.indexes.filter(i => !bufferRemoveList.includes(i));
    }
    const shouldRemoveBuffered = bufferRemoveList.length > 0;
    const shouldRemoveVirtual = Remove.removeVirtualItems(scroller, params, sequenceOnly);
    if (!shouldRemoveBuffered && !shouldRemoveVirtual) {
      return false;
    }
    if (!isNaN(fetch.firstVisibleIndex)) {
      fetch.remove();
    }
    scroller.logger.stat('after remove');
    return true;
  }
  static removeBufferedItems(scroller, options) {
    const { predicate, indexes, increase } = options;
    let result = [];
    if (predicate) {
      result = Remove.runPredicateOverBuffer(scroller, predicate, !!increase);
    }
    if (indexes) {
      const indexPredicate = ({ $index }) => indexes.indexOf($index) >= 0;
      result = Remove.runPredicateOverBuffer(scroller, indexPredicate, !!increase);
    }
    return result;
  }
  static runPredicateOverBuffer(scroller, predicate, increase) {
    const { viewport, buffer, buffer: { items }, state: { fetch } } = scroller;
    // get items to remove
    const clipList = [];
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (predicate(item.get())) {
        clipList.push(item);
        item.toRemove = true;
      }
      else if (clipList.length) {
        break; // allow only first strict uninterrupted sequence
      }
    }
    if (!clipList.length) {
      return [];
    }
    // what item should be shown after remove (1-4)
    const firstClipIndex = clipList[0].$index, lastClipIndex = clipList[clipList.length - 1].$index;
    // 1) current first visible item will remain
    const { index: firstIndex, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);
    if (firstIndex < firstClipIndex || firstIndex > lastClipIndex) {
      fetch.firstVisibleIndex = firstIndex;
      fetch.firstVisibleItemDelta = -buffer.getSizeByIndex(firstIndex) + diff;
    }
    // 2) next after the last removed item
    if (isNaN(fetch.firstVisibleIndex) && lastClipIndex < buffer.finiteAbsMaxIndex) {
      fetch.firstVisibleIndex = lastClipIndex + 1;
    }
    // 3) prev before the first removed item
    if (isNaN(fetch.firstVisibleIndex) && firstClipIndex > buffer.finiteAbsMinIndex) {
      fetch.firstVisibleIndex = firstClipIndex - 1;
    }
    // 4) prev before the first removed item
    if (isNaN(fetch.firstVisibleIndex)) {
      fetch.firstVisibleIndex = buffer.finiteAbsMinIndex;
    }
    // logical removal
    const indexListToRemove = clipList.map(item => item.$index);
    scroller.logger.log(() => `going to remove ${clipList.length} item(s) from Buffer: [${indexListToRemove.join(',')}]`);
    buffer.removeItems(indexListToRemove, increase, false);
    buffer.checkDefaultSize();
    Remove.shiftFirstVisibleIndex(scroller, indexListToRemove, increase);
    // physical removal (hiding)
    clipList.forEach(item => item.hide());
    return indexListToRemove;
  }
  static removeVirtualItems(scroller, params, sequenceOnly) {
    const { indexes, increase } = params;
    if (!indexes || !indexes.length) {
      return false;
    }
    const { buffer, viewport, state: { fetch } } = scroller;
    // get items to remove
    const { finiteAbsMinIndex, firstIndex, finiteAbsMaxIndex, lastIndex } = buffer;
    const toRemove = [];
    let last = NaN;
    for (let i = 0, len = indexes.length; i < len; i++) {
      const index = indexes[i];
      if (index >= finiteAbsMinIndex && !isNaN(firstIndex) && index < firstIndex) {
        toRemove.push(index); // backward;
      }
      else if (index <= finiteAbsMaxIndex && !isNaN(lastIndex) && index > lastIndex) {
        toRemove.push(index); // forward;
      }
      else {
        continue;
      }
      if (sequenceOnly && !isNaN(last) && Math.abs(last - index) > 1) {
        // allow only first strict uninterrupted sequence
        break;
      }
      last = index;
    }
    if (!toRemove.length) {
      return false;
    }
    // what should be shown after remove; Buffer removal has priority
    if (isNaN(fetch.firstVisibleIndex)) {
      const { index, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);
      if (!isNaN(index)) {
        fetch.firstVisibleIndex = index;
        fetch.firstVisibleItemDelta = -buffer.getSizeByIndex(index) + diff;
      }
    }
    // virtual removal
    scroller.logger.log(() => `going to remove ${toRemove.length} item(s) virtually`);
    buffer.removeItems(toRemove, !!increase, true);
    buffer.checkDefaultSize();
    Remove.shiftFirstVisibleIndex(scroller, toRemove, !!increase);
    return true;
  }
  static shiftFirstVisibleIndex({ state: { fetch } }, listToRemove, increase) {
    if (isNaN(fetch.firstVisibleIndex)) {
      return;
    }
    const shift = listToRemove.reduce((acc, index) => acc + (((increase && index > fetch.firstVisibleIndex) || (!increase && index < fetch.firstVisibleIndex)) ? 1 : 0), 0);
    fetch.firstVisibleIndex = fetch.firstVisibleIndex + (increase ? shift : -shift);
  }
}

class UserClip extends BaseAdapterProcessFactory(AdapterProcess.clip) {
  static run(scroller, options) {
    const { params } = UserClip.parseInput(scroller, options);
    scroller.state.clip.forceForward = !(params && params.backwardOnly);
    scroller.state.clip.forceBackward = !(params && params.forwardOnly);
    scroller.workflow.call({
      process: UserClip.process,
      status: ProcessStatus.next
    });
  }
}

class Update extends BaseAdapterProcessFactory(AdapterProcess.update) {
  static run(scroller, options) {
    const { params } = Update.parseInput(scroller, options);
    if (!params) {
      return;
    }
    const shouldUpdate = Update.doUpdate(scroller, params);
    scroller.workflow.call({
      process: Update.process,
      status: shouldUpdate ? ProcessStatus.next : ProcessStatus.done
    });
  }
  static doUpdate(scroller, params) {
    const { buffer, viewport, state: { fetch }, routines, logger } = scroller;
    if (!buffer.items) {
      logger.log(() => 'no items in Buffer');
      return false;
    }
    const before = [...buffer.items];
    const { item: firstItem, index: firstIndex, diff: firstItemDiff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);
    const trackedIndex = buffer.updateItems(params.predicate, (index, data) => new Item(index, data, routines), firstIndex, !!params.fixRight);
    let delta = 0;
    const trackedItem = buffer.get(trackedIndex);
    if (firstItem && firstItem === trackedItem) {
      delta = -buffer.getSizeByIndex(trackedIndex) + firstItemDiff;
    }
    const itemsToRemove = before.filter(({ toRemove }) => toRemove);
    itemsToRemove.forEach(item => item.hide());
    logger.log(() => itemsToRemove.length
      ? 'items to remove: [' + itemsToRemove.map(({ $index }) => $index).join(',') + ']'
      : 'no items to remove');
    const itemsToRender = buffer.items.filter(({ toInsert }) => toInsert);
    logger.log(() => itemsToRender.length
      ? 'items to render: [' + itemsToRender.map(({ $index }) => $index).join(',') + ']'
      : 'no items to render');
    fetch.update(trackedIndex, delta, itemsToRender, itemsToRemove);
    return !!itemsToRemove.length || !!itemsToRender.length;
  }
}

class Insert extends BaseAdapterProcessFactory(AdapterProcess.insert) {
  static run(scroller, options) {
    const { params } = Insert.parseInput(scroller, options);
    if (!params) {
      return;
    }
    const shouldInsert = Insert.doInsert(scroller, params);
    scroller.workflow.call({
      process: Insert.process,
      status: shouldInsert ? ProcessStatus.next : ProcessStatus.done
    });
  }
  static doInsert(scroller, params) {
    const { before, after, items, decrease } = params;
    const method = (before || after);
    const found = scroller.buffer.items.find(item => method(item.get()));
    if (!found) {
      scroller.logger.log('no item to insert found');
      return false;
    }
    const indexToInsert = found.$index;
    const updateOptions = {
      predicate: ({ $index, data }) => {
        if (indexToInsert === $index) {
          return before ? [...items, data] : [data, ...items];
        }
        return true;
      },
      fixRight: decrease
    };
    return Update.doUpdate(scroller, updateOptions);
  }
}

class Replace extends BaseAdapterProcessFactory(AdapterProcess.replace) {
  static run(scroller, options) {
    const { params } = Replace.parseInput(scroller, options);
    if (!params) {
      return;
    }
    const shouldReplace = Replace.doReplace(scroller, params);
    scroller.workflow.call({
      process: Replace.process,
      status: shouldReplace ? ProcessStatus.next : ProcessStatus.done,
    });
  }
  static doReplace(scroller, params) {
    const toRemove = scroller.buffer.items
      .filter(item => params.predicate(item))
      .map(item => item.$index);
    if (!toRemove.length) {
      scroller.logger.log('no items to be replaced');
      return false;
    }
    let injected = false;
    const updateOptions = {
      predicate: ({ $index }) => {
        if (!toRemove.includes($index)) {
          return true;
        }
        if (!injected) {
          injected = true;
          return params.items;
        }
        return false;
      },
      fixRight: params.fixRight
    };
    return Update.doUpdate(scroller, updateOptions);
  }
}

const { [AdapterProcess.fix]: FixParams } = AdapterMethods;
class Fix extends BaseAdapterProcessFactory(AdapterProcess.fix) {
  static run(scroller, options) {
    const { workflow } = scroller;
    const { data, params } = Fix.parseInput(scroller, options);
    if (!params) {
      return;
    }
    Object.entries(data.params).forEach(([key, value]) => {
      if (value.isSet && value.isValid) {
        Fix.runByType(scroller, key, value.value, data);
      }
    });
    workflow.call({
      process: Fix.process,
      status: ProcessStatus.done
    });
  }
  static runByType(scroller, token, value, methodData) {
    switch (token) {
      case FixParams.scrollPosition:
        return Fix.setScrollPosition(scroller, value);
      case FixParams.minIndex:
        return Fix.setMinIndex(scroller, value);
      case FixParams.maxIndex:
        return Fix.setMaxIndex(scroller, value);
      case FixParams.updater:
        return Fix.updateItems(scroller, value);
      case FixParams.scrollToItem:
        if (methodData.params) {
          const scrollToItemOpt = methodData.params[FixParams.scrollToItemOpt];
          const options = scrollToItemOpt ? scrollToItemOpt.value : void 0;
          return Fix.scrollToItem(scroller, value, options);
        }
        return;
      case FixParams.scrollToItemOpt:
        return;
    }
  }
  static setScrollPosition({ viewport }, value) {
    let result = value;
    if (value === -Infinity) {
      result = 0;
    }
    else if (value === Infinity) {
      result = viewport.getScrollableSize();
    }
    viewport.setPosition(result);
  }
  static setMinIndex({ buffer, settings }, value) {
    settings.minIndex = value;
    buffer.absMinIndex = value;
  }
  static setMaxIndex({ buffer, settings }, value) {
    settings.maxIndex = value;
    buffer.absMaxIndex = value;
  }
  static updateItems({ buffer, logger }, value) {
    let updateReference = false;
    const updater = () => updateReference = true;
    buffer.items.forEach(item => value(item.get(), updater));
    if (updateReference) {
      logger.log(() => 'update Buffer.items reference');
      buffer.items = [...buffer.items];
    }
  }
  static scrollToItem(scroller, value, options) {
    const found = scroller.buffer.items.find(item => value(item.get()));
    if (!found) {
      scroller.logger.log(() => 'scrollToItem cancelled, item not found');
      return;
    }
    found.scrollTo(options);
  }
}

class Start extends BaseProcessFactory(CommonProcess.start) {
  static run(scroller) {
    const payload = scroller.state.startInnerLoop();
    scroller.workflow.call({
      process: Start.process,
      status: ProcessStatus.next,
      payload
    });
  }
}

class PreFetch extends BaseProcessFactory(CommonProcess.preFetch) {
  static run(scroller) {
    const { workflow, buffer, state: { fetch, cycle } } = scroller;
    fetch.minIndex = buffer.minIndex;
    // set first and last indexes of items to fetch
    PreFetch.setPositionsAndIndexes(scroller);
    // skip indexes that are in buffer
    PreFetch.skipBufferedItems(scroller);
    if (scroller.settings.infinite) {
      // fill indexes to include buffer if no clip
      PreFetch.checkBufferGaps(scroller);
    }
    // add indexes if there are too few items to fetch (clip padding)
    PreFetch.checkFetchPackSize(scroller);
    // set fetch direction
    PreFetch.setFetchDirection(scroller);
    workflow.call({
      process: PreFetch.process,
      status: PreFetch.getStatus(scroller),
      payload: { process: cycle.initiator }
    });
  }
  static setPositionsAndIndexes(scroller) {
    PreFetch.setPositions(scroller);
    PreFetch.setFirstIndex(scroller);
    PreFetch.setLastIndex(scroller);
    scroller.logger.fetch();
  }
  static setPositions(scroller) {
    const { state: { fetch: { positions } }, viewport } = scroller;
    const paddingDelta = viewport.getBufferPadding();
    positions.before = viewport.scrollPosition;
    positions.startDelta = PreFetch.getStartDelta(scroller);
    positions.relative = positions.before - positions.startDelta;
    positions.start = positions.relative - paddingDelta;
    positions.end = positions.relative + viewport.getSize() + paddingDelta;
  }
  static getStartDelta(scroller) {
    const { buffer, viewport: { offset } } = scroller;
    let startDelta = 0;
    if (offset) {
      startDelta += offset;
    }
    if (!buffer.defaultSize) {
      return startDelta;
    }
    for (let index = buffer.finiteAbsMinIndex; index < buffer.startIndex; index++) {
      startDelta += buffer.getSizeByIndex(index);
    }
    scroller.logger.log(() => [
      `start delta is ${startDelta}`, ...(offset ? [` (+${offset} offset)`] : [])
    ]);
    return startDelta;
  }
  static setFirstIndex(scroller) {
    const { state, buffer } = scroller;
    const { positions: { start }, first } = state.fetch;
    let firstIndex = buffer.startIndex;
    let firstIndexPosition = 0;
    if (state.cycle.innerLoop.isInitial) {
      scroller.logger.log('skipping fetch backward direction [initial loop]');
    }
    else if (!buffer.defaultSize) {
      scroller.logger.log('skipping fetch backward direction [no item size]');
    }
    else {
      let position = firstIndexPosition;
      let index = firstIndex;
      while (1) { // eslint-disable-line no-constant-condition
        if (start >= 0) {
          const size = buffer.getSizeByIndex(index);
          const diff = (position + size) - start;
          if (diff > 0) {
            firstIndex = index;
            firstIndexPosition = position;
            break;
          }
          position += size;
          index++;
          if (index < buffer.absMinIndex) {
            break;
          }
        }
        if (start < 0) {
          index--;
          if (index < buffer.absMinIndex) {
            break;
          }
          position -= buffer.getSizeByIndex(index);
          const diff = position - start;
          firstIndex = index;
          firstIndexPosition = position;
          if (diff <= 0) {
            break;
          }
        }
      }
    }
    first.index = first.indexBuffer = Math.max(firstIndex, buffer.absMinIndex);
    first.position = firstIndexPosition;
  }
  static setLastIndex(scroller) {
    const { state: { fetch, cycle }, buffer, settings } = scroller;
    const { positions: { relative, end }, first, last } = fetch;
    let lastIndex;
    if (!buffer.defaultSize) {
      // just to fetch forward bufferSize items if neither averageItemSize nor itemSize are present
      lastIndex = buffer.startIndex + settings.bufferSize - 1;
      scroller.logger.log('forcing fetch forward direction [no item size]');
    }
    else {
      let index = first.indexBuffer;
      let position = first.position;
      lastIndex = index;
      while (1) { // eslint-disable-line no-constant-condition
        lastIndex = index;
        const size = buffer.getSizeByIndex(index);
        position += size;
        if (isNaN(fetch.firstVisibleIndex) && position > relative) {
          fetch.firstVisibleIndex = index;
          if (!cycle.innerLoop.isInitial) {
            fetch.firstVisibleItemDelta = position - size - relative;
          }
        }
        if (position >= end) {
          break;
        }
        if (index++ > buffer.absMaxIndex) {
          break;
        }
      }
    }
    last.index = last.indexBuffer = Math.min(lastIndex, buffer.absMaxIndex);
  }
  static skipBufferedItems(scroller) {
    const { buffer } = scroller;
    if (!buffer.size) {
      return;
    }
    const { fetch } = scroller.state;
    const firstIndex = fetch.first.index;
    const lastIndex = fetch.last.index;
    const packs = [[]];
    let p = 0;
    for (let i = firstIndex; i <= lastIndex; i++) {
      if (!buffer.get(i)) {
        packs[p].push(i);
      }
      else if (packs[p].length) {
        packs[++p] = [];
      }
    }
    let pack = packs[0];
    if (packs[0].length && packs[1] && packs[1].length) {
      fetch.hasAnotherPack = true;
      // todo: need to look for biggest pack in visible area
      // todo: or think about merging two requests in a single Fetch process
      if (packs[1].length >= packs[0].length) {
        pack = packs[1];
      }
    }
    fetch.first.index = Math.max(pack[0], buffer.absMinIndex);
    fetch.last.index = Math.min(pack[pack.length - 1], buffer.absMaxIndex);
    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {
      scroller.logger.fetch('after Buffer flushing');
    }
  }
  static checkBufferGaps(scroller) {
    const { buffer, state: { fetch } } = scroller;
    if (!buffer.size) {
      return;
    }
    const fetchFirst = fetch.first.index;
    const bufferLast = buffer.lastIndex;
    if (fetchFirst > bufferLast) {
      fetch.first.index = fetch.first.indexBuffer = bufferLast + 1;
    }
    const bufferFirst = buffer.firstIndex;
    const fetchLast = fetch.last.index;
    if (fetchLast < bufferFirst) {
      fetch.last.index = fetch.last.indexBuffer = bufferFirst - 1;
    }
    if (fetch.first.index !== fetchFirst || fetch.last.index !== fetchLast) {
      scroller.logger.fetch('after Buffer filling (no clip case)');
    }
  }
  static checkFetchPackSize(scroller) {
    const { buffer, state: { fetch } } = scroller;
    if (!fetch.shouldFetch) {
      return;
    }
    const firstIndex = fetch.first.index;
    const lastIndex = fetch.last.index;
    const diff = scroller.settings.bufferSize - (lastIndex - firstIndex + 1);
    if (diff <= 0) {
      return;
    }
    if (!buffer.size || lastIndex > buffer.items[0].$index) { // forward
      const newLastIndex = Math.min(lastIndex + diff, buffer.absMaxIndex);
      if (newLastIndex > lastIndex) {
        fetch.last.index = fetch.last.indexBuffer = newLastIndex;
      }
    }
    else {
      const newFirstIndex = Math.max(firstIndex - diff, buffer.absMinIndex);
      if (newFirstIndex < firstIndex) {
        fetch.first.index = fetch.first.indexBuffer = newFirstIndex;
      }
    }
    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {
      scroller.logger.fetch('after bufferSize adjustment');
      PreFetch.skipBufferedItems(scroller);
    }
  }
  static setFetchDirection(scroller) {
    const { buffer, state: { fetch } } = scroller;
    if (fetch.last.index) {
      let direction = Direction.forward;
      if (buffer.size) {
        direction = fetch.last.index < buffer.items[0].$index ? Direction.backward : Direction.forward;
      }
      fetch.direction = direction;
      scroller.logger.log(() => `fetch direction is "${direction}"`);
    }
  }
  static getStatus(scroller) {
    const { cycle, fetch } = scroller.state;
    if (cycle.initiator === AdapterProcess.clip) {
      scroller.logger.log(() => `going to skip fetch due to "${AdapterProcess.clip}" process`);
      return ProcessStatus.next;
    }
    if (fetch.shouldFetch) {
      scroller.logger.log(() => `going to fetch ${fetch.count} items started from index ${fetch.index}`);
      return ProcessStatus.next;
    }
    return ProcessStatus.done;
  }
}

class Fetch extends BaseProcessFactory(CommonProcess.fetch) {
  static run(scroller) {
    const { workflow } = scroller;
    const box = {
      success: (data) => {
        scroller.logger.log(() => `resolved ${data.length} items ` +
          `(index = ${scroller.state.fetch.index}, count = ${scroller.state.fetch.count})`);
        scroller.state.fetch.newItemsData = data;
        workflow.call({
          process: Fetch.process,
          status: ProcessStatus.next
        });
      },
      fail: (error) => workflow.call({
        process: Fetch.process,
        status: ProcessStatus.error,
        payload: { error }
      })
    };
    const result = Fetch.get(scroller);
    Fetch.complete(scroller, box, result);
  }
  static complete(scroller, box, result) {
    if (Object.prototype.hasOwnProperty.call(result, 'data')) {
      const { data, error, isError } = result;
      if (!isError) {
        box.success(data || []);
      }
      else {
        box.fail(error);
      }
    }
    else {
      const { state: { scrollState, fetch }, viewport } = scroller;
      if (scrollState.positionBeforeAsync === null) {
        scrollState.positionBeforeAsync = viewport.scrollPosition;
      }
      fetch.cancel = () => {
        box.success = () => null;
        box.fail = () => null;
      };
      result.then((data) => box.success(data), (error) => box.fail(error));
    }
  }
  static get(scroller) {
    const _get = scroller.datasource.get;
    const { index, count } = scroller.state.fetch;
    let immediateData, immediateError;
    let resolve, reject;
    const done = (data) => {
      if (!resolve) {
        immediateData = data || null;
        return;
      }
      resolve(data);
    };
    const fail = (error) => {
      if (!reject) {
        immediateError = error || null;
        return;
      }
      reject(error);
    };
    const getResult = _get(index, count, done, fail);
    if (getResult && typeof getResult === 'object' && getResult !== null) {
      if (typeof getResult.then === 'function') {
        return getResult;
      }
      else if (typeof getResult.subscribe === 'function') {
        const sub = getResult.subscribe(done, fail, () => {
          if (sub && typeof sub === 'object' && typeof sub.unsubscribe === 'function') {
            sub.unsubscribe();
          }
        });
      }
    }
    if (immediateData || immediateError) { // callback case or immediate observable
      return {
        data: immediateError ? null : (immediateData || []),
        error: immediateError,
        isError: !!immediateError
      };
    }
    return new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    });
  }
}

class PostFetch extends BaseProcessFactory(CommonProcess.postFetch) {
  static run(scroller) {
    const { workflow } = scroller;
    if (PostFetch.setItems(scroller)) {
      PostFetch.setBufferLimits(scroller);
      workflow.call({
        process: PostFetch.process,
        status: scroller.state.fetch.hasNewItems
          ? ProcessStatus.next
          : ProcessStatus.done
      });
    }
    else {
      workflow.call({
        process: PostFetch.process,
        status: ProcessStatus.error,
        payload: { error: 'Can\'t set buffer items' }
      });
    }
  }
  static setBufferLimits(scroller) {
    const { buffer, state: { fetch, fetch: { items }, cycle: { innerLoop } } } = scroller;
    const first = fetch.first.index;
    const last = fetch.last.index;
    if (!items.length) {
      if (last < buffer.minIndex || innerLoop.isInitial) {
        buffer.absMinIndex = buffer.minIndex;
      }
      if (first > buffer.maxIndex || innerLoop.isInitial) {
        buffer.absMaxIndex = buffer.maxIndex;
      }
    }
    else {
      const lastIndex = items.length - 1;
      if (first < items[0].$index) {
        buffer.absMinIndex = items[0].$index;
      }
      if (last > items[lastIndex].$index) {
        buffer.absMaxIndex = items[lastIndex].$index;
      }
    }
  }
  static setItems(scroller) {
    const { buffer, state: { fetch, cycle } } = scroller;
    const items = fetch.newItemsData;
    if (!items || !items.length) { // empty result
      return true;
    }
    // eof/bof case, need to shift fetch index if bof
    let fetchIndex = fetch.index;
    if (items.length < fetch.count) {
      if (cycle.innerLoop.isInitial) {
        // let's treat initial poor fetch as startIndex-bof
        fetchIndex = buffer.startIndex;
      }
      else if (fetch.first.index < buffer.minIndex) { // normal bof
        fetchIndex = buffer.minIndex - items.length;
      }
    }
    fetch.items = items.map((item, index) => new Item(fetchIndex + index, item, scroller.routines));
    fetch.isPrepend = !!buffer.items.length && buffer.items[0].$index > fetch.items[fetch.items.length - 1].$index;
    return buffer.setItems(fetch.items);
  }
}

class Render extends BaseProcessFactory(CommonProcess.render) {
  static run(scroller) {
    const { workflow, state: { cycle, render, scrollState }, viewport } = scroller;
    scroller.logger.stat('before new items render');
    if (scrollState.positionBeforeAsync === null) {
      scrollState.positionBeforeAsync = viewport.scrollPosition;
    }
    render.renderTimer = setTimeout(() => {
      render.renderTimer = null;
      if (Render.doRender(scroller)) {
        workflow.call({
          process: Render.process,
          status: render.noSize ? ProcessStatus.done : ProcessStatus.next,
          payload: { process: cycle.initiator }
        });
      }
      else {
        workflow.call({
          process: Render.process,
          status: ProcessStatus.error,
          payload: { error: 'Can\'t associate item with element' }
        });
      }
    }, 0);
  }
  static doRender(scroller) {
    const { state: { fetch, render }, viewport, buffer, logger } = scroller;
    render.positionBefore = viewport.scrollPosition;
    if (!fetch.isCheck) {
      render.sizeBefore = viewport.getScrollableSize();
      if (fetch.items.map(item => Render.processElement(scroller, item)).some(x => !x)) {
        return false;
      }
    }
    buffer.checkDefaultSize();
    render.sizeAfter = viewport.getScrollableSize();
    logger.stat('after new items render');
    logger.log(() => render.noSize ? 'viewport size has not been changed' : void 0);
    return true;
  }
  static processElement(scroller, item) {
    const { state: { fetch }, viewport, buffer } = scroller;
    const element = viewport.element.querySelector(`[data-sid="${item.nodeId}"]`);
    if (!element) {
      return false;
    }
    item.element = element;
    item.element.style.left = '';
    item.element.style.top = '';
    item.element.style.position = '';
    item.invisible = false;
    item.setSize();
    buffer.cacheItem(item);
    if (item.$index < fetch.minIndex) {
      fetch.negativeSize += item.size;
    }
    return true;
  }
}

class Adjust extends BaseProcessFactory(CommonProcess.adjust) {
  static run(scroller) {
    const { workflow, viewport, state: { scrollState } } = scroller;
    scrollState.positionBeforeAdjust = viewport.scrollPosition;
    Adjust.setPaddings(scroller);
    scrollState.positionAfterAdjust = viewport.scrollPosition;
    // scroll position adjustments
    const position = Adjust.calculatePosition(scroller);
    // set new position using animation frame
    Adjust.setPosition(scroller, position, () => workflow.call({
      process: Adjust.process,
      status: ProcessStatus.done
    }));
  }
  static setPaddings(scroller) {
    const { viewport, buffer, settings: { inverse }, state: { fetch } } = scroller;
    const firstItem = buffer.getFirstVisibleItem();
    const lastItem = buffer.getLastVisibleItem();
    let first, last;
    if (firstItem && lastItem) {
      first = firstItem.$index;
      last = lastItem.$index;
    }
    else {
      first = !isNaN(fetch.firstVisibleIndex) ? fetch.firstVisibleIndex : buffer.startIndex;
      last = first - 1;
    }
    const { forward, backward } = viewport.paddings;
    let index, bwdSize = 0, fwdSize = 0;
    // new backward and forward paddings size
    for (index = buffer.finiteAbsMinIndex; index < first; index++) {
      bwdSize += buffer.getSizeByIndex(index);
    }
    for (index = last + 1; index <= buffer.finiteAbsMaxIndex; index++) {
      fwdSize += buffer.getSizeByIndex(index);
    }
    // lack of items case
    const bufferSize = viewport.getScrollableSize() - forward.size - backward.size;
    const viewportSizeDiff = viewport.getSize() - (bwdSize + bufferSize + fwdSize);
    if (viewportSizeDiff > 0) {
      if (inverse) {
        bwdSize += viewportSizeDiff;
      }
      else {
        fwdSize += viewportSizeDiff;
      }
      scroller.logger.log(() => inverse ? 'backward' : 'forward' + ` padding will be increased by ${viewportSizeDiff} to fill the viewport`);
    }
    backward.size = bwdSize;
    forward.size = fwdSize;
    scroller.logger.stat('after paddings adjustments');
  }
  static calculatePosition(scroller) {
    const { viewport, buffer, state } = scroller;
    const { fetch, render, scrollState } = state;
    let position = viewport.paddings.backward.size;
    // backward outlet increase
    if (!isNaN(fetch.firstVisibleIndex) && !isNaN(buffer.firstIndex)) {
      for (let i = buffer.firstIndex; i < fetch.firstVisibleIndex; i++) {
        position += buffer.getSizeByIndex(i);
      }
      if (fetch.firstVisibleItemDelta) {
        position -= fetch.firstVisibleItemDelta;
      }
    }
    else {
      if (fetch.isPrepend && fetch.negativeSize) {
        position += fetch.negativeSize;
      }
    }
    // change per slow fetch/render
    if (scrollState.positionBeforeAsync !== null) {
      const diff = render.positionBefore - scrollState.positionBeforeAsync;
      if (diff !== 0) {
        scroller.logger.log(`shift position due to fetch-render difference (${diff})`);
        position += diff;
      }
    }
    // offset increase
    if (viewport.offset > 0 && (position || fetch.positions.before)) {
      position += viewport.offset;
    }
    return Math.round(position);
  }
  static setPosition(scroller, position, done) {
    const { state: { scrollState }, viewport } = scroller;
    if (!scrollState.hasPositionChanged(position)) {
      return done();
    }
    scrollState.syntheticPosition = position;
    scrollState.syntheticFulfill = false;
    scrollState.animationFrameId = requestAnimationFrame(() => {
      const inertiaDiff = scrollState.positionAfterAdjust - viewport.scrollPosition;
      let diffLog = '';
      if (inertiaDiff > 0) {
        position -= inertiaDiff;
        scrollState.syntheticPosition = position;
        diffLog = ` (-${inertiaDiff})`;
      }
      scrollState.syntheticFulfill = true;
      viewport.scrollPosition = position;
      scroller.logger.stat('after scroll adjustment' + diffLog);
      done();
    });
  }
}

class PreClip extends BaseProcessFactory(CommonProcess.preClip) {
  static run(scroller) {
    PreClip.prepareClip(scroller);
    scroller.workflow.call({
      process: PreClip.process,
      status: ProcessStatus.next,
      payload: {
        doClip: scroller.state.clip.doClip
      }
    });
  }
  static prepareClip(scroller) {
    const { state: { fetch, clip } } = scroller;
    if (PreClip.shouldNotClip(scroller)) {
      return;
    }
    const firstIndex = fetch.first.indexBuffer;
    const lastIndex = fetch.last.indexBuffer;
    scroller.logger.log(() => `looking for ${fetch.direction ? 'anti-' + fetch.direction + ' ' : ''}items ` +
      `that are out of [${firstIndex}..${lastIndex}] range`);
    if (PreClip.isBackward(scroller, firstIndex)) {
      PreClip.prepareClipByDirection(scroller, Direction.backward, firstIndex);
    }
    if (PreClip.isForward(scroller, lastIndex)) {
      PreClip.prepareClipByDirection(scroller, Direction.forward, lastIndex);
    }
    if (!clip.doClip) {
      scroller.logger.log('skipping clip [no items to clip]');
    }
    return;
  }
  static shouldNotClip(scroller) {
    const { settings, buffer, state } = scroller;
    if (settings.infinite && !state.clip.force) {
      scroller.logger.log('skipping clip [infinite mode]');
      return true;
    }
    if (!buffer.size) {
      scroller.logger.log('skipping clip [empty buffer]');
      return true;
    }
    if (state.cycle.isInitial) {
      scroller.logger.log('skipping clip [initial cycle]');
      return true;
    }
    return false;
  }
  static isBackward(scroller, firstIndex) {
    const { buffer, state: { clip, fetch } } = scroller;
    if (clip.force) {
      return clip.forceBackward;
    }
    if (fetch.direction !== Direction.backward) {
      if (firstIndex - 1 >= buffer.absMinIndex) {
        return true;
      }
    }
    return false;
  }
  static isForward(scroller, lastIndex) {
    const { buffer, state: { clip, fetch } } = scroller;
    if (clip.force) {
      return clip.forceForward;
    }
    if (fetch.direction !== Direction.forward) {
      if (lastIndex + 1 <= buffer.absMaxIndex) {
        return true;
      }
    }
    return false;
  }
  static prepareClipByDirection(scroller, direction, edgeIndex) {
    const forward = direction === Direction.forward;
    scroller.buffer.items.forEach(item => {
      if ((!forward && item.$index < edgeIndex) ||
        (forward && item.$index > edgeIndex)) {
        item.toRemove = true;
        item.removeDirection = direction;
        scroller.state.clip.doClip = true;
      }
    });
  }
}

class Clip extends BaseProcessFactory(CommonProcess.clip) {
  static run(scroller) {
    const { workflow } = scroller;
    Clip.doClip(scroller);
    workflow.call({
      process: Clip.process,
      status: ProcessStatus.next
    });
  }
  static doClip(scroller) {
    const { buffer, viewport: { paddings }, state: { clip }, logger } = scroller;
    const size = { [Direction.backward]: 0, [Direction.forward]: 0 };
    logger.stat(`before clip (${++clip.callCount})`);
    const itemsToRemove = buffer.items.filter(item => {
      if (!item.toRemove) {
        return false;
      }
      item.hide();
      size[item.removeDirection] += item.size;
      return true;
    });
    if (itemsToRemove.length) {
      if (size[Direction.backward]) {
        paddings.byDirection(Direction.backward).size += size[Direction.backward];
      }
      if (size[Direction.forward]) {
        paddings.byDirection(Direction.forward).size += size[Direction.forward];
      }
      if (scroller.settings.onBeforeClip) {
        scroller.settings.onBeforeClip(itemsToRemove.map(item => item.get()));
      }
    }
    buffer.clip();
    logger.log(() => {
      const list = itemsToRemove.map(({ $index }) => $index);
      return list.length
        ? [
          `clipped ${list.length} item(s) from Buffer` +
            (size.backward ? `, +${size.backward} fwd px` : '') +
            (size.forward ? `, +${size.forward} bwd px` : '') +
            `, range: [${list[0]}..${list[list.length - 1]}]`
        ]
        : 'clipped 0 items from Buffer';
    });
    logger.stat('after clip');
  }
}

const isInterrupted = ({ call }) => !!call.interrupted;
class End extends BaseProcessFactory(CommonProcess.end) {
  static run(scroller, { error } = {}) {
    const { workflow, state: { cycle: { interrupter } } } = scroller;
    if (!error && !interrupter) {
      // set out params accessible via Adapter
      End.calculateParams(scroller, workflow);
    }
    // explicit interruption for we don't want to go through the inner loop finalizing
    if (isInterrupted(workflow)) {
      workflow.call({ process: End.process, status: ProcessStatus.done });
      return;
    }
    const next = End.finalizeInnerLoop(scroller, error);
    workflow.call({
      process: End.process,
      status: next ? ProcessStatus.next : ProcessStatus.done,
      payload: Object.assign({}, (interrupter ? { process: interrupter } : {}))
    });
  }
  static calculateParams(scroller, workflow) {
    const { adapter, viewport, buffer: { items } } = scroller;
    if (adapter.wanted.firstVisible) {
      const { item } = viewport.getEdgeVisibleItem(items, Direction.backward);
      if (!item || item.element !== adapter.firstVisible.element) {
        adapter.firstVisible = item ? item.get() : EMPTY_ITEM;
      }
    }
    // the workflow can be interrupter on firstVisible change
    if (adapter.wanted.lastVisible && !isInterrupted(workflow)) {
      const { item } = viewport.getEdgeVisibleItem(items, Direction.forward);
      if (!item || item.element !== adapter.lastVisible.element) {
        adapter.lastVisible = item ? item.get() : EMPTY_ITEM;
      }
    }
  }
  static finalizeInnerLoop(scroller, error) {
    const { state, state: { cycle, clip, fetch } } = scroller;
    const next = !!cycle.interrupter || (error ? false : End.getNext(scroller));
    cycle.innerLoop.isInitial = false;
    fetch.stopSimulate();
    clip.reset(true);
    state.endInnerLoop();
    return next;
  }
  static getNext(scroller) {
    const { state: { fetch, render } } = scroller;
    if (fetch.simulate && fetch.isCheck && !render.noSize) { // Adapter.check
      return true;
    }
    if (fetch.simulate && fetch.doRemove) { // Adapter.remove or Adapter.update with clip
      return true;
    }
    if ( // common inner loop (App start, Scroll, Adapter.clip) accompanied by fetch
    !fetch.simulate && ((fetch.hasNewItems && !render.noSize) || fetch.hasAnotherPack)) {
      return true;
    }
    return false;
  }
}

class Logger {
  constructor(scroller, packageInfo, adapter) {
    this.logs = [];
    this.logAdapterMethod = (methodName, args, add) => {
      if (!this.debug) {
        return;
      }
      const params = (args === void 0 ? [] : (Array.isArray(args) ? args : [args]))
        .map((arg) => {
        if (typeof arg === 'function') {
          return 'func';
        }
        else if (typeof arg !== 'object' || !arg) {
          return arg;
        }
        else if (Array.isArray(arg)) {
          return `[of ${arg.length}]`;
        }
        return '{ ' + Object.keys(arg).join(', ') + ' }';
      })
        .join(', ');
      this.log(`adapter: ${methodName}(${params || ''})${add || ''}`);
    };
    const { settings } = scroller;
    this.debug = settings.debug;
    this.immediateLog = settings.immediateLog;
    this.logTime = settings.logTime;
    this.getTime = () => scroller.state && ` // time: ${scroller.state.time}`;
    this.getStat = () => {
      const { buffer, viewport } = scroller;
      const first = buffer.getFirstVisibleItem();
      const last = buffer.getLastVisibleItem();
      return 'pos: ' + viewport.scrollPosition + ', ' +
        'size: ' + viewport.getScrollableSize() + ', ' +
        'bwd_p: ' + viewport.paddings.backward.size + ', ' +
        'fwd_p: ' + viewport.paddings.forward.size + ', ' +
        'default: ' + (buffer.defaultSize || 'no') + ', ' +
        'items: ' + buffer.getVisibleItemsCount() + ', ' +
        'range: ' + (first && last ? `[${first.$index}..${last.$index}]` : 'no');
    };
    this.getFetchRange = () => {
      const { first: { index: first }, last: { index: last } } = scroller.state.fetch;
      return !Number.isNaN(first) && !Number.isNaN(last)
        ? `[${first}..${last}]`
        : 'no';
    };
    this.getLoopId = () => scroller.state.cycle.loopId;
    this.getLoopIdNext = () => scroller.state.cycle.loopIdNext;
    this.getWorkflowCycleData = () => `${settings.instanceIndex}-${scroller.state.cycle.count}`;
    this.getScrollPosition = (element) => scroller.routines.getScrollPosition(element);
    this.log(() => 'vscroll Workflow has been started, ' +
      `core: ${packageInfo.core.name} v${packageInfo.core.version}, ` +
      `consumer: ${packageInfo.consumer.name} v${packageInfo.consumer.version}, ` +
      `workflow instance: ${settings.instanceIndex}, adapter ` +
      (!adapter ? 'is not instantiated' : `instance: ${adapter.id}`));
  }
  object(str, obj, stringify) {
    this.log(() => [
      str,
      stringify
        ? JSON.stringify(obj, (k, v) => {
          if (Number.isNaN(v)) {
            return 'NaN';
          }
          if (v === Infinity) {
            return 'Infinity';
          }
          if (v === -Infinity) {
            return '-Infinity';
          }
          if (v instanceof Element) {
            return 'HTMLElement';
          }
          if (v instanceof HTMLDocument) {
            return 'HTMLDocument';
          }
          if (typeof v === 'function') {
            return 'Function';
          }
          return v;
        })
          .replace(/"/g, '')
          .replace(/(\{|:|,)/g, '$1 ')
          .replace(/(\})/g, ' $1')
        : obj
    ]);
  }
  stat(str) {
    if (this.debug) {
      const logStyles = [
        'color: #888; border: dashed #888 0; border-bottom-width: 0px',
        'color: #000; border-width: 0'
      ];
      this.log(() => ['%cstat' + (str ? ` ${str}` : '') + ',%c ' + this.getStat(), ...logStyles]);
    }
  }
  fetch(str) {
    if (this.debug) {
      const _text = 'fetch interval' + (str ? ` ${str}` : '');
      const logStyles = ['color: #888', 'color: #000'];
      this.log(() => [`%c${_text}: %c${this.getFetchRange()}`, ...logStyles]);
    }
  }
  prepareForLog(data) {
    return data instanceof Event && data.target
      ? this.getScrollPosition(data.target)
      : data;
  }
  logProcess(data) {
    if (!this.debug) {
      return;
    }
    const { process, status, payload } = data;
    // inner loop start-end log
    const loopLog = [];
    if (process === CommonProcess.init && status === ProcessStatus.next) {
      loopLog.push(`%c---=== loop ${this.getLoopIdNext()} start`);
    }
    else if (process === CommonProcess.end) {
      loopLog.push(`%c---=== loop ${this.getLoopId()} done`);
      const parent = payload && payload.process;
      if (status === ProcessStatus.next && (parent !== AdapterProcess.reset && parent !== AdapterProcess.reload)) {
        loopLog[0] += `, loop ${this.getLoopIdNext()} start`;
      }
    }
    if (loopLog.length) {
      this.log(() => [...loopLog, 'color: #006600;']);
    }
  }
  logCycle(start = true) {
    const logData = this.getWorkflowCycleData();
    const border = start ? '1px 0 0 1px' : '0 0 1px 1px';
    const logStyles = `color: #0000aa; border: solid #555 1px; border-width: ${border}; margin-left: -2px`;
    this.log(() => [`%c   ~~~ WF Cycle ${logData} ${start ? 'STARTED' : 'FINALIZED'} ~~~  `, logStyles]);
  }
  logError(str) {
    if (this.debug) {
      const logStyles = ['color: #a00;', 'color: #000'];
      this.log(() => ['error:%c' + (str ? ` ${str}` : '') + `%c (loop ${this.getLoopIdNext()})`, ...logStyles]);
    }
  }
  log(...args) {
    if (this.debug) {
      if (typeof args[0] === 'function') {
        args = args[0]();
        if (!Array.isArray(args)) {
          args = [args];
        }
      }
      if (args.every(item => item === void 0)) {
        return;
      }
      if (this.logTime) {
        args = [...args, this.getTime()];
      }
      args = args.map((arg) => this.prepareForLog(arg));
      if (this.immediateLog) {
        console.log.apply(this, args);
      }
      else {
        this.logs.push(args);
      }
    }
  }
  // logNow(...args: any[]) {
  //   const immediateLog = this.immediateLog;
  //   const debug = this.debug;
  //   (this as any).debug = true;
  //   (this as any).immediateLog = true;
  //   this.log.apply(this, args);
  //   (this as any).debug = debug;
  //   (this as any).immediateLog = immediateLog;
  // }
  logForce(...args) {
    if (this.debug) {
      if (!this.immediateLog && this.logs.length) {
        this.logs.forEach(logArgs => console.log.apply(this, logArgs));
        this.logs = [];
      }
      if (args.length) {
        console.log.apply(this, args);
      }
    }
  }
}

class Routines {
  constructor(settings) {
    this.horizontal = settings.horizontal;
    this.window = settings.windowViewport;
  }
  checkElement(element) {
    if (!element) {
      throw new Error('HTML element is not defined');
    }
  }
  getScrollPosition(element) {
    if (this.window) {
      return window.pageYOffset;
    }
    this.checkElement(element);
    return element[this.horizontal ? 'scrollLeft' : 'scrollTop'];
  }
  setScrollPosition(element, value) {
    value = Math.max(0, value);
    if (this.window) {
      if (this.horizontal) {
        window.scrollTo(value, window.scrollY);
      }
      else {
        window.scrollTo(window.scrollX, value);
      }
      return;
    }
    this.checkElement(element);
    element[this.horizontal ? 'scrollLeft' : 'scrollTop'] = value;
  }
  getParams(element, doNotBind) {
    this.checkElement(element);
    if (this.window && doNotBind) {
      return {
        'height': element.clientHeight,
        'width': element.clientWidth,
        'top': element.clientTop,
        'bottom': element.clientTop + element.clientHeight,
        'left': element.clientLeft,
        'right': element.clientLeft + element.clientWidth
      };
    }
    return element.getBoundingClientRect();
  }
  getSize(element, doNotBind) {
    return this.getParams(element, doNotBind)[this.horizontal ? 'width' : 'height'];
  }
  getSizeStyle(element) {
    this.checkElement(element);
    const size = element.style[this.horizontal ? 'width' : 'height'];
    return parseFloat(size) || 0;
  }
  setSizeStyle(element, value) {
    this.checkElement(element);
    value = Math.max(0, Math.round(value));
    element.style[this.horizontal ? 'width' : 'height'] = `${value}px`;
  }
  getEdge(element, direction, doNotBind) {
    const params = this.getParams(element, doNotBind);
    const isFwd = direction === Direction.forward;
    return params[isFwd ? (this.horizontal ? 'right' : 'bottom') : (this.horizontal ? 'left' : 'top')];
  }
  getEdge2(element, direction, relativeElement, opposite) {
    // vertical only ?
    return element.offsetTop - (relativeElement ? relativeElement.scrollTop : 0) +
      (direction === (!opposite ? Direction.forward : Direction.backward) ? this.getSize(element) : 0);
  }
  hideElement(element) {
    this.checkElement(element);
    element.style.display = 'none';
  }
  getOffset(element) {
    this.checkElement(element);
    return (this.horizontal ? element.offsetLeft : element.offsetTop) || 0;
  }
  scrollTo(element, argument) {
    this.checkElement(element);
    element.scrollIntoView(argument);
  }
}

class Padding {
  constructor(element, direction, routines) {
    this.element = element.querySelector(`[data-padding-${direction}]`);
    this.direction = direction;
    this.routines = routines;
  }
  reset(size) {
    this.size = size || 0;
  }
  get size() {
    return this.routines.getSizeStyle(this.element);
  }
  set size(value) {
    this.routines.setSizeStyle(this.element, value);
  }
}
class Paddings {
  constructor(element, routines, settings) {
    this.settings = settings;
    this.forward = new Padding(element, Direction.forward, routines);
    this.backward = new Padding(element, Direction.backward, routines);
  }
  byDirection(direction, opposite) {
    return direction === Direction.backward
      ? (opposite ? this.forward : this.backward)
      : (opposite ? this.backward : this.forward);
  }
  reset(viewportSize, startIndex, offset) {
    const positive = this.getPositiveSize(startIndex, viewportSize, offset);
    const negative = this.getNegativeSize(startIndex);
    if (this.settings.inverse) {
      this.forward.reset(negative);
      this.backward.reset(positive);
      const diff = viewportSize - this.backward.size - offset;
      if (diff > 0) {
        this.backward.size += diff;
        this.forward.size -= diff;
      }
    }
    else {
      this.forward.reset(positive);
      this.backward.reset(negative);
      const diff = viewportSize - this.forward.size - offset;
      if (diff > 0) {
        this.backward.size -= diff;
        this.forward.size += diff;
      }
    }
  }
  getPositiveSize(startIndex, viewportSize, offset) {
    const { settings } = this;
    let positiveSize = viewportSize;
    if (isFinite(settings.maxIndex)) {
      positiveSize = (settings.maxIndex - startIndex + 1) * settings.itemSize;
    }
    if (offset) {
      positiveSize = Math.max(positiveSize - offset, 0);
    }
    return positiveSize;
  }
  getNegativeSize(startIndex) {
    const { settings } = this;
    let negativeSize = 0;
    if (isFinite(settings.minIndex)) {
      negativeSize = (startIndex - settings.minIndex) * settings.itemSize;
    }
    return negativeSize;
  }
}

class Viewport {
  constructor(element, settings, routines, state, logger) {
    this.element = element;
    this.settings = settings;
    this.routines = routines;
    this.state = state;
    this.logger = logger;
    this.disabled = false;
    if (settings.windowViewport) {
      this.hostElement = document.documentElement;
      this.scrollEventReceiver = window;
    }
    else {
      this.hostElement = settings.viewport || this.element.parentElement;
      this.scrollEventReceiver = this.hostElement;
    }
    this.paddings = new Paddings(this.element, this.routines, settings);
    if (settings.windowViewport && 'scrollRestoration' in history) {
      history.scrollRestoration = 'manual';
    }
    if (settings.dismissOverflowAnchor) {
      this.hostElement.style.overflowAnchor = 'none';
    }
  }
  reset(startIndex) {
    this.setOffset();
    this.paddings.reset(this.getSize(), startIndex, this.offset);
    this.scrollPosition = this.paddings.backward.size || 0;
    this.state.scrollState.reset();
  }
  setPosition(value) {
    const oldPosition = this.scrollPosition;
    if (oldPosition === value) {
      this.logger.log(() => ['setting scroll position at', value, '[cancelled]']);
      return value;
    }
    this.routines.setScrollPosition(this.hostElement, value);
    const position = this.scrollPosition;
    this.logger.log(() => [
      'setting scroll position at', position, ...(position !== value ? [`(${value})`] : [])
    ]);
    return position;
  }
  get scrollPosition() {
    return this.routines.getScrollPosition(this.hostElement);
  }
  set scrollPosition(value) {
    this.setPosition(value);
  }
  disableScrollForOneLoop() {
    if (this.disabled) {
      return;
    }
    const { style } = this.hostElement;
    if (style.overflowY === 'hidden') {
      return;
    }
    this.disabled = true;
    const overflow = style.overflowY;
    setTimeout(() => {
      this.disabled = false;
      style.overflowY = overflow;
    });
    style.overflowY = 'hidden';
  }
  getSize() {
    return this.routines.getSize(this.hostElement, true);
  }
  getScrollableSize() {
    return this.routines.getSize(this.element);
  }
  getBufferPadding() {
    return this.getSize() * this.settings.padding;
  }
  getEdge(direction) {
    return this.routines.getEdge(this.hostElement, direction, true);
  }
  setOffset() {
    this.offset = this.routines.getOffset(this.element);
    if (!this.settings.windowViewport) {
      this.offset -= this.routines.getOffset(this.hostElement);
    }
  }
  getEdgeVisibleItem(items, direction) {
    const bwd = direction === Direction.backward;
    const opposite = bwd ? Direction.forward : Direction.backward;
    const viewportEdge = this.getEdge(direction);
    let item, diff = 0;
    for (let i = bwd ? 0 : items.length - 1; bwd ? i <= items.length - 1 : i >= 0; i += bwd ? 1 : -1) {
      const itemEdge = this.routines.getEdge(items[i].element, opposite);
      diff = itemEdge - viewportEdge;
      if (bwd && diff > 0 || !bwd && diff < 0) {
        item = items[i];
        break;
      }
    }
    return { item, index: item ? item.$index : NaN, diff };
  }
}

class SizesRecalculation {
  constructor() {
    this.reset();
  }
  reset() {
    this.newItems = [];
    this.oldItems = [];
    this.removed = [];
  }
}
class DefaultSize {
  constructor(itemSize, sizeStrategy) {
    this.itemSize = itemSize;
    this.sizeStrategy = sizeStrategy;
    this.sizeMap = new Map();
    this.recalculation = new SizesRecalculation();
  }
  reset(force) {
    if (force) {
      this.constantSize = this.itemSize;
      this.frequentSize = this.itemSize;
      this.averageSize = this.itemSize;
      this.averageSizeFloat = this.itemSize;
      this.sizeMap.clear();
    }
    this.recalculation.reset();
  }
  get() {
    switch (this.sizeStrategy) {
      case SizeStrategy.Average:
        return this.averageSize;
      case SizeStrategy.Frequent:
        return this.frequentSize;
      default:
        return this.constantSize;
    }
  }
  recalculateAverageSize(cacheSize) {
    const { oldItems, newItems, removed } = this.recalculation;
    if (oldItems.length) {
      const oldSize = oldItems.reduce((acc, item) => acc + item.size, 0);
      const newSize = oldItems.reduce((acc, item) => acc + item.newSize, 0);
      const averageSize = this.averageSizeFloat || 0;
      this.averageSizeFloat = averageSize - (oldSize - newSize) / (cacheSize - newItems.length);
    }
    if (newItems.length) {
      const newSize = newItems.reduce((acc, item) => acc + item.size, 0);
      const averageSize = this.averageSizeFloat || 0;
      this.averageSizeFloat = ((cacheSize - newItems.length) * averageSize + newSize) / cacheSize;
    }
    if (removed.length) {
      const removedSize = removed.reduce((acc, item) => acc + item.size, 0);
      const averageSize = this.averageSizeFloat || 0;
      this.averageSizeFloat = ((cacheSize + removed.length) * averageSize - removedSize) / cacheSize;
    }
    this.averageSize = Math.round(this.averageSizeFloat);
  }
  recalculateFrequentSize() {
    const { oldItems, newItems, removed } = this.recalculation;
    const oldFrequentSizeCount = this.sizeMap.get(this.frequentSize);
    if (newItems.length) {
      newItems.forEach(({ size }) => this.sizeMap.set(size, (this.sizeMap.get(size) || 0) + 1));
    }
    if (oldItems.length) {
      oldItems.forEach(({ size }) => this.sizeMap.set(size, Math.max((this.sizeMap.get(size) || 0) - 1, 0)));
      oldItems.forEach(({ newSize: s }) => this.sizeMap.set(s, (this.sizeMap.get(s) || 0) + 1));
    }
    if (removed.length) {
      removed.forEach(({ size }) => this.sizeMap.set(size, Math.max((this.sizeMap.get(size) || 0) - 1, 0)));
    }
    const sorted = [...this.sizeMap.entries()].sort((a, b) => b[1] - a[1]);
    const mostFrequentCount = sorted[0][1];
    const listEqual = sorted.filter(i => i[1] === mostFrequentCount);
    if (listEqual.length > 1 && listEqual.find(i => i[0] === oldFrequentSizeCount)) {
      // if there are more than 1 most frequent sizes, but the old one is present
      return;
    }
    this.frequentSize = sorted[0][0];
  }
  recalculate(cacheSize) {
    if (this.sizeStrategy === SizeStrategy.Constant) {
      return false;
    }
    const { oldItems, newItems, removed } = this.recalculation;
    if (!oldItems.length && !newItems.length && !removed.length) {
      return false;
    }
    const oldValue = this.get();
    if (this.sizeStrategy === SizeStrategy.Average) {
      this.recalculateAverageSize(cacheSize);
    }
    else {
      this.recalculateFrequentSize();
    }
    this.recalculation.reset();
    return this.get() !== oldValue;
  }
  setExisted(oldItem, newItem) {
    if (this.sizeStrategy !== SizeStrategy.Constant) {
      this.recalculation.oldItems.push({
        size: oldItem.size,
        newSize: newItem.size
      });
    }
  }
  setNew(newItem) {
    if (this.sizeStrategy !== SizeStrategy.Constant) {
      this.recalculation.newItems.push({
        size: newItem.size
      });
    }
    else {
      if (!this.constantSize) {
        this.constantSize = newItem.size;
      }
    }
  }
  setRemoved(oldItem) {
    if (this.sizeStrategy !== SizeStrategy.Constant) {
      this.recalculation.removed.push({
        size: oldItem.size
      });
    }
  }
}

class ItemCache {
  constructor(item, saveData) {
    this.$index = item.$index;
    this.nodeId = item.nodeId;
    this.data = saveData ? item.data : null;
    this.size = item.size;
  }
  changeIndex(value) {
    this.$index = value;
    this.nodeId = String(value);
  }
}
class Cache {
  constructor({ itemSize, cacheData, cacheOnReload, sizeStrategy }, logger) {
    this.itemSize = itemSize;
    this.saveData = cacheData;
    this.cacheOnReload = cacheOnReload;
    this.sizeStrategy = sizeStrategy;
    this.logger = logger;
    this.items = new Map();
    this.defaultSize = new DefaultSize(itemSize, sizeStrategy);
    this.reset(true);
  }
  reset(force) {
    force = force || !this.cacheOnReload;
    if (force) {
      this.minIndex = +Infinity;
      this.maxIndex = -Infinity;
      this.items.clear();
    }
    this.defaultSize.reset(force);
  }
  get size() {
    return this.items.size;
  }
  get(index) {
    return this.items.get(index);
  }
  getItemSize(index) {
    const item = this.get(index);
    return item ? item.size : 0;
  }
  getDefaultSize() {
    return this.defaultSize.get();
  }
  recalculateDefaultSize() {
    if (this.defaultSize.recalculate(this.size)) {
      this.logger.log(() => `default size has been updated: ${this.defaultSize.get()}`);
      return true;
    }
    return false;
  }
  /**
   * Adds item to Set by $index, replaces existed item if $index matches.
   * Maintains min/max indexes and default item size.
   *
   * @param {Item<Data>} item A Buffer item to be cached, an objects with { $index, data, size } props.
   *
   * @returns {ItemCache<Data>} Cached item.
   */
  add(item) {
    let itemCache = this.get(item.$index);
    if (itemCache) { // adding item is already cached
      if (this.saveData) {
        itemCache.data = item.data;
      }
      if (itemCache.size !== item.size) { // size changes
        if (itemCache.size !== void 0) {
          this.defaultSize.setExisted(itemCache, item);
        }
        else {
          this.defaultSize.setNew(item);
        }
        itemCache.size = item.size;
      }
    }
    else {
      itemCache = new ItemCache(item, this.saveData);
      this.items.set(item.$index, itemCache);
      this.defaultSize.setNew(itemCache);
    }
    if (item.$index < this.minIndex) {
      this.minIndex = item.$index;
    }
    if (item.$index > this.maxIndex) {
      this.maxIndex = item.$index;
    }
    return itemCache;
  }
  /**
   * Removes items from Set, shifts $indexes of items that remain.
   * Replaces current Set with a new one with new regular $indexes.
   * Maintains min/max indexes and default item size.
   *
   * @param {number[]} toRemove List of indexes to be removed.
   * @param {boolean} fixRight Defines indexes shifting strategy.
   * If false, indexes that are greater than the removed ones will be decreased.
   * If true, indexes that are less than than the removed ones will be increased.
   */
  removeItems(toRemove, fixRight) {
    const items = new Map();
    let min = Infinity, max = -Infinity;
    this.items.forEach(item => {
      if (toRemove.some(index => index === item.$index)) {
        if (item.size !== void 0) {
          this.defaultSize.setRemoved(item);
        }
        return;
      }
      const diff = fixRight
        ? toRemove.reduce((acc, index) => acc + (item.$index < index ? 1 : 0), 0)
        : toRemove.reduce((acc, index) => acc - (item.$index > index ? 1 : 0), 0);
      item.changeIndex(item.$index + diff);
      items.set(item.$index, item);
      min = item.$index < min ? item.$index : min;
      max = item.$index > max ? item.$index : max;
    });
    this.items = items;
    this.minIndex = min;
    this.maxIndex = max;
  }
  /**
   * Destructively updates Set based on subset (before-after) changes.
   * Replaces current Set with a new one with new regular $indexes.
   * Maintains min/max indexes. Maintains default item size on remove only.
   * Inserted and replaced items will be taken into account on Cache.add async calls after render.
   *
   * @param {number[]} before Initial subset of indexes to be replaced by "after". Must be incremental.
   * @param {Item<Data>[]} after Transformed subset that replaces "before". Must be be $index-incremental.
   * Must contain at least 1 $index from "before" or be empty.
   * @param {boolean} fixRight This is to fix right indexes during subset collapsing. Acts only if "after" is empty.
   */
  updateSubset(before, after, fixRight) {
    if (!this.size || !before.length) {
      return;
    }
    const minB = before[0], maxB = before[before.length - 1];
    let leftDiff, rightDiff, found;
    if (after.length) {
      const minA = after[0].$index, maxA = after[after.length - 1].$index;
      leftDiff = minA - minB;
      rightDiff = maxA - maxB;
    }
    else {
      leftDiff = fixRight ? maxB - minB + 1 : 0;
      rightDiff = fixRight ? 0 : minB - maxB - 1;
    }
    const items = new Map();
    this.items.forEach(item => {
      if (item.$index < minB) { // items to the left of the subset
        item.changeIndex(item.$index + leftDiff);
        items.set(item.$index, item);
        return;
      }
      else if (item.$index > maxB) { // items to the right of the subset
        item.changeIndex(item.$index + rightDiff);
        items.set(item.$index, item);
        return;
      }
    });
    after.forEach(item => // subset items
     items.set(item.$index, new ItemCache(item, this.saveData)));
    before.forEach(index => {
      if (!after.some(({ $index }) => index === $index) && (found = this.get(index))) {
        this.defaultSize.setRemoved(found);
      }
    });
    this.minIndex += leftDiff;
    this.maxIndex += rightDiff;
    this.items = items;
  }
}

class Buffer {
  constructor(settings, onDataChanged, logger) {
    this._items = [];
    this.logger = logger;
    this.changeItems = onDataChanged;
    this.bof = new Reactive(false);
    this.eof = new Reactive(false);
    this.cache = new Cache(settings, logger);
    this.startIndexUser = settings.startIndex;
    this.minIndexUser = settings.minIndex;
    this.maxIndexUser = settings.maxIndex;
    this.reset(true);
  }
  dispose() {
    this.bof.dispose();
    this.eof.dispose();
    this._items.forEach(item => item.dispose());
    this._items = [];
  }
  reset(force, startIndex) {
    this.items.forEach(item => item.hide());
    this.pristine = true;
    this.items = [];
    this.cache.reset(force);
    this.absMinIndex = this.minIndexUser;
    this.absMaxIndex = this.maxIndexUser;
    this.setCurrentStartIndex(startIndex);
    this.bof.set(false);
    this.eof.set(false);
    this.pristine = false;
  }
  setCurrentStartIndex(newStartIndex) {
    const min = this.minIndexUser;
    const max = this.maxIndexUser;
    const start = this.startIndexUser;
    let index = Number(newStartIndex);
    if (Number.isNaN(index)) {
      this.logger.log(() => `fallback startIndex to settings.startIndex (${start})`);
      index = start;
    }
    if (index < min) {
      this.logger.log(() => `setting startIndex to settings.minIndex (${min}) because ${index} < ${min}`);
      index = min;
    }
    if (index > max) {
      this.logger.log(() => `setting startIndex to settings.maxIndex (${max}) because ${index} > ${max}`);
      index = max;
    }
    this.startIndex = index;
  }
  set items(items) {
    this._items = items;
    this.changeItems(items);
    if (!this.pristine) {
      this.checkBOF();
      this.checkEOF();
    }
  }
  get items() {
    return this._items;
  }
  set absMinIndex(value) {
    if (this._absMinIndex !== value) {
      this._absMinIndex = Number.isFinite(this._absMaxIndex) && value > this._absMaxIndex ? this._absMaxIndex : value;
    }
    if (!this.pristine) {
      this.checkBOF();
    }
  }
  get absMinIndex() {
    return this._absMinIndex;
  }
  set absMaxIndex(value) {
    if (this._absMaxIndex !== value) {
      this._absMaxIndex = Number.isFinite(this._absMinIndex) && value < this._absMinIndex ? this._absMinIndex : value;
    }
    if (!this.pristine) {
      this.checkEOF();
    }
  }
  get absMaxIndex() {
    return this._absMaxIndex;
  }
  checkBOF() {
    // since bof has no setter, need to call checkBOF() on items and absMinIndex change
    const bof = this.items.length
      ? (this.items[0].$index === this.absMinIndex)
      : isFinite(this.absMinIndex);
    this.bof.set(bof);
  }
  checkEOF() {
    // since eof has no setter, need to call checkEOF() on items and absMaxIndex change
    const eof = this.items.length
      ? (this.items[this.items.length - 1].$index === this.absMaxIndex)
      : isFinite(this.absMaxIndex);
    this.eof.set(eof);
  }
  get size() {
    return this._items.length;
  }
  get cacheSize() {
    return this.cache.size;
  }
  get defaultSize() {
    return this.cache.getDefaultSize();
  }
  get minIndex() {
    return isFinite(this.cache.minIndex) ? this.cache.minIndex : this.startIndex;
  }
  get maxIndex() {
    return isFinite(this.cache.maxIndex) ? this.cache.maxIndex : this.startIndex;
  }
  get firstIndex() {
    return this.items.length ? this.items[0].$index : NaN;
  }
  get lastIndex() {
    return this.items.length ? this.items[this.items.length - 1].$index : NaN;
  }
  get finiteAbsMinIndex() {
    return isFinite(this.absMinIndex) ? this.absMinIndex : this.minIndex;
  }
  get finiteAbsMaxIndex() {
    return isFinite(this.absMaxIndex) ? this.absMaxIndex : this.maxIndex;
  }
  get($index) {
    return this.items.find(item => item.$index === $index);
  }
  setItems(items) {
    if (!this.items.length) {
      this.items = [...items];
    }
    else if (this.items[0].$index > items[items.length - 1].$index) {
      this.items = [...items, ...this.items];
    }
    else if (items[0].$index > this.items[this.items.length - 1].$index) {
      this.items = [...this.items, ...items];
    }
    else {
      return false;
    }
    return true;
  }
  clip() {
    this.items = this.items.filter(({ toRemove }) => !toRemove);
  }
  append(items) {
    this.items = [...this.items, ...items];
  }
  prepend(items) {
    this.items = [...items, ...this.items];
  }
  shiftExtremum(amount, fixRight) {
    if (!fixRight) {
      this.absMaxIndex += amount;
    }
    else {
      this.absMinIndex -= amount;
      this.startIndex -= amount;
    }
    if (this.startIndex > this.absMaxIndex) {
      this.startIndex = this.absMaxIndex;
    }
    else if (this.startIndex < this.absMinIndex) {
      this.startIndex = this.absMinIndex;
    }
  }
  removeItems(indexes, fixRight, virtual = false) {
    const result = [];
    const toRemove = virtual ? indexes : [];
    const length = this.items.length;
    let shifted = false;
    for (let i = fixRight ? length - 1 : 0; fixRight ? i >= 0 : i < length; fixRight ? i-- : i++) {
      const item = this.items[i];
      if (!virtual && indexes.indexOf(item.$index) >= 0) {
        toRemove.push(item.$index);
        continue;
      }
      const diff = toRemove.reduce((acc, index) => acc + (fixRight
        ? (item.$index < index ? 1 : 0)
        : (item.$index > index ? -1 : 0)), 0);
      shifted = shifted || !!diff;
      item.updateIndex(item.$index + diff);
      if (!virtual) {
        if (fixRight) {
          result.unshift(item);
        }
        else {
          result.push(item);
        }
      }
    }
    this.shiftExtremum(-toRemove.length, fixRight);
    if (!virtual) {
      this.items = result;
    }
    else if (shifted) {
      this.items = [...this.items];
    }
    this.cache.removeItems(toRemove, fixRight);
  }
  updateItems(predicate, generator, indexToTrack, fixRight) {
    if (!this.size || Number.isNaN(this.firstIndex)) {
      return NaN;
    }
    let _indexToTrack = indexToTrack;
    let index = fixRight ? this.lastIndex : this.firstIndex;
    const items = [];
    const diff = fixRight ? -1 : 1;
    const initialIndexList = this.items.map(({ $index }) => $index);
    (fixRight ? this.items.reverse() : this.items).forEach(item => {
      const result = predicate(item);
      // if predicate result is falsy or empty array -> delete
      if (!result || (Array.isArray(result) && !result.length)) {
        item.toRemove = true;
        _indexToTrack += item.$index >= indexToTrack ? (fixRight ? 1 : 0) : (fixRight ? 0 : -1);
        this.shiftExtremum(-1, fixRight);
        return;
      }
      // if predicate result is truthy but not array -> leave
      if (!Array.isArray(result)) {
        item.updateIndex(index);
        items.push(item);
        index += diff;
        return;
      }
      // if predicate result is non-empty array -> insert/replace
      if (item.$index < indexToTrack) {
        _indexToTrack += fixRight ? 0 : result.length - 1;
      }
      else if (item.$index > indexToTrack) {
        _indexToTrack += fixRight ? 1 - result.length : 0;
      }
      let toRemove = true;
      const newItems = [];
      (fixRight ? [...result].reverse() : result).forEach((data, i) => {
        let newItem;
        if (item.data === data) {
          if (indexToTrack === item.$index) {
            _indexToTrack = index + i * diff;
          }
          item.updateIndex(index + i * diff);
          newItem = item;
          toRemove = false; // insert case
        }
        else {
          newItem = generator(index + i * diff, data);
          newItem.toInsert = true;
        }
        newItems.push(newItem);
      });
      item.toRemove = toRemove;
      items.push(...newItems);
      index += diff * result.length;
      if (result.length > 1) {
        this.shiftExtremum(result.length - 1, fixRight);
      }
    });
    this.items = fixRight ? items.reverse() : items;
    this.cache.updateSubset(initialIndexList, this.items, fixRight);
    if (this.finiteAbsMinIndex === this.finiteAbsMaxIndex) {
      _indexToTrack = NaN;
    }
    else if (_indexToTrack > this.finiteAbsMaxIndex) {
      _indexToTrack = this.finiteAbsMaxIndex;
    }
    else if (_indexToTrack < this.finiteAbsMinIndex) {
      _indexToTrack = this.finiteAbsMinIndex;
    }
    return _indexToTrack;
  }
  cacheItem(item) {
    this.cache.add(item);
  }
  getFirstVisibleItemIndex() {
    const length = this.items.length;
    for (let i = 0; i < length; i++) {
      if (!this.items[i].invisible) {
        return i;
      }
    }
    return -1;
  }
  getLastVisibleItemIndex() {
    for (let i = this.items.length - 1; i >= 0; i--) {
      if (!this.items[i].invisible) {
        return i;
      }
    }
    return -1;
  }
  getFirstVisibleItem() {
    const index = this.getFirstVisibleItemIndex();
    if (index >= 0) {
      return this.items[index];
    }
  }
  getLastVisibleItem() {
    const index = this.getLastVisibleItemIndex();
    if (index >= 0) {
      return this.items[index];
    }
  }
  getEdgeVisibleItem(direction, opposite) {
    return direction === (!opposite ? Direction.forward : Direction.backward) ?
      this.getLastVisibleItem() : this.getFirstVisibleItem();
  }
  getVisibleItemsCount() {
    return this.items.reduce((acc, item) => acc + (item.invisible ? 0 : 1), 0);
  }
  getSizeByIndex(index) {
    const item = this.cache.get(index);
    return item ? item.size : this.defaultSize;
  }
  checkDefaultSize() {
    return this.cache.recalculateDefaultSize();
  }
  getIndexToAppend(eof) {
    return (!eof
      ? (this.size ? this.items[this.size - 1].$index : this.maxIndex)
      : this.absMaxIndex) + (this.size ? 1 : 0);
  }
  getIndexToPrepend(bof) {
    return (!bof
      ? (this.size ? this.items[0].$index : this.minIndex)
      : this.absMinIndex) - (this.size ? 1 : 0);
  }
  getIndexToAdd(eof, prepend) {
    return prepend ? this.getIndexToPrepend(eof) : this.getIndexToAppend(eof);
  }
}

class InnerLoopModel {
  constructor(total) {
    this.total = total;
    this.isInitial = false;
    this.busy = new Reactive(false);
  }
  get first() {
    return this.count === 0;
  }
  done() {
    this.count++;
    this.total++;
    this.busy.set(false);
  }
  start() {
    this.busy.set(true);
  }
  dispose() {
    this.busy.dispose();
  }
}
class WorkflowCycleModel {
  constructor(instanceIndex, cycle) {
    const cycleCount = cycle ? cycle.count : 1;
    const loopCount = cycle ? cycle.innerLoop.count : 0;
    this.instanceIndex = instanceIndex;
    this.innerLoop = new InnerLoopModel(loopCount);
    this.interrupter = null;
    this.busy = new Reactive(false);
    this.done(cycleCount);
  }
  get loopId() {
    return `${this.instanceIndex}-${this.count}-${this.innerLoop.total}`;
  }
  get loopIdNext() {
    return `${this.instanceIndex}-${this.count}-${this.innerLoop.total + 1}`;
  }
  done(count) {
    this.count = count;
    this.isInitial = false;
    this.busy.set(false);
  }
  start(isInitial, initiator) {
    this.isInitial = isInitial;
    this.initiator = initiator;
    this.innerLoop.isInitial = isInitial;
    this.innerLoop.count = 0;
    this.interrupter = null;
    this.busy.set(true);
  }
  dispose(forever) {
    if (forever) {
      // otherwise the value will be persisted during re-instantiation
      this.busy.dispose();
    }
    this.innerLoop.dispose();
  }
}

class Positions {
  constructor() {
    this.reset();
  }
  reset() {
    this.startDelta = 0;
    this.before = 0;
  }
}
class First {
  constructor() {
    this.reset();
  }
  reset() {
    this.index = NaN;
    this.indexBuffer = NaN;
    this.position = NaN;
  }
}
class Last {
  constructor() {
    this.reset();
  }
  reset() {
    this.index = NaN;
    this.indexBuffer = NaN;
  }
}
class FetchModel {
  constructor() {
    this.callCount = 0;
    this.positions = new Positions();
    this.first = new First();
    this.last = new Last();
    this.reset();
  }
  reset() {
    this._newItemsData = null;
    this.items = [];
    this.positions.reset();
    this.first.reset();
    this.last.reset();
    this.hasAnotherPack = false;
    this.firstVisibleIndex = NaN;
    this.firstVisibleItemDelta = NaN;
    this.negativeSize = 0;
    this.direction = null;
    this.cancel = null;
    this.simulate = false;
    this.isPrepend = false;
    this.isCheck = false;
    this.doRemove = false;
  }
  get newItemsData() {
    return this._newItemsData;
  }
  set newItemsData(items) {
    this._newItemsData = items;
    if (items && items.length) {
      this.callCount++;
    }
  }
  get shouldFetch() {
    return !!this.count;
  }
  get hasNewItems() {
    return !!((this._newItemsData && this._newItemsData.length));
  }
  get index() {
    return this.first.index;
  }
  get count() {
    return !isNaN(this.first.index) && !isNaN(this.last.index) ? this.last.index - this.first.index + 1 : 0;
  }
  startSimulate(items) {
    this.simulate = true;
    this._newItemsData = items.map(item => item.data);
    this.items = items;
    this.hasAnotherPack = false;
    this.negativeSize = 0;
  }
  stopSimulate() {
    this.simulate = false;
    this.isPrepend = false;
    this.isCheck = false;
    this.doRemove = false;
  }
  append(items) {
    this.startSimulate(items);
    this.last.index = items[items.length - 1].$index;
    this.first.index = items[0].$index;
    this.direction = Direction.forward;
  }
  prepend(items) {
    this.startSimulate(items);
    this.last.index = items[0].$index;
    this.first.index = items[items.length - 1].$index;
    this.direction = Direction.backward;
    this.isPrepend = true;
  }
  check(items) {
    this.startSimulate(items);
    this.last.index = items[0].$index;
    this.first.index = items[items.length - 1].$index;
    this.isCheck = true;
  }
  remove() {
    this.startSimulate([]);
    this.doRemove = true;
    // firstVisibleIndex & delta should be set inside process
  }
  update(index, delta, items, itemsToRemove) {
    this.startSimulate(items);
    this.firstVisibleIndex = index;
    this.firstVisibleItemDelta = delta;
    this.doRemove = itemsToRemove.length > 0;
  }
}

class ClipModel {
  constructor() {
    this.callCount = 0;
    this.reset();
  }
  get force() {
    return this.forceForward || this.forceBackward;
  }
  reset(force) {
    this.doClip = false;
    if (!force) {
      this.forceForward = false;
      this.forceBackward = false;
    }
  }
}

class RenderModel {
  constructor() {
    this.reset();
  }
  get noSize() {
    return this.sizeBefore === this.sizeAfter;
  }
  reset() {
    this.sizeBefore = 0;
    this.sizeAfter = 0;
    this.positionBefore = 0;
    this.renderTimer = null;
  }
}

class ScrollState {
  constructor() {
    this.reset();
  }
  reset() {
    this.previous = null;
    this.current = null;
    this.syntheticPosition = null;
    this.syntheticFulfill = false;
    this.positionBeforeAsync = null;
    this.positionBeforeAdjust = null;
    this.positionAfterAdjust = null;
    this.cleanupTimers();
  }
  cleanupTimers() {
    if (this.scrollTimer) {
      clearTimeout(this.scrollTimer);
      this.scrollTimer = null;
    }
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = 0;
    }
  }
  hasPositionChanged(position) {
    const before = this.positionBeforeAdjust;
    const after = this.positionAfterAdjust;
    return before === null || before !== position || after === null || after !== position;
  }
}

class State {
  constructor(packageInfo, settings, state) {
    this.packageInfo = packageInfo;
    this.settings = settings;
    this.initTime = Number(new Date());
    this.cycle = new WorkflowCycleModel(this.settings.instanceIndex, state ? state.cycle : void 0);
    this.fetch = new FetchModel();
    this.clip = new ClipModel();
    this.render = new RenderModel();
    this.scrollState = new ScrollState();
  }
  get time() {
    return Number(new Date()) - this.initTime;
  }
  endInnerLoop() {
    const { fetch, render, cycle } = this;
    if (fetch.cancel) {
      fetch.cancel();
      fetch.cancel = null;
    }
    if (render.renderTimer) {
      clearTimeout(render.renderTimer);
      render.renderTimer = null;
    }
    cycle.innerLoop.done();
  }
  startInnerLoop() {
    const { cycle, scrollState: scroll, fetch, render, clip } = this;
    cycle.innerLoop.start();
    scroll.positionBeforeAsync = null;
    if (!fetch.simulate) {
      fetch.reset();
    }
    clip.reset(clip.force);
    render.reset();
    return Object.assign({}, (cycle.innerLoop.first ? {
      process: cycle.initiator,
      doRender: fetch.simulate && fetch.items.length > 0
    } : {}));
  }
  dispose() {
    this.cycle.dispose();
    this.endInnerLoop();
    this.scrollState.cleanupTimers();
  }
}

const ADAPTER_PROPS_STUB = getDefaultAdapterProps();
const _has = (obj, prop) => typeof obj === 'object' && obj !== null && Object.prototype.hasOwnProperty.call(obj, prop);
const convertAppendArgs = (prepend, options, eof) => {
  let result = options;
  if (!_has(options, 'items')) {
    const items = !Array.isArray(options) ? [options] : options;
    result = prepend ? { items, bof: eof } : { items, eof: eof };
  }
  return result;
};
const convertRemoveArgs = (options) => {
  if (!(_has(options, 'predicate') || _has(options, 'indexes'))) {
    const predicate = options;
    options = { predicate };
  }
  return options;
};
class Adapter {
  constructor(context, getWorkflow, logger) {
    this.source = {}; // for Reactive props
    this.box = {}; // for Scalars over Reactive props
    this.demand = {}; // for Scalars on demand
    this.wanted = {};
    this.getWorkflow = getWorkflow;
    this.logger = logger;
    this.relax$ = null;
    this.relaxRun = null;
    this.reloadCounter = 0;
    // public context (if exists) should provide access Reactive props configuration by id
    const reactivePropsStore = context && reactiveConfigStorage.get(context.id) || {};
    // make array of the original values from public context if present
    const adapterProps = context
      ? ADAPTER_PROPS_STUB.map(prop => {
        let value = context[prop.name];
        // if context is augmented, we need to replace external reactive props with inner ones
        if (context.augmented) {
          const reactiveProp = reactivePropsStore[prop.name];
          if (reactiveProp) {
            value = reactiveProp.default; // boolean doesn't matter here
          }
        }
        return (Object.assign(Object.assign({}, prop), { value }));
      })
      : getDefaultAdapterProps();
    // restore default reactive props if they were configured
    Object.entries(reactivePropsStore).forEach(([key, value]) => {
      const prop = adapterProps.find(({ name }) => name === key);
      if (prop && value) {
        prop.value = value.default;
      }
    });
    // Scalar permanent props
    adapterProps
      .filter(({ type, permanent }) => type === AdapterPropType.Scalar && permanent)
      .forEach(({ name, value }) => Object.defineProperty(this, name, {
      configurable: true,
      get: () => value
    }));
    // Reactive props
    // 1) store original values in "source" container, to avoid extra .get() calls on scalar twins set
    // 2) "wanted" container is bound with scalars; get() updates it
    adapterProps
      .filter(prop => prop.type === AdapterPropType.Reactive)
      .forEach(({ name, value }) => {
      this.source[name] = value;
      Object.defineProperty(this, name, {
        configurable: true,
        get: () => {
          const scalarWanted = ADAPTER_PROPS_STUB.find(({ wanted, reactive }) => wanted && reactive === name);
          if (scalarWanted) {
            this.wanted[scalarWanted.name] = true;
          }
          return this.source[name];
        }
      });
    });
    // Scalar props that have Reactive twins
    // 1) scalars should use "box" container
    // 2) "wanted" should be updated on get
    // 3) reactive props (from "source") are triggered on set
    adapterProps
      .filter(prop => prop.type === AdapterPropType.Scalar && !!prop.reactive)
      .forEach(({ name, value, reactive, wanted }) => {
      if (wanted) {
        this.wanted[name] = false;
      }
      this.box[name] = value;
      Object.defineProperty(this, name, {
        configurable: true,
        set: (newValue) => {
          if (newValue !== this.box[name]) {
            this.box[name] = newValue;
            this.source[reactive].set(newValue);
            // need to emit new value through the configured reactive prop if present
            const reactiveProp = reactivePropsStore[reactive];
            if (reactiveProp) {
              reactiveProp.emit(reactiveProp.source, newValue);
            }
          }
        },
        get: () => {
          if (wanted) {
            this.wanted[name] = true;
          }
          return this.box[name];
        }
      });
    });
    // Scalar props on-demand
    // these scalars should use "demand" container
    // setting defaults should be overridden on init()
    adapterProps
      .filter(prop => prop.type === AdapterPropType.Scalar && prop.onDemand)
      .forEach(({ name, value }) => {
      this.demand[name] = value;
      Object.defineProperty(this, name, {
        configurable: true,
        get: () => this.demand[name]
      });
    });
    if (!context) {
      return;
    }
    // Adapter public context augmentation
    adapterProps
      .forEach(({ name, type, value: defaultValue, permanent }) => {
      let value = this[name];
      if (type === AdapterPropType.Function) {
        value = value.bind(this);
      }
      else if (type === AdapterPropType.WorkflowRunner) {
        value = this.getPromisifiedMethod(value, defaultValue);
      }
      else if (type === AdapterPropType.Reactive && reactivePropsStore[name]) {
        value = context[name];
      }
      else if (name === AdapterPropName.augmented) {
        value = true;
      }
      Object.defineProperty(context, name, {
        configurable: true,
        get: () => !permanent && type === AdapterPropType.Scalar
          ? this[name] // non-permanent Scalars should be taken in runtime
          : value // Reactive props and methods (Functions/WorkflowRunners) can be defined once
      });
    });
    this.externalContext = context;
  }
  get workflow() {
    return this.getWorkflow();
  }
  get reloadCount() {
    return this.reloadCounter;
  }
  get reloadId() {
    return this.id + '.' + this.reloadCounter;
  }
  getPromisifiedMethod(method, defaultMethod) {
    return (...args) => this.relax$
      ? new Promise(resolve => {
        if (this.relax$) {
          this.relax$.once(value => resolve(value));
        }
        method.apply(this, args);
      })
      : defaultMethod.apply(this, args);
  }
  initialize(buffer, state, logger, adapterRun$) {
    // buffer
    Object.defineProperty(this.demand, AdapterPropName.itemsCount, {
      get: () => buffer.getVisibleItemsCount()
    });
    Object.defineProperty(this.demand, AdapterPropName.bufferInfo, {
      get: () => ({
        firstIndex: buffer.firstIndex,
        lastIndex: buffer.lastIndex,
        minIndex: buffer.minIndex,
        maxIndex: buffer.maxIndex,
        absMinIndex: buffer.absMinIndex,
        absMaxIndex: buffer.absMaxIndex,
        defaultSize: buffer.defaultSize,
      })
    });
    this.bof = buffer.bof.get();
    buffer.bof.on(bof => this.bof = bof);
    this.eof = buffer.eof.get();
    buffer.eof.on(eof => this.eof = eof);
    // state
    Object.defineProperty(this.demand, AdapterPropName.packageInfo, {
      get: () => state.packageInfo
    });
    this.loopPending = state.cycle.innerLoop.busy.get();
    state.cycle.innerLoop.busy.on(busy => this.loopPending = busy);
    this.isLoading = state.cycle.busy.get();
    state.cycle.busy.on(busy => this.isLoading = busy);
    // logger
    this.logger = logger;
    // self-pending subscription; set up only on the very first init
    if (adapterRun$) {
      if (!this.relax$) {
        this.relax$ = new Reactive();
      }
      const relax$ = this.relax$;
      adapterRun$.on(({ status, payload }) => {
        let unSubRelax = () => { };
        if (status === ProcessStatus.start) {
          unSubRelax = this.isLoading$.on(value => {
            if (!value) {
              unSubRelax();
              relax$.set({ success: true, immediate: false, details: null });
            }
          });
        }
        else if (status === ProcessStatus.done || status === ProcessStatus.error) {
          unSubRelax();
          relax$.set({
            success: status !== ProcessStatus.error,
            immediate: true,
            details: status === ProcessStatus.error && payload ? String(payload.error) : null
          });
        }
      });
    }
    // init
    this.init = true;
  }
  dispose() {
    if (this.relax$) {
      this.relax$.dispose();
    }
    if (this.externalContext) {
      this.resetContext();
    }
    Object.getOwnPropertyNames(this).forEach(prop => {
      delete this[prop];
    });
  }
  resetContext() {
    const reactiveStore = reactiveConfigStorage.get(this.externalContext.id);
    ADAPTER_PROPS_STUB
      .forEach(({ type, permanent, name, value }) => {
      // assign initial values to non-reactive non-permanent props
      if (type !== AdapterPropType.Reactive && !permanent) {
        Object.defineProperty(this.externalContext, name, {
          configurable: true,
          get: () => value
        });
      }
      // reset reactive props
      if (type === AdapterPropType.Reactive && reactiveStore) {
        const property = reactiveStore[name];
        if (property) {
          property.default.reset();
          property.emit(property.source, property.default.get());
        }
      }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  reset(options) {
    this.reloadCounter++;
    this.logger.logAdapterMethod('reset', options, ` of ${this.reloadId}`);
    this.workflow.call({
      process: AdapterProcess.reset,
      status: ProcessStatus.start,
      payload: { options }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  reload(options) {
    this.reloadCounter++;
    this.logger.logAdapterMethod('reload', options, ` of ${this.reloadId}`);
    this.workflow.call({
      process: AdapterProcess.reload,
      status: ProcessStatus.start,
      payload: { options }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  append(_options, eof) {
    const options = convertAppendArgs(false, _options, eof); // support old signature
    this.logger.logAdapterMethod('append', [options.items, options.eof]);
    this.workflow.call({
      process: AdapterProcess.append,
      status: ProcessStatus.start,
      payload: { options }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  prepend(_options, bof) {
    const options = convertAppendArgs(true, _options, bof); // support old signature
    this.logger.logAdapterMethod('prepend', [options.items, options.bof]);
    this.workflow.call({
      process: AdapterProcess.prepend,
      status: ProcessStatus.start,
      payload: { options }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  check() {
    this.logger.logAdapterMethod('check');
    this.workflow.call({
      process: AdapterProcess.check,
      status: ProcessStatus.start
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  remove(options) {
    options = convertRemoveArgs(options); // support old signature
    this.logger.logAdapterMethod('remove', options);
    this.workflow.call({
      process: AdapterProcess.remove,
      status: ProcessStatus.start,
      payload: { options }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  clip(options) {
    this.logger.logAdapterMethod('clip', options);
    this.workflow.call({
      process: AdapterProcess.clip,
      status: ProcessStatus.start,
      payload: { options }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  insert(options) {
    this.logger.logAdapterMethod('insert', options);
    this.workflow.call({
      process: AdapterProcess.insert,
      status: ProcessStatus.start,
      payload: { options }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  replace(options) {
    this.logger.logAdapterMethod('replace', options);
    this.workflow.call({
      process: AdapterProcess.replace,
      status: ProcessStatus.start,
      payload: { options }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  update(options) {
    this.logger.logAdapterMethod('update', options);
    this.workflow.call({
      process: AdapterProcess.update,
      status: ProcessStatus.start,
      payload: { options }
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  fix(options) {
    this.logger.logAdapterMethod('fix', options);
    this.workflow.call({
      process: AdapterProcess.fix,
      status: ProcessStatus.start,
      payload: { options }
    });
  }
  relaxUnchained(callback, reloadId) {
    const runCallback = () => typeof callback === 'function' && reloadId === this.reloadId && callback();
    if (!this.isLoading) {
      runCallback();
    }
    return new Promise(resolve => {
      if (!this.isLoading) {
        resolve(true);
        return;
      }
      this.isLoading$.once(() => {
        runCallback();
        resolve(false);
      });
    }).then(immediate => {
      const success = reloadId === this.reloadId;
      this.logger.log(() => !success ? `relax promise cancelled due to ${reloadId} != ${this.reloadId}` : void 0);
      return {
        immediate,
        success,
        details: !success ? 'Interrupted by reload or reset' : null
      };
    });
  }
  relax(callback) {
    const reloadId = this.reloadId;
    this.logger.logAdapterMethod('relax', callback, ` of ${reloadId}`);
    if (!this.init) {
      return Promise.resolve(methodPreResult);
    }
    return this.relaxRun = this.relaxRun
      ? this.relaxRun.then(() => this.relaxUnchained(callback, reloadId))
      : this.relaxUnchained(callback, reloadId).then((result) => {
        this.relaxRun = null;
        return result;
      });
  }
  showLog() {
    this.logger.logAdapterMethod('showLog');
    this.logger.logForce();
  }
}

const INVALID_DATASOURCE_PREFIX = 'Invalid datasource:';
let instanceCount = 0;
class Scroller {
  constructor({ datasource, consumer, element, workflow, scroller }) {
    const { params: { get } } = validate(datasource, DATASOURCE);
    if (!get.isValid) {
      throw new Error(`${INVALID_DATASOURCE_PREFIX} ${get.errors[0]}`);
    }
    const packageInfo = scroller ? scroller.state.packageInfo : { consumer, core };
    element = scroller ? scroller.viewport.element : element;
    workflow = scroller ? scroller.workflow : workflow;
    this.workflow = workflow;
    this.settings = new Settings(datasource.settings, datasource.devSettings, ++instanceCount);
    this.logger = new Logger(this, packageInfo, datasource.adapter);
    this.routines = new Routines(this.settings);
    this.state = new State(packageInfo, this.settings, scroller ? scroller.state : void 0);
    this.buffer = new Buffer(this.settings, workflow.onDataChanged, this.logger);
    this.viewport = new Viewport(element, this.settings, this.routines, this.state, this.logger);
    this.logger.object('vscroll settings object', this.settings, true);
    this.initDatasource(datasource, scroller);
  }
  initDatasource(datasource, scroller) {
    if (scroller) { // scroller re-instantiating case
      this.datasource = datasource;
      this.adapter = scroller.adapter;
      // todo: what about (this.settings.adapter !== scroller.setting.adapter) case?
      return;
    }
    // scroller is being instantiated for the first time
    const constructed = datasource instanceof DatasourceGeneric;
    const mockAdapter = !constructed && !this.settings.adapter;
    if (constructed) { // datasource is already instantiated
      this.datasource = datasource;
    }
    else { // datasource as POJO
      const DS = makeDatasource(() => ({ mock: mockAdapter }));
      this.datasource = new DS(datasource);
      if (this.settings.adapter) {
        datasource.adapter = this.datasource.adapter;
      }
    }
    const publicContext = !mockAdapter ? this.datasource.adapter : null;
    this.adapter = new Adapter(publicContext, () => this.workflow, this.logger);
  }
  init(adapterRun$) {
    this.viewport.reset(this.buffer.startIndex);
    this.logger.stat('initialization');
    this.adapter.initialize(this.buffer, this.state, this.logger, adapterRun$);
  }
  dispose(forever) {
    if (forever) { // Adapter is not re-instantiated on reset
      this.adapter.dispose();
    }
    this.buffer.dispose();
    this.state.dispose();
  }
  finalize() {
  }
}

const runStateMachine = ({ input: { process, status, payload = {} }, methods: { run, interrupt, done, onError } }) => {
  if (status === ProcessStatus.error) {
    onError(process, payload);
    if (!process.startsWith('adapter')) {
      run(End)(payload);
    }
    return;
  }
  const { options } = payload;
  switch (process) {
    case CommonProcess.init:
      if (status === ProcessStatus.start) { // App start
        run(Init)(process);
      }
      if (status === ProcessStatus.next) {
        run(Start)();
      }
      break;
    case CommonProcess.scroll:
      if (status === ProcessStatus.start) {
        run(Scroll)(payload);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.reset:
    case AdapterProcess.reload:
      if (status === ProcessStatus.start) {
        if (process === AdapterProcess.reset) {
          run(Reset)(options);
        }
        else {
          run(Reload)(options);
        }
      }
      if (status === ProcessStatus.next) {
        interrupt(Object.assign({ process }, payload));
        if (payload.finalize) {
          run(End)();
        }
        else {
          run(Init)(process);
        }
      }
      break;
    case AdapterProcess.append:
    case AdapterProcess.prepend:
      if (status === ProcessStatus.start) {
        run(Append)({ process, options });
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.check:
      if (status === ProcessStatus.start) {
        run(Check)();
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.remove:
      if (status === ProcessStatus.start) {
        run(Remove)(options);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.clip:
      if (status === ProcessStatus.start) {
        run(UserClip)(options);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.insert:
      if (status === ProcessStatus.start) {
        run(Insert)(options);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.replace:
      if (status === ProcessStatus.start) {
        run(Replace)(options);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.update:
      if (status === ProcessStatus.start) {
        run(Update)(options);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.fix:
      if (status === ProcessStatus.start) {
        run(Fix)(options);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case CommonProcess.start:
      switch (payload.process) {
        case AdapterProcess.append:
        case AdapterProcess.check:
        case AdapterProcess.insert:
          run(Render)();
          break;
        case AdapterProcess.remove:
          run(Adjust)();
          break;
        case AdapterProcess.replace:
        case AdapterProcess.update:
          if (payload.doRender) {
            run(Render)();
          }
          else {
            run(Adjust)();
          }
          break;
        default:
          run(PreFetch)();
      }
      break;
    case CommonProcess.preFetch:
      if (status === ProcessStatus.next) {
        switch (payload.process) {
          case AdapterProcess.clip:
            run(PreClip)();
            break;
          default:
            run(Fetch)();
        }
      }
      if (status === ProcessStatus.done) {
        run(End)();
      }
      break;
    case CommonProcess.fetch:
      run(PostFetch)();
      break;
    case CommonProcess.postFetch:
      if (status === ProcessStatus.next) {
        run(Render)();
      }
      if (status === ProcessStatus.done) {
        run(End)();
      }
      break;
    case CommonProcess.render:
      if (status === ProcessStatus.next) {
        switch (payload.process) {
          case AdapterProcess.append:
          case AdapterProcess.check:
          case AdapterProcess.insert:
          case AdapterProcess.replace:
          case AdapterProcess.update:
            run(Adjust)();
            break;
          default:
            run(PreClip)();
        }
      }
      if (status === ProcessStatus.done) {
        run(End)();
      }
      break;
    case CommonProcess.preClip:
      if (payload.doClip) {
        run(Clip)();
      }
      else {
        run(Adjust)();
      }
      break;
    case CommonProcess.clip:
      run(Adjust)();
      break;
    case CommonProcess.adjust:
      run(End)();
      break;
    case CommonProcess.end:
      if (status === ProcessStatus.next) {
        switch (payload.process) {
          case AdapterProcess.reset:
          case AdapterProcess.reload:
            done();
            run(Init)(payload.process);
            break;
          default:
            run(Start)();
        }
      }
      if (status === ProcessStatus.done) {
        done();
      }
      break;
  }
};

class Workflow {
  constructor({ element, datasource, consumer, run }) {
    this.isInitialized = false;
    this.initTimer = null;
    this.adapterRun$ = new Reactive();
    this.cyclesDone = 0;
    this.interruptionCount = 0;
    this.errors = [];
    this.disposeScrollEventHandler = () => null;
    this.propagateChanges = run;
    this.stateMachineMethods = {
      run: this.runProcess(),
      interrupt: this.interrupt.bind(this),
      done: this.done.bind(this),
      onError: this.onError.bind(this)
    };
    this.scroller = new Scroller({ element, datasource, consumer, workflow: this.getUpdater() });
    if (this.scroller.settings.initializeDelay) {
      this.initTimer = setTimeout(() => {
        this.initTimer = null;
        this.init();
      }, this.scroller.settings.initializeDelay);
    }
    else {
      this.init();
    }
  }
  init() {
    this.scroller.init(this.adapterRun$);
    this.isInitialized = true;
    // run the Workflow
    this.callWorkflow({
      process: CommonProcess.init,
      status: ProcessStatus.start
    });
    // set up scroll event listener
    const { scrollEventReceiver } = this.scroller.viewport;
    const onScrollHandler = event => this.callWorkflow({
      process: CommonProcess.scroll,
      status: ProcessStatus.start,
      payload: { event }
    });
    scrollEventReceiver.addEventListener('scroll', onScrollHandler);
    this.disposeScrollEventHandler = () => scrollEventReceiver.removeEventListener('scroll', onScrollHandler);
  }
  changeItems(items) {
    this.propagateChanges(items);
  }
  callWorkflow(processSubject) {
    if (!this.isInitialized) {
      return;
    }
    const { process, status } = processSubject;
    if (process && process.startsWith('adapter') && status !== ProcessStatus.next) {
      this.adapterRun$.set(processSubject);
    }
    this.process(processSubject);
  }
  getUpdater() {
    return {
      call: this.callWorkflow.bind(this),
      onDataChanged: this.changeItems.bind(this),
    };
  }
  process(data) {
    const { status, process, payload } = data;
    if (this.scroller.settings.logProcessRun) {
      this.scroller.logger.log(() => [
        '%cfire%c', ...['color: #cc7777;', 'color: #000000;'],
        process, `"${status}"`, ...(payload !== void 0 ? [payload] : [])
      ]);
    }
    this.scroller.logger.logProcess(data);
    if (process === CommonProcess.end) {
      this.scroller.finalize();
    }
    runStateMachine({
      input: data,
      methods: this.stateMachineMethods
    });
  }
  runProcess() {
    return ({ run, process, name }) => (...args) => {
      if (this.scroller.settings.logProcessRun) {
        this.scroller.logger.log(() => [
          '%crun%c', ...['color: #333399;', 'color: #000000;'],
          process || name, ...args
        ]);
      }
      run(this.scroller, ...args);
    };
  }
  onError(process, payload) {
    const message = payload && String(payload.error) || '';
    const { time, cycle } = this.scroller.state;
    this.errors.push({
      process,
      message,
      time,
      loop: cycle.loopIdNext
    });
    this.scroller.logger.logError(message);
  }
  interrupt({ process, finalize, datasource }) {
    if (finalize) {
      const { workflow, logger } = this.scroller;
      // we are going to create a new reference for the scroller.workflow object
      // calling the old version of the scroller.workflow by any outstanding async processes will be skipped
      workflow.call = (p) => // eslint-disable-line @typescript-eslint/no-unused-vars
       logger.log('[skip wf call]');
      workflow.call.interrupted = true;
      this.scroller.workflow = this.getUpdater();
      this.interruptionCount++;
      logger.log(() => `workflow had been interrupted by the ${process} process (${this.interruptionCount})`);
    }
    if (datasource) { // Scroller re-initialization case
      this.scroller.adapter.relax(() => {
        this.scroller.logger.log('new Scroller instantiation');
        const scroller = new Scroller({ datasource, scroller: this.scroller });
        this.scroller.dispose();
        this.scroller = scroller;
        this.scroller.init();
      });
    }
  }
  done() {
    const { state, logger } = this.scroller;
    this.cyclesDone++;
    logger.logCycle(false);
    state.cycle.done(this.cyclesDone + 1);
    this.finalize();
  }
  dispose() {
    if (this.initTimer) {
      clearTimeout(this.initTimer);
    }
    this.disposeScrollEventHandler();
    this.adapterRun$.dispose();
    this.scroller.dispose(true);
    Object.getOwnPropertyNames(this).forEach(prop => {
      delete this[prop];
    });
  }
  finalize() {
  }
}

export { AdapterPropName, Direction, EMPTY_ITEM, INVALID_DATASOURCE_PREFIX, SizeStrategy, Workflow, getDefaultAdapterProps, makeDatasource, core as packageInfo };
//# sourceMappingURL=vscroll.esm6.js.map
