/**
 * vscroll (FESM2015)  by Denis Hilt | https://github.com/dhilt/vscroll | 2021-07-14T23:49:14.234Z | MIT license
 */

class e{constructor(e,t){this.id=0,void 0!==e&&(this.value=e,this.initialValue=e),this.options=t||{},this.subscriptions=new Map}set(e){if(this.value!==e||this.options.emitEqual){this.value=e;for(const[,t]of this.subscriptions)if(t.emit(e),this.value!==e)break}}get(){return this.value}on(e){const t=this.id++,s={emit:e,off:()=>{s.emit=()=>null,this.subscriptions.delete(t)}};return this.subscriptions.set(t,s),this.options.emitOnSubscribe&&s.emit(this.value),()=>s.off()}once(e){const t=this.on((s=>{t(),e(s)}));return t}reset(){this.set(this.initialValue)}dispose(){this.subscriptions.forEach((e=>e.off()))}}var t,s;!function(e){e.id="id",e.mock="mock",e.augmented="augmented",e.version="version",e.init="init",e.init$="init$",e.packageInfo="packageInfo",e.itemsCount="itemsCount",e.bufferInfo="bufferInfo",e.isLoading="isLoading",e.isLoading$="isLoading$",e.loopPending="loopPending",e.loopPending$="loopPending$",e.firstVisible="firstVisible",e.firstVisible$="firstVisible$",e.lastVisible="lastVisible",e.lastVisible$="lastVisible$",e.bof="bof",e.bof$="bof$",e.eof="eof",e.eof$="eof$",e.reset="reset",e.reload="reload",e.append="append",e.prepend="prepend",e.check="check",e.remove="remove",e.clip="clip",e.insert="insert",e.replace="replace",e.update="update",e.fix="fix",e.relax="relax",e.showLog="showLog"}(t||(t={})),function(e){e[e.Scalar=0]="Scalar",e[e.Reactive=1]="Reactive",e[e.WorkflowRunner=2]="WorkflowRunner",e[e.Function=3]="Function"}(s||(s={}));const i=t,r=s,n=()=>null,o={immediate:!0,success:!0,details:"Adapter is not initialized"},a=()=>Promise.resolve(o),l={core:{name:"",version:""},consumer:{name:"",version:""}},c={firstIndex:NaN,lastIndex:NaN,minIndex:NaN,maxIndex:NaN,absMinIndex:-1/0,absMaxIndex:1/0,defaultSize:NaN},d={data:{},element:{}},h=()=>[{type:r.Scalar,name:i.id,value:0,permanent:!0},{type:r.Scalar,name:i.mock,value:!0,permanent:!0},{type:r.Scalar,name:i.augmented,value:!1,permanent:!0},{type:r.Scalar,name:i.version,value:"",permanent:!0},{type:r.Scalar,name:i.init,value:!1,reactive:i.init$},{type:r.Scalar,name:i.packageInfo,value:l,onDemand:!0},{type:r.Scalar,name:i.itemsCount,value:0,onDemand:!0},{type:r.Scalar,name:i.bufferInfo,value:c,onDemand:!0},{type:r.Scalar,name:i.isLoading,value:!1,reactive:i.isLoading$},{type:r.Scalar,name:i.loopPending,value:!1,reactive:i.loopPending$},{type:r.Scalar,name:i.firstVisible,value:d,reactive:i.firstVisible$,wanted:!0},{type:r.Scalar,name:i.lastVisible,value:d,reactive:i.lastVisible$,wanted:!0},{type:r.Scalar,name:i.bof,value:!1,reactive:i.bof$},{type:r.Scalar,name:i.eof,value:!1,reactive:i.eof$},{type:r.WorkflowRunner,name:i.reset,value:a},{type:r.WorkflowRunner,name:i.reload,value:a},{type:r.WorkflowRunner,name:i.append,value:a},{type:r.WorkflowRunner,name:i.prepend,value:a},{type:r.WorkflowRunner,name:i.check,value:a},{type:r.WorkflowRunner,name:i.remove,value:a},{type:r.WorkflowRunner,name:i.clip,value:a},{type:r.WorkflowRunner,name:i.insert,value:a},{type:r.WorkflowRunner,name:i.replace,value:a},{type:r.WorkflowRunner,name:i.update,value:a},{type:r.WorkflowRunner,name:i.fix,value:a},{type:r.Function,name:i.relax,value:n},{type:r.Function,name:i.showLog,value:n},{type:r.Reactive,name:i.init$,value:new e},{type:r.Reactive,name:i.isLoading$,value:new e},{type:r.Reactive,name:i.loopPending$,value:new e},{type:r.Reactive,name:i.firstVisible$,value:new e(d,{emitOnSubscribe:!0})},{type:r.Reactive,name:i.lastVisible$,value:new e(d,{emitOnSubscribe:!0})},{type:r.Reactive,name:i.bof$,value:new e},{type:r.Reactive,name:i.eof$,value:new e}],u=new Map;var f={name:"vscroll",version:"1.2.0"};let p=0;class g{constructor(e){const{mock:i,reactive:r}=e,n=++p,o={configurable:!0},a={};Object.defineProperty(this,t.id,Object.assign({get:()=>n},o)),Object.defineProperty(this,t.mock,Object.assign({get:()=>i},o)),Object.defineProperty(this,t.augmented,Object.assign({get:()=>!1},o)),Object.defineProperty(this,t.version,Object.assign({get:()=>f.version},o)),h().filter((({permanent:e})=>!e)).forEach((({name:e,value:t,type:i})=>{if(r&&i===s.Reactive){const s=r[e];s&&(a[e]=Object.assign(Object.assign({},s),{default:t}),t=s.source)}Object.defineProperty(this,e,Object.assign({get:()=>t},o))})),r&&u.set(n,a)}}class m{constructor(e,t){this.get=e.get,e.settings&&(this.settings=e.settings),e.devSettings&&(this.devSettings=e.devSettings);const s=new g(t||{mock:!1});this.adapter=s}dispose(){u.delete(this.adapter.id)}}const x=e=>class extends m{constructor(t){super(t,"function"==typeof e?e():void 0)}},b=x();var I,w,v;!function(e){e.forward="forward",e.backward="backward"}(I||(I={})),function(e){e.Average="average",e.Constant="constant",e.Frequent="frequent"}(w||(w={})),function(e){e.number="must be a number",e.integer="must be an integer",e.integerUnlimited="must be an integer or infinity",e.moreOrEqual="must be a number greater than (or equal to) {arg1}",e.itemList="must be an array of items {arg1}",e.boolean="must be a boolean",e.object="must be an object",e.element="must be an html element",e.function="must be a function",e.funcOfxArguments="must have {arg1} argument(s)",e.funcOfxAndMoreArguments="must have at least {arg1} argument(s)",e.funcOfXToYArguments="must have {arg1} to {arg2} arguments",e.oneOfCan="can be present as only one item of {arg1} list",e.oneOfMust="must be present as only one item of {arg1} list",e.or="must satisfy at least 1 validator from {arg1} list",e.enum="must belong to {arg1} list"}(v||(v={}));const y=(e,t)=>(t||[""]).reduce(((e,t,s)=>e.replace(`{arg${s+1}}`,t)),e),S=e=>"number"==typeof e||"string"==typeof e&&""!==e?Number(e):NaN,z=e=>{const t=S(e),s=[];return Number.isNaN(t)&&s.push(v.number),{value:t,isSet:!0,isValid:!s.length,errors:s}},k=(e,t)=>s=>{const i=z(s);if(!i.isValid)return i;let r=i.value;const n=[];return r<e&&(t?r=e:n.push(y(v.moreOrEqual,[String(e)]))),{value:r,isSet:!0,isValid:!n.length,errors:n}},$=e=>{const t=[];return"function"!=typeof e&&t.push(v.function),{value:e,isSet:!0,isValid:!t.length,errors:t}},N=(e,t)=>s=>{const i=$(s);if(!i.isValid)return i;const r=[];return((s=i.value).length<e||s.length>t)&&r.push(y(v.funcOfXToYArguments,[String(e),String(t)])),{value:s,isSet:!0,isValid:!r.length,errors:r}},E=(e,t)=>(s,i)=>{const r=[],n=void 0!==s;let o=!n;const a=t?v.oneOfMust:v.oneOfCan;if(Array.isArray(e)&&e.length){for(let t=e.length-1;t>=0;t--){const s=e[t];if("string"!=typeof s){r.push(y(a,[e.join('", "')])+" (non-string token)");break}const l=i&&Object.prototype.hasOwnProperty.call(i,s);if(n&&l){r.push(y(a,[e.join('", "')])+` (${s} is present)`);break}o&&l&&(o=!1)}t&&o&&r.push(y(a,[e.join('", "')]))}else r.push(y(a,["undefined"]));return{value:s,isSet:n,isValid:!r.length,errors:r}},M=e=>t=>{const s=[],i=Object.keys(e).filter((e=>isNaN(Number(e)))).map((t=>e[t]));return i.some((e=>e===t))||s.push(y(v.enum,["["+i.join(",")+"]"])),{value:t,isSet:!0,isValid:!s.length,errors:s}},V={NUMBER:{type:v.number,method:z},INTEGER:{type:v.integer,method:e=>{const t=[];e=S(e);const s=parseInt(String(e),10);return e!==s&&t.push(v.integer),{value:s,isSet:!0,isValid:!t.length,errors:t}}},INTEGER_UNLIMITED:{type:v.integerUnlimited,method:e=>{let t=e;const s=[];return e=S(e),t=Number.isFinite(e)?parseInt(String(e),10):e,e!==t&&s.push(v.integerUnlimited),{value:t,isSet:!0,isValid:!s.length,errors:s}}},MORE_OR_EQUAL:(e,t)=>({type:v.moreOrEqual,method:k(e,t)}),BOOLEAN:{type:v.boolean,method:e=>{const t=[];let s=e;return"true"===e?s=!0:"false"===e&&(s=!1),"boolean"!=typeof s&&t.push(v.boolean),{value:s,isSet:!0,isValid:!t.length,errors:t}}},OBJECT:{type:v.object,method:e=>{const t=[];return"[object Object]"!==Object.prototype.toString.call(e)&&t.push(v.object),{value:e,isSet:!0,isValid:!t.length,errors:t}}},ITEM_LIST:{type:v.itemList,method:e=>{let t=e;const s=[];if(Array.isArray(e))if(e.length){if(e.length>1){const t=typeof e[0];e.some((e=>typeof e!==t))&&s.push(y(v.itemList,["of items of the same type"]))}}else s.push(y(v.itemList,["with at least 1 item"]));else s.push(v.itemList),t=[];return{value:t,isSet:!0,isValid:!s.length,errors:s}}},ELEMENT:{type:v.element,method:e=>{const t=[];return e instanceof Element||e instanceof HTMLDocument||t.push(v.element),{value:e,isSet:!0,isValid:!t.length,errors:t}}},FUNC:{type:v.function,method:$},FUNC_WITH_X_ARGUMENTS:e=>{return{type:v.funcOfxArguments,method:(t=e,e=>{const s=$(e);if(!s.isValid)return s;const i=[];return(e=s.value).length!==t&&i.push(y(v.funcOfxArguments,[String(t)])),{value:e,isSet:!0,isValid:!i.length,errors:i}})};var t},FUNC_WITH_X_AND_MORE_ARGUMENTS:e=>{return{type:v.funcOfxAndMoreArguments,method:(t=e,e=>{const s=$(e);if(!s.isValid)return s;const i=[];return(e=s.value).length<t&&i.push(y(v.funcOfxArguments,[String(t)])),{value:e,isSet:!0,isValid:!i.length,errors:i}})};var t},FUNC_WITH_X_TO_Y_ARGUMENTS:(e,t)=>({type:v.funcOfXToYArguments,method:N(e,t)}),ONE_OF_CAN:e=>({type:v.oneOfCan,method:E(e,!1)}),ONE_OF_MUST:e=>({type:v.oneOfMust,method:E(e,!0)}),OR:e=>{return{type:v.or,method:(t=e,e=>{const s=[];return t.every((t=>!t.method(e).isValid))&&s.push(t.map((e=>e.type)).join(" OR ")),{value:e,isSet:!0,isValid:!s.length,errors:s}})};var t},ENUM:e=>({type:v.enum,method:M(e)})};class O{constructor(e){this.params={},this.contextErrors=[],this.errors=[],this.isValid=!0,this.setContext(e)}setContext(e){e&&"[object Object]"===Object.prototype.toString.call(e)?this.isValidContext=!0:(this.setCommonError("context is not an object"),this.isValidContext=!1),this.context=e}setValidity(){this.errors=Object.keys(this.params).reduce(((e,t)=>[...e,...this.params[t].errors]),[]),this.isValid=!this.errors.length}setCommonError(e){this.contextErrors.push(e),this.errors.push(e),this.isValid=!1}setParam(e,t){t.isValid||(t.errors=t.isSet?t.errors.map((t=>`"${e}" ${t}`)):[`"${e}" must be set`]),this.params[e]=t,this.setValidity()}showErrors(){return this.errors.length?"validation failed: "+this.errors.join(", "):""}}const A=(e,t,s)=>{const{value:i,errors:r}=e,n=t.method(i,s),o=[...r,...n.errors];return{value:n.value,isSet:n.isSet,isValid:!o.length,errors:o}},T=(e,t)=>{const s=void 0===e,i=!t.mandatory&&void 0!==t.defaultValue;return{value:s?i?t.defaultValue:void 0:e,isSet:!s||i,isValid:!s||!t.mandatory,errors:[]}},P=(e,t,s)=>{const i=T(e[t],s);if(i.isSet)for(const t of Object.values(s.validators)){const r=A(i,t,e);if(!r.isValid&&void 0!==s.defaultValue)return{value:s.defaultValue,isSet:!0,isValid:!0,errors:[]};Object.assign(i,r)}else{const t=s.validators.find((e=>e.type===v.oneOfMust));if(t)return A(i,t,e)}return i},R=(e,t)=>{const s=new O(e);return Object.entries(t).forEach((([e,t])=>s.setParam(e,s.isValidContext?P(s.context,e,t):T(void 0,t)))),s},{OBJECT:F,FUNC_WITH_X_AND_MORE_ARGUMENTS:C}=V;var L;!function(e){e.get="get",e.settings="settings",e.devSettings="devSettings"}(L||(L={}));const D={[L.get]:{validators:[C(2)],mandatory:!0},[L.settings]:{validators:[F]},[L.devSettings]:{validators:[F]}},{NUMBER:B,INTEGER:j,INTEGER_UNLIMITED:_,MORE_OR_EQUAL:U,BOOLEAN:W,ELEMENT:q,FUNC:H,OR:G,ENUM:X}=V;var Y,J;!function(e){e.adapter="adapter",e.startIndex="startIndex",e.minIndex="minIndex",e.maxIndex="maxIndex",e.itemSize="itemSize",e.bufferSize="bufferSize",e.padding="padding",e.infinite="infinite",e.horizontal="horizontal",e.windowViewport="windowViewport",e.viewportElement="viewportElement",e.inverse="inverse",e.onBeforeClip="onBeforeClip",e.sizeStrategy="sizeStrategy"}(Y||(Y={})),function(e){e.debug="debug",e.immediateLog="immediateLog",e.logProcessRun="logProcessRun",e.logTime="logTime",e.throttle="throttle",e.initDelay="initDelay",e.initWindowDelay="initWindowDelay",e.cacheData="cacheData",e.cacheOnReload="cacheOnReload",e.changeOverflow="changeOverflow",e.dismissOverflowAnchor="dismissOverflowAnchor"}(J||(J={}));const Q={[Y.itemSize]:1,[Y.bufferSize]:1,[Y.padding]:.01,[J.throttle]:0,[J.initDelay]:0,[J.initWindowDelay]:0},Z={[Y.adapter]:{validators:[W],defaultValue:!1},[Y.startIndex]:{validators:[j],defaultValue:1},[Y.minIndex]:{validators:[_],defaultValue:-1/0},[Y.maxIndex]:{validators:[_],defaultValue:1/0},[Y.itemSize]:{validators:[j,U(Q[Y.itemSize],!0)],defaultValue:NaN},[Y.bufferSize]:{validators:[j,U(Q[Y.bufferSize],!0)],defaultValue:5},[Y.padding]:{validators:[B,U(Q[Y.padding],!0)],defaultValue:.5},[Y.infinite]:{validators:[W],defaultValue:!1},[Y.horizontal]:{validators:[W],defaultValue:!1},[Y.windowViewport]:{validators:[W],defaultValue:!1},[Y.viewportElement]:{validators:[G([q,H])],defaultValue:null},[Y.inverse]:{validators:[W],defaultValue:!1},[Y.onBeforeClip]:{validators:[H],defaultValue:null},[Y.sizeStrategy]:{validators:[X(w)],defaultValue:w.Average}},K={[J.debug]:{validators:[W],defaultValue:!1},[J.immediateLog]:{validators:[W],defaultValue:!0},[J.logProcessRun]:{validators:[W],defaultValue:!1},[J.logTime]:{validators:[W],defaultValue:!1},[J.throttle]:{validators:[j,U(Q[J.throttle],!0)],defaultValue:40},[J.initDelay]:{validators:[j,U(Q[J.initDelay],!0)],defaultValue:1},[J.initWindowDelay]:{validators:[j,U(Q[J.initWindowDelay],!0)],defaultValue:40},[J.cacheData]:{validators:[W],defaultValue:!1},[J.cacheOnReload]:{validators:[W],defaultValue:!1},[J.changeOverflow]:{validators:[W],defaultValue:!1},[J.dismissOverflowAnchor]:{validators:[W],defaultValue:!0}};var ee,te,se;!function(e){e.init="init",e.scroll="scroll",e.start="start",e.preFetch="preFetch",e.fetch="fetch",e.postFetch="postFetch",e.render="render",e.preClip="preClip",e.clip="clip",e.adjust="adjust",e.end="end"}(ee||(ee={})),function(e){e.reset="adapter.reset",e.reload="adapter.reload",e.append="adapter.append",e.prepend="adapter.prepend",e.check="adapter.check",e.remove="adapter.remove",e.replace="adapter.replace",e.update="adapter.update",e.clip="adapter.clip",e.insert="adapter.insert",e.fix="adapter.fix"}(te||(te={})),function(e){e.start="start",e.next="next",e.done="done",e.error="error"}(se||(se={}));const{INTEGER:ie,INTEGER_UNLIMITED:re,BOOLEAN:ne,OBJECT:oe,ITEM_LIST:ae,FUNC_WITH_X_ARGUMENTS:le,FUNC_WITH_X_AND_MORE_ARGUMENTS:ce,FUNC_WITH_X_TO_Y_ARGUMENTS:de,ONE_OF_MUST:he,ONE_OF_CAN:ue,OR:fe}=V;var pe;pe||(pe={});const ge={[L.get]:{validators:[ce(2)]},[L.settings]:{validators:[oe]},[L.devSettings]:{validators:[oe]}};var me;!function(e){e.reloadIndex="reloadIndex"}(me||(me={}));const xe={[me.reloadIndex]:{validators:[ie]}};var be;!function(e){e.items="items",e.bof="bof",e.eof="eof"}(be||(be={}));const Ie={[be.items]:{validators:[ae],mandatory:!0},[be.bof]:{validators:[ne,ue([be.eof])]},[be.eof]:{validators:[ne,ue([be.bof])]}};var we;!function(e){e.predicate="predicate",e.indexes="indexes",e.increase="increase"}(we||(we={}));const ve={[we.predicate]:{validators:[le(1),he([we.indexes])]},[we.indexes]:{validators:[ae,he([we.predicate])]},[we.increase]:{validators:[ne],defaultValue:!1}};var ye;!function(e){e.backwardOnly="backwardOnly",e.forwardOnly="forwardOnly"}(ye||(ye={}));const Se={[ye.backwardOnly]:{validators:[ne,ue([ye.forwardOnly])],defaultValue:!1},[ye.forwardOnly]:{validators:[ne,ue([ye.backwardOnly])],defaultValue:!1}};var ze;!function(e){e.items="items",e.before="before",e.after="after",e.decrease="decrease"}(ze||(ze={}));const ke={[ze.items]:{validators:[ae],mandatory:!0},[ze.before]:{validators:[le(1),he([ze.after])]},[ze.after]:{validators:[le(1),he([ze.before])]},[ze.decrease]:{validators:[ne],defaultValue:!1}};var $e;!function(e){e.items="items",e.predicate="predicate",e.fixRight="fixRight"}($e||($e={}));const Ne={[ze.items]:{validators:[ae],mandatory:!0},[$e.predicate]:{validators:[le(1)],mandatory:!0},[$e.fixRight]:{validators:[ne],defaultValue:!1}};var Ee;!function(e){e.predicate="predicate",e.fixRight="fixRight"}(Ee||(Ee={}));const Me={[Ee.predicate]:{validators:[le(1)],mandatory:!0},[Ee.fixRight]:{validators:[ne],defaultValue:!1}};var Ve;!function(e){e.scrollPosition="scrollPosition",e.minIndex="minIndex",e.maxIndex="maxIndex",e.updater="updater",e.scrollToItem="scrollToItem",e.scrollToItemOpt="scrollToItemOpt"}(Ve||(Ve={}));const Oe={[Ve.scrollPosition]:{validators:[re]},[Ve.minIndex]:{validators:[re]},[Ve.maxIndex]:{validators:[re]},[Ve.updater]:{validators:[de(1,2)]},[Ve.scrollToItem]:{validators:[le(1)]},[Ve.scrollToItemOpt]:{validators:[fe([ne,oe])]}},Ae={[te.reset]:L,[te.reload]:me,[te.append]:be,[te.prepend]:be,[te.check]:pe,[te.remove]:we,[te.clip]:ye,[te.insert]:ze,[te.replace]:$e,[te.update]:Ee,[te.fix]:Ve},Te={[te.reset]:ge,[te.reload]:xe,[te.append]:Ie,[te.prepend]:Ie,[te.check]:{},[te.remove]:ve,[te.clip]:Se,[te.insert]:ke,[te.replace]:Ne,[te.update]:Me,[te.fix]:Oe};class Pe{constructor(e,t,s){this.parseInput(e,Z),this.parseInput(t,K),this.instanceIndex=s,this.initializeDelay=this.getInitializeDelay(),this.viewport=this.getViewport()}parseInput(e,t){const s=R(e,t);if(!s.isValid)throw new Error("Invalid settings");Object.entries(s.params).forEach((([e,t])=>Object.assign(this,{[e]:t.value})))}getInitializeDelay(){let e=0;return this.windowViewport&&this.initWindowDelay&&!("scrollRestoration"in history)&&(e=this.initWindowDelay),this.initDelay>0&&(e=Math.max(e,this.initDelay)),e}getViewport(){if("function"!=typeof this.viewportElement)return this.viewportElement;const e=this.viewportElement(),t=P({value:e},"value",{validators:[V.ELEMENT]});return t.isValid?t.value:null}}const Re=e=>{var t;return(t=class{}).process=e,t},Fe=e=>{var t;return(t=class extends(Re(e)){static parseInput(t,s,i=!1){const r={data:R(s,Te[e])};return r.data.isValid?r.params=Object.entries(r.data.params).reduce(((e,[t,{value:s}])=>Object.assign(Object.assign({},e),{[t]:s})),{}):(t.logger.log((()=>r.data.showErrors())),i||t.workflow.call({process:e,status:se.error,payload:{error:`Wrong argument of the "${e}" method call`}})),r}}).process=e,t},Ce=[ee.init,te.reset,te.reload];class Le extends(Re(ee.init)){static run(e,t){const{state:{cycle:s},workflow:i}=e,r=Ce.includes(t);e.logger.logCycle(!0),s.start(r,t),i.call({process:Le.process,status:se.next})}}class De extends(Re(ee.scroll)){static run(e,t){const{workflow:s,viewport:i}=e,r=i.scrollPosition;De.onSynthetic(e,r)||De.onThrottle(e,r,(()=>De.onScroll(e,s)))}static onSynthetic(e,t){const{scrollState:s}=e.state,i=s.syntheticPosition;if(null!==i){if(s.syntheticFulfill&&(s.syntheticPosition=null),!s.syntheticFulfill||i===t)return e.logger.log((()=>["skipping scroll",t,`[${s.syntheticFulfill?"":"pre-"}synthetic]`])),!0;e.logger.log((()=>["synthetic scroll has been fulfilled:",t,t<i?"<":">",i]))}return!1}static onThrottle(e,t,s){const{state:{scrollState:i},settings:{throttle:r},logger:n}=e;i.current=De.getScrollEvent(t,i.previous);const{direction:o,time:a}=i.current,l=i.previous?a-i.previous.time:1/0,c=r-l,d=isFinite(c)&&c>0,h=!!i.scrollTimer;if(n.log((()=>[o===I.backward?"⤴":"⤵",t,d?l+"ms":"0ms",d?h?"delayed":`/ ${c}ms delay`:""])),!d)return i.scrollTimer&&(clearTimeout(i.scrollTimer),i.scrollTimer=null),void s();h||(i.scrollTimer=setTimeout((()=>{n.log((()=>{const s=De.getScrollEvent(e.viewport.scrollPosition,i.current);return[s.direction===I.backward?"⤴":"⤵",s.position,s.time-a+"ms","triggered by timer set on",t]})),i.scrollTimer=null,s()}),c))}static getScrollEvent(e,t){const s=Number(new Date);let i=I.forward;return t&&(e===t.position?i=t.direction:e<t.position&&(i=I.backward)),{position:e,direction:i,time:s}}static onScroll(e,t){const{state:{scrollState:s,cycle:i}}=e;s.previous=Object.assign({},s.current),s.current=null,i.busy.get()?e.logger.log((()=>["skipping scroll",s.previous.position,"[pending]"])):t.call({process:De.process,status:se.next})}}class Be extends(Fe(te.reset)){static run(e,t){const{datasource:s,buffer:i,viewport:{paddings:r},state:{cycle:n}}=e;if(t){const{data:i}=Be.parseInput(e,t);if(!i.isValid)return;const r=t instanceof b;Object.keys(L).forEach((e=>{const t=i.params[e],n=s;(t.isSet||r&&n[e])&&(n[e]=t.value)}))}i.reset(!0),r.backward.reset(),r.forward.reset();const o={datasource:s};n.busy.get()&&(o.finalize=!0,n.interrupter=Be.process),e.workflow.call({process:Be.process,status:se.next,payload:o})}}class je extends(Fe(te.reload)){static run(e,t){const{viewport:s,state:i,buffer:r}=e,{params:n}=je.parseInput(e,{reloadIndex:t},!0);r.reset(!1,n?n.reloadIndex:void 0),s.reset(r.startIndex);const o={};i.cycle.busy.get()&&(i.scrollState.cleanupTimers(),o.finalize=!0,i.cycle.interrupter=je.process),e.workflow.call({process:je.process,status:se.next,payload:o})}}class _e{constructor(e,t,s){this.container={$index:e,data:t},this.nodeId=String(e),this.routines=s,this.invisible=!0,this.toRemove=!1,this.toInsert=!1}get $index(){return this.container.$index}set $index(e){this.container.$index=e}get data(){return this.container.data}set data(e){this.container.data=e}get element(){return this.container.element}set element(e){this.container.element=e}dispose(){delete this.container.element}setSize(){this.size=this.routines.getSize(this.element)}hide(){this.element&&this.routines.hideElement(this.element)}scrollTo(e){this.element&&this.routines.scrollTo(this.element,e)}updateIndex(e){this.$index=e,this.nodeId=String(e)}get(){return this.container}}class Ue extends(Fe(te.append)){static run(e,{process:t,options:s}){const{params:i}=Ue.parseInput(e,s);if(!i)return;const{items:r,bof:n,eof:o}=i,a=t!==te.append,l=!!(a?n:o);if(a&&l&&!e.buffer.bof.get()||!a&&l&&!e.buffer.eof.get())return Ue.doVirtualize(e,r,a),void e.workflow.call({process:Ue.process,status:se.done});Ue.simulateFetch(e,r,l,a),e.workflow.call({process:Ue.process,status:se.next})}static doVirtualize(e,t,s){const{buffer:i,viewport:{paddings:r}}=e,n=s?"absMinIndex":"absMaxIndex";if(isFinite(i[n])){const o=t.length*i.defaultSize,a=s?r.backward:r.forward;i[n]+=(s?-1:1)*t.length,a.size+=o,s&&(e.viewport.scrollPosition+=o),e.logger.log((()=>`buffer.${[n]} value is set to ${i[n]}`)),e.logger.stat("after virtual "+(s?"prepend":"append"))}}static simulateFetch(e,t,s,i){const{buffer:r,state:{fetch:n}}=e,o=i?"absMinIndex":"absMaxIndex";let a=r.getIndexToAdd(s,i),l=r[o];const c=[];for(let s=0;s<t.length;s++){const r=new _e(a,t[s],e.routines);isFinite(l)&&(i&&a<l||!i&&a>l)&&(l+=i?-1:1),(i?Array.prototype.unshift:Array.prototype.push).apply(c,[r]),a+=i?-1:1}return l!==r[o]&&(r[o]=l,e.logger.log((()=>`buffer.${o} value is set to ${r[o]}`))),(i?n.prepend:n.append).call(n,c),(i?r.prepend:r.append).call(r,c),n.first.indexBuffer=isNaN(r.firstIndex)?a:r.firstIndex,n.last.indexBuffer=isNaN(r.lastIndex)?a:r.lastIndex,!0}}class We extends(Fe(te.check)){static run(e){const{workflow:t,buffer:s,state:{fetch:i},viewport:r}=e;let n=1/0,o=-1/0;if(s.items.forEach((e=>{const t=e.size;e.setSize(),e.size!==t&&(s.cacheItem(e),n=Math.min(n,e.$index),o=Math.max(o,e.$index))})),Number.isFinite(n)){i.first.indexBuffer=s.firstIndex,i.last.indexBuffer=s.lastIndex;const{index:e,diff:t}=r.getEdgeVisibleItem(s.items,I.backward);i.firstVisibleIndex=e,isNaN(e)||(i.firstVisibleItemDelta=-s.getSizeByIndex(e)+t),i.check(s.items.filter((e=>e.$index>=n&&e.$index<=o)))}e.logger.stat("check"),t.call({process:We.process,status:Number.isFinite(n)?se.next:se.done})}}class qe extends(Fe(te.remove)){static run(e,t){const{params:s}=qe.parseInput(e,t);if(!s)return;const i=qe.doRemove(e,s);e.workflow.call({process:qe.process,status:i?se.next:se.done})}static doRemove(e,t,s=!1){const{fetch:i}=e.state;i.firstVisibleIndex=NaN;const r=qe.removeBufferedItems(e,t);t.indexes&&t.indexes.length&&(t.indexes=t.indexes.filter((e=>!r.includes(e))));const n=r.length>0,o=qe.removeVirtualItems(e,t,s);return!(!n&&!o)&&(isNaN(i.firstVisibleIndex)||i.remove(),e.logger.stat("after remove"),!0)}static removeBufferedItems(e,t){const{predicate:s,indexes:i,increase:r}=t;let n=[];if(s&&(n=qe.runPredicateOverBuffer(e,s,!!r)),i){const t=({$index:e})=>i.indexOf(e)>=0;n=qe.runPredicateOverBuffer(e,t,!!r)}return n}static runPredicateOverBuffer(e,t,s){const{viewport:i,buffer:r,buffer:{items:n},state:{fetch:o}}=e,a=[];for(let e=0;e<n.length;e++){const s=n[e];if(t(s.get()))a.push(s),s.toRemove=!0;else if(a.length)break}if(!a.length)return[];const l=a[0].$index,c=a[a.length-1].$index,{index:d,diff:h}=i.getEdgeVisibleItem(r.items,I.backward);(d<l||d>c)&&(o.firstVisibleIndex=d,o.firstVisibleItemDelta=-r.getSizeByIndex(d)+h),isNaN(o.firstVisibleIndex)&&c<r.finiteAbsMaxIndex&&(o.firstVisibleIndex=c+1),isNaN(o.firstVisibleIndex)&&l>r.finiteAbsMinIndex&&(o.firstVisibleIndex=l-1),isNaN(o.firstVisibleIndex)&&(o.firstVisibleIndex=r.finiteAbsMinIndex);const u=a.map((e=>e.$index));return e.logger.log((()=>`going to remove ${a.length} item(s) from Buffer: [${u.join(",")}]`)),r.removeItems(u,s,!1),r.checkDefaultSize(),qe.shiftFirstVisibleIndex(e,u,s),a.forEach((e=>e.hide())),u}static removeVirtualItems(e,t,s){const{indexes:i,increase:r}=t;if(!i||!i.length)return!1;const{buffer:n,viewport:o,state:{fetch:a}}=e,{finiteAbsMinIndex:l,firstIndex:c,finiteAbsMaxIndex:d,lastIndex:h}=n,u=[];let f=NaN;for(let e=0,t=i.length;e<t;e++){const t=i[e];if(t>=l&&!isNaN(c)&&t<c)u.push(t);else{if(!(t<=d&&!isNaN(h)&&t>h))continue;u.push(t)}if(s&&!isNaN(f)&&Math.abs(f-t)>1)break;f=t}if(!u.length)return!1;if(isNaN(a.firstVisibleIndex)){const{index:e,diff:t}=o.getEdgeVisibleItem(n.items,I.backward);isNaN(e)||(a.firstVisibleIndex=e,a.firstVisibleItemDelta=-n.getSizeByIndex(e)+t)}return e.logger.log((()=>`going to remove ${u.length} item(s) virtually`)),n.removeItems(u,!!r,!0),n.checkDefaultSize(),qe.shiftFirstVisibleIndex(e,u,!!r),!0}static shiftFirstVisibleIndex({state:{fetch:e}},t,s){if(isNaN(e.firstVisibleIndex))return;const i=t.reduce(((t,i)=>t+(s&&i>e.firstVisibleIndex||!s&&i<e.firstVisibleIndex?1:0)),0);e.firstVisibleIndex=e.firstVisibleIndex+(s?i:-i)}}class He extends(Fe(te.clip)){static run(e,t){const{params:s}=He.parseInput(e,t);e.state.clip.forceForward=!(s&&s.backwardOnly),e.state.clip.forceBackward=!(s&&s.forwardOnly),e.workflow.call({process:He.process,status:se.next})}}class Ge extends(Fe(te.update)){static run(e,t){const{params:s}=Ge.parseInput(e,t);if(!s)return;const i=Ge.doUpdate(e,s);e.workflow.call({process:Ge.process,status:i?se.next:se.done})}static doUpdate(e,t){const{buffer:s,viewport:i,state:{fetch:r},routines:n,logger:o}=e;if(!s.items)return o.log((()=>"no items in Buffer")),!1;const a=[...s.items],{item:l,index:c,diff:d}=i.getEdgeVisibleItem(s.items,I.backward),h=s.updateItems(t.predicate,((e,t)=>new _e(e,t,n)),c,!!t.fixRight);let u=0;const f=s.get(h);l&&l===f&&(u=-s.getSizeByIndex(h)+d);const p=a.filter((({toRemove:e})=>e));p.forEach((e=>e.hide())),o.log((()=>p.length?"items to remove: ["+p.map((({$index:e})=>e)).join(",")+"]":"no items to remove"));const g=s.items.filter((({toInsert:e})=>e));return o.log((()=>g.length?"items to render: ["+g.map((({$index:e})=>e)).join(",")+"]":"no items to render")),r.update(h,u,g,p),!!p.length||!!g.length}}class Xe extends(Fe(te.insert)){static run(e,t){const{params:s}=Xe.parseInput(e,t);if(!s)return;const i=Xe.doInsert(e,s);e.workflow.call({process:Xe.process,status:i?se.next:se.done})}static doInsert(e,t){const{before:s,after:i,items:r,decrease:n}=t,o=s||i,a=e.buffer.items.find((e=>o(e.get())));if(!a)return e.logger.log("no item to insert found"),!1;const l=a.$index,c={predicate:({$index:e,data:t})=>l!==e||(s?[...r,t]:[t,...r]),fixRight:n};return Ge.doUpdate(e,c)}}class Ye extends(Fe(te.replace)){static run(e,t){const{params:s}=Ye.parseInput(e,t);if(!s)return;const i=Ye.doReplace(e,s);e.workflow.call({process:Ye.process,status:i?se.next:se.done})}static doReplace(e,t){const s=e.buffer.items.filter((e=>t.predicate(e))).map((e=>e.$index));if(!s.length)return e.logger.log("no items to be replaced"),!1;let i=!1;const r={predicate:({$index:e})=>!s.includes(e)||!i&&(i=!0,t.items),fixRight:t.fixRight};return Ge.doUpdate(e,r)}}const{[te.fix]:Je}=Ae;class Qe extends(Fe(te.fix)){static run(e,t){const{workflow:s}=e,{data:i,params:r}=Qe.parseInput(e,t);r&&(Object.entries(i.params).forEach((([t,s])=>{s.isSet&&s.isValid&&Qe.runByType(e,t,s.value,i)})),s.call({process:Qe.process,status:se.done}))}static runByType(e,t,s,i){switch(t){case Je.scrollPosition:return Qe.setScrollPosition(e,s);case Je.minIndex:return Qe.setMinIndex(e,s);case Je.maxIndex:return Qe.setMaxIndex(e,s);case Je.updater:return Qe.updateItems(e,s);case Je.scrollToItem:if(i.params){const t=i.params[Je.scrollToItemOpt],r=t?t.value:void 0;return Qe.scrollToItem(e,s,r)}return;case Je.scrollToItemOpt:return}}static setScrollPosition({viewport:e},t){let s=t;t===-1/0?s=0:t===1/0&&(s=e.getScrollableSize()),e.setPosition(s)}static setMinIndex({buffer:e,settings:t},s){t.minIndex=s,e.absMinIndex=s}static setMaxIndex({buffer:e,settings:t},s){t.maxIndex=s,e.absMaxIndex=s}static updateItems({buffer:e,logger:t},s){let i=!1;const r=()=>i=!0;e.items.forEach((e=>s(e.get(),r))),i&&(t.log((()=>"update Buffer.items reference")),e.items=[...e.items])}static scrollToItem(e,t,s){const i=e.buffer.items.find((e=>t(e.get())));i?i.scrollTo(s):e.logger.log((()=>"scrollToItem cancelled, item not found"))}}class Ze extends(Re(ee.start)){static run(e){const t=e.state.startInnerLoop();e.workflow.call({process:Ze.process,status:se.next,payload:t})}}class Ke extends(Re(ee.preFetch)){static run(e){const{workflow:t,buffer:s,state:{fetch:i,cycle:r}}=e;i.minIndex=s.minIndex,Ke.setPositionsAndIndexes(e),Ke.skipBufferedItems(e),e.settings.infinite&&Ke.checkBufferGaps(e),Ke.checkFetchPackSize(e),Ke.setFetchDirection(e),t.call({process:Ke.process,status:Ke.getStatus(e),payload:{process:r.initiator}})}static setPositionsAndIndexes(e){Ke.setPositions(e),Ke.setFirstIndex(e),Ke.setLastIndex(e),e.logger.fetch()}static setPositions(e){const{state:{fetch:{positions:t}},viewport:s}=e,i=s.getBufferPadding();t.before=s.scrollPosition,t.startDelta=Ke.getStartDelta(e),t.relative=t.before-t.startDelta,t.start=t.relative-i,t.end=t.relative+s.getSize()+i}static getStartDelta(e){const{buffer:t,viewport:{offset:s}}=e;let i=0;if(s&&(i+=s),!t.defaultSize)return i;for(let e=t.finiteAbsMinIndex;e<t.startIndex;e++)i+=t.getSizeByIndex(e);return e.logger.log((()=>[`start delta is ${i}`,...s?[` (+${s} offset)`]:[]])),i}static setFirstIndex(e){const{state:t,buffer:s}=e,{positions:{start:i},first:r}=t.fetch;let n=s.startIndex,o=0;if(t.cycle.innerLoop.isInitial)e.logger.log("skipping fetch backward direction [initial loop]");else if(s.defaultSize){let e=o,t=n;for(;;){if(i>=0){const r=s.getSizeByIndex(t);if(e+r-i>0){n=t,o=e;break}if(e+=r,t++,t<s.absMinIndex)break}if(i<0){if(t--,t<s.absMinIndex)break;e-=s.getSizeByIndex(t);if(n=t,o=e,e-i<=0)break}}}else e.logger.log("skipping fetch backward direction [no item size]");r.index=r.indexBuffer=Math.max(n,s.absMinIndex),r.position=o}static setLastIndex(e){const{state:{fetch:t,cycle:s},buffer:i,settings:r}=e,{positions:{relative:n,end:o},first:a,last:l}=t;let c;if(i.defaultSize){let e=a.indexBuffer,r=a.position;for(c=e;;){c=e;const a=i.getSizeByIndex(e);if(r+=a,isNaN(t.firstVisibleIndex)&&r>n&&(t.firstVisibleIndex=e,s.innerLoop.isInitial||(t.firstVisibleItemDelta=r-a-n)),r>=o)break;if(e++>i.absMaxIndex)break}}else c=i.startIndex+r.bufferSize-1,e.logger.log("forcing fetch forward direction [no item size]");l.index=l.indexBuffer=Math.min(c,i.absMaxIndex)}static skipBufferedItems(e){const{buffer:t}=e;if(!t.size)return;const{fetch:s}=e.state,i=s.first.index,r=s.last.index,n=[[]];let o=0;for(let e=i;e<=r;e++)t.get(e)?n[o].length&&(n[++o]=[]):n[o].push(e);let a=n[0];n[0].length&&n[1]&&n[1].length&&(s.hasAnotherPack=!0,n[1].length>=n[0].length&&(a=n[1])),s.first.index=Math.max(a[0],t.absMinIndex),s.last.index=Math.min(a[a.length-1],t.absMaxIndex),s.first.index===i&&s.last.index===r||e.logger.fetch("after Buffer flushing")}static checkBufferGaps(e){const{buffer:t,state:{fetch:s}}=e;if(!t.size)return;const i=s.first.index,r=t.lastIndex;i>r&&(s.first.index=s.first.indexBuffer=r+1);const n=t.firstIndex,o=s.last.index;o<n&&(s.last.index=s.last.indexBuffer=n-1),s.first.index===i&&s.last.index===o||e.logger.fetch("after Buffer filling (no clip case)")}static checkFetchPackSize(e){const{buffer:t,state:{fetch:s}}=e;if(!s.shouldFetch)return;const i=s.first.index,r=s.last.index,n=e.settings.bufferSize-(r-i+1);if(!(n<=0)){if(!t.size||r>t.items[0].$index){const e=Math.min(r+n,t.absMaxIndex);e>r&&(s.last.index=s.last.indexBuffer=e)}else{const e=Math.max(i-n,t.absMinIndex);e<i&&(s.first.index=s.first.indexBuffer=e)}s.first.index===i&&s.last.index===r||(e.logger.fetch("after bufferSize adjustment"),Ke.skipBufferedItems(e))}}static setFetchDirection(e){const{buffer:t,state:{fetch:s}}=e;if(s.last.index){let i=I.forward;t.size&&(i=s.last.index<t.items[0].$index?I.backward:I.forward),s.direction=i,e.logger.log((()=>`fetch direction is "${i}"`))}}static getStatus(e){const{cycle:t,fetch:s}=e.state;return t.initiator===te.clip?(e.logger.log((()=>`going to skip fetch due to "${te.clip}" process`)),se.next):s.shouldFetch?(e.logger.log((()=>`going to fetch ${s.count} items started from index ${s.index}`)),se.next):se.done}}class et extends(Re(ee.fetch)){static run(e){const{workflow:t}=e,s={success:s=>{e.logger.log((()=>`resolved ${s.length} items (index = ${e.state.fetch.index}, count = ${e.state.fetch.count})`)),e.state.fetch.newItemsData=s,t.call({process:et.process,status:se.next})},fail:e=>t.call({process:et.process,status:se.error,payload:{error:e}})},i=et.get(e);et.complete(e,s,i)}static complete(e,t,s){if(Object.prototype.hasOwnProperty.call(s,"data")){const{data:e,error:i,isError:r}=s;r?t.fail(i):t.success(e||[])}else{const{state:{scrollState:i,fetch:r},viewport:n}=e;null===i.positionBeforeAsync&&(i.positionBeforeAsync=n.scrollPosition),r.cancel=()=>{t.success=()=>null,t.fail=()=>null},s.then((e=>t.success(e)),(e=>t.fail(e)))}}static get(e){const t=e.datasource.get,{index:s,count:i}=e.state.fetch;let r,n,o,a;const l=e=>{o?o(e):r=e||null},c=e=>{a?a(e):n=e||null},d=t(s,i,l,c);if(d&&"object"==typeof d&&null!==d){if("function"==typeof d.then)return d;if("function"==typeof d.subscribe){const e=d.subscribe(l,c,(()=>{e&&"object"==typeof e&&"function"==typeof e.unsubscribe&&e.unsubscribe()}))}}return r||n?{data:n?null:r||[],error:n,isError:!!n}:new Promise(((e,t)=>{o=e,a=t}))}}class tt extends(Re(ee.postFetch)){static run(e){const{workflow:t}=e;tt.setItems(e)?(tt.setBufferLimits(e),t.call({process:tt.process,status:e.state.fetch.hasNewItems?se.next:se.done})):t.call({process:tt.process,status:se.error,payload:{error:"Can't set buffer items"}})}static setBufferLimits(e){const{buffer:t,state:{fetch:s,fetch:{items:i},cycle:{innerLoop:r}}}=e,n=s.first.index,o=s.last.index;if(i.length){const e=i.length-1;n<i[0].$index&&(t.absMinIndex=i[0].$index),o>i[e].$index&&(t.absMaxIndex=i[e].$index)}else(o<t.minIndex||r.isInitial)&&(t.absMinIndex=t.minIndex),(n>t.maxIndex||r.isInitial)&&(t.absMaxIndex=t.maxIndex)}static setItems(e){const{buffer:t,state:{fetch:s,cycle:i}}=e,r=s.newItemsData;if(!r||!r.length)return!0;let n=s.index;return r.length<s.count&&(i.innerLoop.isInitial?n=t.startIndex:s.first.index<t.minIndex&&(n=t.minIndex-r.length)),s.items=r.map(((t,s)=>new _e(n+s,t,e.routines))),s.isPrepend=!!t.items.length&&t.items[0].$index>s.items[s.items.length-1].$index,t.setItems(s.items)}}class st extends(Re(ee.render)){static run(e){const{workflow:t,state:{cycle:s,render:i,scrollState:r},viewport:n}=e;e.logger.stat("before new items render"),null===r.positionBeforeAsync&&(r.positionBeforeAsync=n.scrollPosition),i.renderTimer=setTimeout((()=>{i.renderTimer=null,st.doRender(e)?t.call({process:st.process,status:i.noSize?se.done:se.next,payload:{process:s.initiator}}):t.call({process:st.process,status:se.error,payload:{error:"Can't associate item with element"}})}),0)}static doRender(e){const{state:{fetch:t,render:s},viewport:i,buffer:r,logger:n}=e;return s.positionBefore=i.scrollPosition,!(!t.isCheck&&(s.sizeBefore=i.getScrollableSize(),t.items.map((t=>st.processElement(e,t))).some((e=>!e))))&&(r.checkDefaultSize(),s.sizeAfter=i.getScrollableSize(),n.stat("after new items render"),n.log((()=>s.noSize?"viewport size has not been changed":void 0)),!0)}static processElement(e,t){const{state:{fetch:s},viewport:i,buffer:r}=e,n=i.element.querySelector(`[data-sid="${t.nodeId}"]`);return!!n&&(t.element=n,t.element.style.left="",t.element.style.top="",t.element.style.position="",t.invisible=!1,t.setSize(),r.cacheItem(t),t.$index<s.minIndex&&(s.negativeSize+=t.size),!0)}}class it extends(Re(ee.adjust)){static run(e){const{workflow:t,viewport:s,state:{scrollState:i}}=e;i.positionBeforeAdjust=s.scrollPosition,it.setPaddings(e),i.positionAfterAdjust=s.scrollPosition;const r=it.calculatePosition(e);it.setPosition(e,r,(()=>t.call({process:it.process,status:se.done})))}static setPaddings(e){const{viewport:t,buffer:s,settings:{inverse:i},state:{fetch:r}}=e,n=s.getFirstVisibleItem(),o=s.getLastVisibleItem();let a,l;n&&o?(a=n.$index,l=o.$index):(a=isNaN(r.firstVisibleIndex)?s.startIndex:r.firstVisibleIndex,l=a-1);const{forward:c,backward:d}=t.paddings;let h,u=0,f=0;for(h=s.finiteAbsMinIndex;h<a;h++)u+=s.getSizeByIndex(h);for(h=l+1;h<=s.finiteAbsMaxIndex;h++)f+=s.getSizeByIndex(h);const p=t.getScrollableSize()-c.size-d.size,g=t.getSize()-(u+p+f);g>0&&(i?u+=g:f+=g,e.logger.log((()=>i?"backward":`forward padding will be increased by ${g} to fill the viewport`))),d.size=u,c.size=f,e.logger.stat("after paddings adjustments")}static calculatePosition(e){const{viewport:t,buffer:s,state:i}=e,{fetch:r,render:n,scrollState:o}=i;let a=t.paddings.backward.size;if(isNaN(r.firstVisibleIndex)||isNaN(s.firstIndex))r.isPrepend&&r.negativeSize&&(a+=r.negativeSize);else{for(let e=s.firstIndex;e<r.firstVisibleIndex;e++)a+=s.getSizeByIndex(e);r.firstVisibleItemDelta&&(a-=r.firstVisibleItemDelta)}if(null!==o.positionBeforeAsync){const t=n.positionBefore-o.positionBeforeAsync;0!==t&&(e.logger.log(`shift position due to fetch-render difference (${t})`),a+=t)}return t.offset>0&&(a||r.positions.before)&&(a+=t.offset),Math.round(a)}static setPosition(e,t,s){const{state:{scrollState:i},viewport:r}=e;if(!i.hasPositionChanged(t))return s();i.syntheticPosition=t,i.syntheticFulfill=!1,i.animationFrameId=requestAnimationFrame((()=>{const n=i.positionAfterAdjust-r.scrollPosition;let o="";n>0&&(t-=n,i.syntheticPosition=t,o=` (-${n})`),i.syntheticFulfill=!0,r.scrollPosition=t,e.logger.stat("after scroll adjustment"+o),s()}))}}class rt extends(Re(ee.preClip)){static run(e){rt.prepareClip(e),e.workflow.call({process:rt.process,status:se.next,payload:{doClip:e.state.clip.doClip}})}static prepareClip(e){const{state:{fetch:t,clip:s}}=e;if(rt.shouldNotClip(e))return;const i=t.first.indexBuffer,r=t.last.indexBuffer;e.logger.log((()=>`looking for ${t.direction?"anti-"+t.direction+" ":""}items that are out of [${i}..${r}] range`)),rt.isBackward(e,i)&&rt.prepareClipByDirection(e,I.backward,i),rt.isForward(e,r)&&rt.prepareClipByDirection(e,I.forward,r),s.doClip||e.logger.log("skipping clip [no items to clip]")}static shouldNotClip(e){const{settings:t,buffer:s,state:i}=e;return t.infinite&&!i.clip.force?(e.logger.log("skipping clip [infinite mode]"),!0):s.size?!!i.cycle.isInitial&&(e.logger.log("skipping clip [initial cycle]"),!0):(e.logger.log("skipping clip [empty buffer]"),!0)}static isBackward(e,t){const{buffer:s,state:{clip:i,fetch:r}}=e;return i.force?i.forceBackward:r.direction!==I.backward&&t-1>=s.absMinIndex}static isForward(e,t){const{buffer:s,state:{clip:i,fetch:r}}=e;return i.force?i.forceForward:r.direction!==I.forward&&t+1<=s.absMaxIndex}static prepareClipByDirection(e,t,s){const i=t===I.forward;e.buffer.items.forEach((r=>{(!i&&r.$index<s||i&&r.$index>s)&&(r.toRemove=!0,r.removeDirection=t,e.state.clip.doClip=!0)}))}}class nt extends(Re(ee.clip)){static run(e){const{workflow:t}=e;nt.doClip(e),t.call({process:nt.process,status:se.next})}static doClip(e){const{buffer:t,viewport:{paddings:s},state:{clip:i},logger:r}=e,n={[I.backward]:0,[I.forward]:0};r.stat(`before clip (${++i.callCount})`);const o=t.items.filter((e=>!!e.toRemove&&(e.hide(),n[e.removeDirection]+=e.size,!0)));o.length&&(n[I.backward]&&(s.byDirection(I.backward).size+=n[I.backward]),n[I.forward]&&(s.byDirection(I.forward).size+=n[I.forward]),e.settings.onBeforeClip&&e.settings.onBeforeClip(o.map((e=>e.get())))),t.clip(),r.log((()=>{const e=o.map((({$index:e})=>e));return e.length?[`clipped ${e.length} item(s) from Buffer`+(n.backward?`, +${n.backward} fwd px`:"")+(n.forward?`, +${n.forward} bwd px`:"")+`, range: [${e[0]}..${e[e.length-1]}]`]:"clipped 0 items from Buffer"})),r.stat("after clip")}}const ot=({call:e})=>!!e.interrupted;class at extends(Re(ee.end)){static run(e,{error:t}={}){const{workflow:s,state:{cycle:{interrupter:i}}}=e;if(t||i||at.calculateParams(e,s),ot(s))return void s.call({process:at.process,status:se.done});const r=at.finalizeInnerLoop(e,t);s.call({process:at.process,status:r?se.next:se.done,payload:Object.assign({},i?{process:i}:{})})}static calculateParams(e,t){const{adapter:s,viewport:i,buffer:{items:r}}=e;if(s.wanted.firstVisible){const{item:e}=i.getEdgeVisibleItem(r,I.backward);e&&e.element===s.firstVisible.element||(s.firstVisible=e?e.get():d)}if(s.wanted.lastVisible&&!ot(t)){const{item:e}=i.getEdgeVisibleItem(r,I.forward);e&&e.element===s.lastVisible.element||(s.lastVisible=e?e.get():d)}}static finalizeInnerLoop(e,t){const{state:s,state:{cycle:i,clip:r,fetch:n}}=e,o=!!i.interrupter||!t&&at.getNext(e);return i.innerLoop.isInitial=!1,n.stopSimulate(),r.reset(!0),s.endInnerLoop(),o}static getNext(e){const{state:{fetch:t,render:s}}=e;return!(!t.simulate||!t.isCheck||s.noSize)||(!(!t.simulate||!t.doRemove)||!(t.simulate||!(t.hasNewItems&&!s.noSize||t.hasAnotherPack)))}}class lt{constructor(e,t,s){this.logs=[],this.logAdapterMethod=(e,t,s)=>{if(!this.debug)return;const i=(void 0===t?[]:Array.isArray(t)?t:[t]).map((e=>"function"==typeof e?"func":"object"==typeof e&&e?Array.isArray(e)?`[of ${e.length}]`:"{ "+Object.keys(e).join(", ")+" }":e)).join(", ");this.log(`adapter: ${e}(${i||""})${s||""}`)};const{settings:i}=e;this.debug=i.debug,this.immediateLog=i.immediateLog,this.logTime=i.logTime,this.getTime=()=>e.state&&` // time: ${e.state.time}`,this.getStat=()=>{const{buffer:t,viewport:s}=e,i=t.getFirstVisibleItem(),r=t.getLastVisibleItem();return"pos: "+s.scrollPosition+", size: "+s.getScrollableSize()+", bwd_p: "+s.paddings.backward.size+", fwd_p: "+s.paddings.forward.size+", default: "+(t.defaultSize||"no")+", items: "+t.getVisibleItemsCount()+", range: "+(i&&r?`[${i.$index}..${r.$index}]`:"no")},this.getFetchRange=()=>{const{first:{index:t},last:{index:s}}=e.state.fetch;return Number.isNaN(t)||Number.isNaN(s)?"no":`[${t}..${s}]`},this.getLoopId=()=>e.state.cycle.loopId,this.getLoopIdNext=()=>e.state.cycle.loopIdNext,this.getWorkflowCycleData=()=>`${i.instanceIndex}-${e.state.cycle.count}`,this.getScrollPosition=t=>e.routines.getScrollPosition(t),this.log((()=>`vscroll Workflow has been started, core: ${t.core.name} v${t.core.version}, consumer: ${t.consumer.name} v${t.consumer.version}, workflow instance: ${i.instanceIndex}, adapter `+(s?`instance: ${s.id}`:"is not instantiated")))}object(e,t,s){this.log((()=>[e,s?JSON.stringify(t,((e,t)=>Number.isNaN(t)?"NaN":t===1/0?"Infinity":t===-1/0?"-Infinity":t instanceof Element?"HTMLElement":t instanceof HTMLDocument?"HTMLDocument":"function"==typeof t?"Function":t)).replace(/"/g,"").replace(/(\{|:|,)/g,"$1 ").replace(/(\})/g," $1"):t]))}stat(e){if(this.debug){const t=["color: #888; border: dashed #888 0; border-bottom-width: 0px","color: #000; border-width: 0"];this.log((()=>["%cstat"+(e?` ${e}`:"")+",%c "+this.getStat(),...t]))}}fetch(e){if(this.debug){const t="fetch interval"+(e?` ${e}`:""),s=["color: #888","color: #000"];this.log((()=>[`%c${t}: %c${this.getFetchRange()}`,...s]))}}prepareForLog(e){return e instanceof Event&&e.target?this.getScrollPosition(e.target):e}logProcess(e){if(!this.debug)return;const{process:t,status:s,payload:i}=e,r=[];if(t===ee.init&&s===se.next)r.push(`%c---=== loop ${this.getLoopIdNext()} start`);else if(t===ee.end){r.push(`%c---=== loop ${this.getLoopId()} done`);const e=i&&i.process;s===se.next&&e!==te.reset&&e!==te.reload&&(r[0]+=`, loop ${this.getLoopIdNext()} start`)}r.length&&this.log((()=>[...r,"color: #006600;"]))}logCycle(e=!0){const t=this.getWorkflowCycleData(),s=`color: #0000aa; border: solid #555 1px; border-width: ${e?"1px 0 0 1px":"0 0 1px 1px"}; margin-left: -2px`;this.log((()=>[`%c   ~~~ WF Cycle ${t} ${e?"STARTED":"FINALIZED"} ~~~  `,s]))}logError(e){if(this.debug){const t=["color: #a00;","color: #000"];this.log((()=>["error:%c"+(e?` ${e}`:"")+`%c (loop ${this.getLoopIdNext()})`,...t]))}}log(...e){if(this.debug){if("function"==typeof e[0]&&(e=e[0](),Array.isArray(e)||(e=[e])),e.every((e=>void 0===e)))return;this.logTime&&(e=[...e,this.getTime()]),e=e.map((e=>this.prepareForLog(e))),this.immediateLog?console.log.apply(this,e):this.logs.push(e)}}logForce(...e){this.debug&&(!this.immediateLog&&this.logs.length&&(this.logs.forEach((e=>console.log.apply(this,e))),this.logs=[]),e.length&&console.log.apply(this,e))}}class ct{constructor(e){this.horizontal=e.horizontal,this.window=e.windowViewport}checkElement(e){if(!e)throw new Error("HTML element is not defined")}getScrollPosition(e){return this.window?window.pageYOffset:(this.checkElement(e),e[this.horizontal?"scrollLeft":"scrollTop"])}setScrollPosition(e,t){t=Math.max(0,t),this.window?this.horizontal?window.scrollTo(t,window.scrollY):window.scrollTo(window.scrollX,t):(this.checkElement(e),e[this.horizontal?"scrollLeft":"scrollTop"]=t)}getParams(e,t){return this.checkElement(e),this.window&&t?{height:e.clientHeight,width:e.clientWidth,top:e.clientTop,bottom:e.clientTop+e.clientHeight,left:e.clientLeft,right:e.clientLeft+e.clientWidth}:e.getBoundingClientRect()}getSize(e,t){return this.getParams(e,t)[this.horizontal?"width":"height"]}getSizeStyle(e){this.checkElement(e);const t=e.style[this.horizontal?"width":"height"];return parseFloat(t)||0}setSizeStyle(e,t){this.checkElement(e),t=Math.max(0,Math.round(t)),e.style[this.horizontal?"width":"height"]=`${t}px`}getEdge(e,t,s){return this.getParams(e,s)[t===I.forward?this.horizontal?"right":"bottom":this.horizontal?"left":"top"]}getEdge2(e,t,s,i){return e.offsetTop-(s?s.scrollTop:0)+(t===(i?I.backward:I.forward)?this.getSize(e):0)}hideElement(e){this.checkElement(e),e.style.display="none"}getOffset(e){return this.checkElement(e),(this.horizontal?e.offsetLeft:e.offsetTop)||0}scrollTo(e,t){this.checkElement(e),e.scrollIntoView(t)}}class dt{constructor(e,t,s){this.element=e.querySelector(`[data-padding-${t}]`),this.direction=t,this.routines=s}reset(e){this.size=e||0}get size(){return this.routines.getSizeStyle(this.element)}set size(e){this.routines.setSizeStyle(this.element,e)}}class ht{constructor(e,t,s){this.settings=s,this.forward=new dt(e,I.forward,t),this.backward=new dt(e,I.backward,t)}byDirection(e,t){return e===I.backward?t?this.forward:this.backward:t?this.backward:this.forward}reset(e,t,s){const i=this.getPositiveSize(t,e,s),r=this.getNegativeSize(t);if(this.settings.inverse){this.forward.reset(r),this.backward.reset(i);const t=e-this.backward.size-s;t>0&&(this.backward.size+=t,this.forward.size-=t)}else{this.forward.reset(i),this.backward.reset(r);const t=e-this.forward.size-s;t>0&&(this.backward.size-=t,this.forward.size+=t)}}getPositiveSize(e,t,s){const{settings:i}=this;let r=t;return isFinite(i.maxIndex)&&(r=(i.maxIndex-e+1)*i.itemSize),s&&(r=Math.max(r-s,0)),r}getNegativeSize(e){const{settings:t}=this;let s=0;return isFinite(t.minIndex)&&(s=(e-t.minIndex)*t.itemSize),s}}class ut{constructor(e,t,s,i,r){this.element=e,this.settings=t,this.routines=s,this.state=i,this.logger=r,this.disabled=!1,t.windowViewport?(this.hostElement=document.documentElement,this.scrollEventReceiver=window):(this.hostElement=t.viewport||this.element.parentElement,this.scrollEventReceiver=this.hostElement),this.paddings=new ht(this.element,this.routines,t),t.windowViewport&&"scrollRestoration"in history&&(history.scrollRestoration="manual"),t.dismissOverflowAnchor&&(this.hostElement.style.overflowAnchor="none")}reset(e){this.setOffset(),this.paddings.reset(this.getSize(),e,this.offset),this.scrollPosition=this.paddings.backward.size||0,this.state.scrollState.reset()}setPosition(e){if(this.scrollPosition===e)return this.logger.log((()=>["setting scroll position at",e,"[cancelled]"])),e;this.routines.setScrollPosition(this.hostElement,e);const t=this.scrollPosition;return this.logger.log((()=>["setting scroll position at",t,...t!==e?[`(${e})`]:[]])),t}get scrollPosition(){return this.routines.getScrollPosition(this.hostElement)}set scrollPosition(e){this.setPosition(e)}disableScrollForOneLoop(){if(this.disabled)return;const{style:e}=this.hostElement;if("hidden"===e.overflowY)return;this.disabled=!0;const t=e.overflowY;setTimeout((()=>{this.disabled=!1,e.overflowY=t})),e.overflowY="hidden"}getSize(){return this.routines.getSize(this.hostElement,!0)}getScrollableSize(){return this.routines.getSize(this.element)}getBufferPadding(){return this.getSize()*this.settings.padding}getEdge(e){return this.routines.getEdge(this.hostElement,e,!0)}setOffset(){this.offset=this.routines.getOffset(this.element),this.settings.windowViewport||(this.offset-=this.routines.getOffset(this.hostElement))}getEdgeVisibleItem(e,t){const s=t===I.backward,i=s?I.forward:I.backward,r=this.getEdge(t);let n,o=0;for(let t=s?0:e.length-1;s?t<=e.length-1:t>=0;t+=s?1:-1){if(o=this.routines.getEdge(e[t].element,i)-r,s&&o>0||!s&&o<0){n=e[t];break}}return{item:n,index:n?n.$index:NaN,diff:o}}}class ft{constructor(){this.reset()}reset(){this.newItems=[],this.oldItems=[],this.removed=[]}}class pt{constructor(e,t){this.itemSize=e,this.sizeStrategy=t,this.sizeMap=new Map,this.recalculation=new ft}reset(e){e&&(this.constantSize=this.itemSize,this.frequentSize=this.itemSize,this.averageSize=this.itemSize,this.averageSizeFloat=this.itemSize,this.sizeMap.clear()),this.recalculation.reset()}get(){switch(this.sizeStrategy){case w.Average:return this.averageSize;case w.Frequent:return this.frequentSize;default:return this.constantSize}}recalculateAverageSize(e){const{oldItems:t,newItems:s,removed:i}=this.recalculation;if(t.length){const i=t.reduce(((e,t)=>e+t.size),0),r=t.reduce(((e,t)=>e+t.newSize),0),n=this.averageSizeFloat||0;this.averageSizeFloat=n-(i-r)/(e-s.length)}if(s.length){const t=s.reduce(((e,t)=>e+t.size),0),i=this.averageSizeFloat||0;this.averageSizeFloat=((e-s.length)*i+t)/e}if(i.length){const t=i.reduce(((e,t)=>e+t.size),0),s=this.averageSizeFloat||0;this.averageSizeFloat=((e+i.length)*s-t)/e}this.averageSize=Math.round(this.averageSizeFloat)}recalculateFrequentSize(){const{oldItems:e,newItems:t,removed:s}=this.recalculation,i=this.sizeMap.get(this.frequentSize);t.length&&t.forEach((({size:e})=>this.sizeMap.set(e,(this.sizeMap.get(e)||0)+1))),e.length&&(e.forEach((({size:e})=>this.sizeMap.set(e,Math.max((this.sizeMap.get(e)||0)-1,0)))),e.forEach((({newSize:e})=>this.sizeMap.set(e,(this.sizeMap.get(e)||0)+1)))),s.length&&s.forEach((({size:e})=>this.sizeMap.set(e,Math.max((this.sizeMap.get(e)||0)-1,0))));const r=[...this.sizeMap.entries()].sort(((e,t)=>t[1]-e[1])),n=r[0][1],o=r.filter((e=>e[1]===n));o.length>1&&o.find((e=>e[0]===i))||(this.frequentSize=r[0][0])}recalculate(e){if(this.sizeStrategy===w.Constant)return!1;const{oldItems:t,newItems:s,removed:i}=this.recalculation;if(!t.length&&!s.length&&!i.length)return!1;const r=this.get();return this.sizeStrategy===w.Average?this.recalculateAverageSize(e):this.recalculateFrequentSize(),this.recalculation.reset(),this.get()!==r}setExisted(e,t){this.sizeStrategy!==w.Constant&&this.recalculation.oldItems.push({size:e.size,newSize:t.size})}setNew(e){this.sizeStrategy!==w.Constant?this.recalculation.newItems.push({size:e.size}):this.constantSize||(this.constantSize=e.size)}setRemoved(e){this.sizeStrategy!==w.Constant&&this.recalculation.removed.push({size:e.size})}}class gt{constructor(e,t){this.$index=e.$index,this.nodeId=e.nodeId,this.data=t?e.data:null,this.size=e.size}changeIndex(e){this.$index=e,this.nodeId=String(e)}}class mt{constructor({itemSize:e,cacheData:t,cacheOnReload:s,sizeStrategy:i},r){this.itemSize=e,this.saveData=t,this.cacheOnReload=s,this.sizeStrategy=i,this.logger=r,this.items=new Map,this.defaultSize=new pt(e,i),this.reset(!0)}reset(e){(e=e||!this.cacheOnReload)&&(this.minIndex=1/0,this.maxIndex=-1/0,this.items.clear()),this.defaultSize.reset(e)}get size(){return this.items.size}get(e){return this.items.get(e)}getItemSize(e){const t=this.get(e);return t?t.size:0}getDefaultSize(){return this.defaultSize.get()}recalculateDefaultSize(){return!!this.defaultSize.recalculate(this.size)&&(this.logger.log((()=>`default size has been updated: ${this.defaultSize.get()}`)),!0)}add(e){let t=this.get(e.$index);return t?(this.saveData&&(t.data=e.data),t.size!==e.size&&(void 0!==t.size?this.defaultSize.setExisted(t,e):this.defaultSize.setNew(e),t.size=e.size)):(t=new gt(e,this.saveData),this.items.set(e.$index,t),this.defaultSize.setNew(t)),e.$index<this.minIndex&&(this.minIndex=e.$index),e.$index>this.maxIndex&&(this.maxIndex=e.$index),t}removeItems(e,t){const s=new Map;let i=1/0,r=-1/0;this.items.forEach((n=>{if(e.some((e=>e===n.$index)))return void(void 0!==n.size&&this.defaultSize.setRemoved(n));const o=t?e.reduce(((e,t)=>e+(n.$index<t?1:0)),0):e.reduce(((e,t)=>e-(n.$index>t?1:0)),0);n.changeIndex(n.$index+o),s.set(n.$index,n),i=n.$index<i?n.$index:i,r=n.$index>r?n.$index:r})),this.items=s,this.minIndex=i,this.maxIndex=r}updateSubset(e,t,s){if(!this.size||!e.length)return;const i=e[0],r=e[e.length-1];let n,o,a;if(t.length){const e=t[0].$index,s=t[t.length-1].$index;n=e-i,o=s-r}else n=s?r-i+1:0,o=s?0:i-r-1;const l=new Map;this.items.forEach((e=>e.$index<i?(e.changeIndex(e.$index+n),void l.set(e.$index,e)):e.$index>r?(e.changeIndex(e.$index+o),void l.set(e.$index,e)):void 0)),t.forEach((e=>l.set(e.$index,new gt(e,this.saveData)))),e.forEach((e=>{!t.some((({$index:t})=>e===t))&&(a=this.get(e))&&this.defaultSize.setRemoved(a)})),this.minIndex+=n,this.maxIndex+=o,this.items=l}}class xt{constructor(t,s,i){this._items=[],this.logger=i,this.changeItems=s,this.bof=new e(!1),this.eof=new e(!1),this.cache=new mt(t,i),this.startIndexUser=t.startIndex,this.minIndexUser=t.minIndex,this.maxIndexUser=t.maxIndex,this.reset(!0)}dispose(){this.bof.dispose(),this.eof.dispose(),this._items.forEach((e=>e.dispose())),this._items=[]}reset(e,t){this.items.forEach((e=>e.hide())),this.pristine=!0,this.items=[],this.cache.reset(e),this.absMinIndex=this.minIndexUser,this.absMaxIndex=this.maxIndexUser,this.setCurrentStartIndex(t),this.bof.set(!1),this.eof.set(!1),this.pristine=!1}setCurrentStartIndex(e){const t=this.minIndexUser,s=this.maxIndexUser,i=this.startIndexUser;let r=Number(e);Number.isNaN(r)&&(this.logger.log((()=>`fallback startIndex to settings.startIndex (${i})`)),r=i),r<t&&(this.logger.log((()=>`setting startIndex to settings.minIndex (${t}) because ${r} < ${t}`)),r=t),r>s&&(this.logger.log((()=>`setting startIndex to settings.maxIndex (${s}) because ${r} > ${s}`)),r=s),this.startIndex=r}set items(e){this._items=e,this.changeItems(e),this.pristine||(this.checkBOF(),this.checkEOF())}get items(){return this._items}set absMinIndex(e){this._absMinIndex!==e&&(this._absMinIndex=Number.isFinite(this._absMaxIndex)&&e>this._absMaxIndex?this._absMaxIndex:e),this.pristine||this.checkBOF()}get absMinIndex(){return this._absMinIndex}set absMaxIndex(e){this._absMaxIndex!==e&&(this._absMaxIndex=Number.isFinite(this._absMinIndex)&&e<this._absMinIndex?this._absMinIndex:e),this.pristine||this.checkEOF()}get absMaxIndex(){return this._absMaxIndex}checkBOF(){const e=this.items.length?this.items[0].$index===this.absMinIndex:isFinite(this.absMinIndex);this.bof.set(e)}checkEOF(){const e=this.items.length?this.items[this.items.length-1].$index===this.absMaxIndex:isFinite(this.absMaxIndex);this.eof.set(e)}get size(){return this._items.length}get cacheSize(){return this.cache.size}get defaultSize(){return this.cache.getDefaultSize()}get minIndex(){return isFinite(this.cache.minIndex)?this.cache.minIndex:this.startIndex}get maxIndex(){return isFinite(this.cache.maxIndex)?this.cache.maxIndex:this.startIndex}get firstIndex(){return this.items.length?this.items[0].$index:NaN}get lastIndex(){return this.items.length?this.items[this.items.length-1].$index:NaN}get finiteAbsMinIndex(){return isFinite(this.absMinIndex)?this.absMinIndex:this.minIndex}get finiteAbsMaxIndex(){return isFinite(this.absMaxIndex)?this.absMaxIndex:this.maxIndex}get(e){return this.items.find((t=>t.$index===e))}setItems(e){if(this.items.length)if(this.items[0].$index>e[e.length-1].$index)this.items=[...e,...this.items];else{if(!(e[0].$index>this.items[this.items.length-1].$index))return!1;this.items=[...this.items,...e]}else this.items=[...e];return!0}clip(){this.items=this.items.filter((({toRemove:e})=>!e))}append(e){this.items=[...this.items,...e]}prepend(e){this.items=[...e,...this.items]}shiftExtremum(e,t){t?(this.absMinIndex-=e,this.startIndex-=e):this.absMaxIndex+=e,this.startIndex>this.absMaxIndex?this.startIndex=this.absMaxIndex:this.startIndex<this.absMinIndex&&(this.startIndex=this.absMinIndex)}removeItems(e,t,s=!1){const i=[],r=s?e:[],n=this.items.length;let o=!1;for(let a=t?n-1:0;t?a>=0:a<n;t?a--:a++){const n=this.items[a];if(!s&&e.indexOf(n.$index)>=0){r.push(n.$index);continue}const l=r.reduce(((e,s)=>e+(t?n.$index<s?1:0:n.$index>s?-1:0)),0);o=o||!!l,n.updateIndex(n.$index+l),s||(t?i.unshift(n):i.push(n))}this.shiftExtremum(-r.length,t),s?o&&(this.items=[...this.items]):this.items=i,this.cache.removeItems(r,t)}updateItems(e,t,s,i){if(!this.size||Number.isNaN(this.firstIndex))return NaN;let r=s,n=i?this.lastIndex:this.firstIndex;const o=[],a=i?-1:1,l=this.items.map((({$index:e})=>e));return(i?this.items.reverse():this.items).forEach((l=>{const c=e(l);if(!c||Array.isArray(c)&&!c.length)return l.toRemove=!0,r+=l.$index>=s?i?1:0:i?0:-1,void this.shiftExtremum(-1,i);if(!Array.isArray(c))return l.updateIndex(n),o.push(l),void(n+=a);l.$index<s?r+=i?0:c.length-1:l.$index>s&&(r+=i?1-c.length:0);let d=!0;const h=[];(i?[...c].reverse():c).forEach(((e,i)=>{let o;l.data===e?(s===l.$index&&(r=n+i*a),l.updateIndex(n+i*a),o=l,d=!1):(o=t(n+i*a,e),o.toInsert=!0),h.push(o)})),l.toRemove=d,o.push(...h),n+=a*c.length,c.length>1&&this.shiftExtremum(c.length-1,i)})),this.items=i?o.reverse():o,this.cache.updateSubset(l,this.items,i),this.finiteAbsMinIndex===this.finiteAbsMaxIndex?r=NaN:r>this.finiteAbsMaxIndex?r=this.finiteAbsMaxIndex:r<this.finiteAbsMinIndex&&(r=this.finiteAbsMinIndex),r}cacheItem(e){this.cache.add(e)}getFirstVisibleItemIndex(){const e=this.items.length;for(let t=0;t<e;t++)if(!this.items[t].invisible)return t;return-1}getLastVisibleItemIndex(){for(let e=this.items.length-1;e>=0;e--)if(!this.items[e].invisible)return e;return-1}getFirstVisibleItem(){const e=this.getFirstVisibleItemIndex();if(e>=0)return this.items[e]}getLastVisibleItem(){const e=this.getLastVisibleItemIndex();if(e>=0)return this.items[e]}getEdgeVisibleItem(e,t){return e===(t?I.backward:I.forward)?this.getLastVisibleItem():this.getFirstVisibleItem()}getVisibleItemsCount(){return this.items.reduce(((e,t)=>e+(t.invisible?0:1)),0)}getSizeByIndex(e){const t=this.cache.get(e);return t?t.size:this.defaultSize}checkDefaultSize(){return this.cache.recalculateDefaultSize()}getIndexToAppend(e){return(e?this.absMaxIndex:this.size?this.items[this.size-1].$index:this.maxIndex)+(this.size?1:0)}getIndexToPrepend(e){return(e?this.absMinIndex:this.size?this.items[0].$index:this.minIndex)-(this.size?1:0)}getIndexToAdd(e,t){return t?this.getIndexToPrepend(e):this.getIndexToAppend(e)}}class bt{constructor(t){this.total=t,this.isInitial=!1,this.busy=new e(!1)}get first(){return 0===this.count}done(){this.count++,this.total++,this.busy.set(!1)}start(){this.busy.set(!0)}dispose(){this.busy.dispose()}}class It{constructor(t,s){const i=s?s.count:1,r=s?s.innerLoop.count:0;this.instanceIndex=t,this.innerLoop=new bt(r),this.interrupter=null,this.busy=new e(!1),this.done(i)}get loopId(){return`${this.instanceIndex}-${this.count}-${this.innerLoop.total}`}get loopIdNext(){return`${this.instanceIndex}-${this.count}-${this.innerLoop.total+1}`}done(e){this.count=e,this.isInitial=!1,this.busy.set(!1)}start(e,t){this.isInitial=e,this.initiator=t,this.innerLoop.isInitial=e,this.innerLoop.count=0,this.interrupter=null,this.busy.set(!0)}dispose(e){e&&this.busy.dispose(),this.innerLoop.dispose()}}class wt{constructor(){this.reset()}reset(){this.startDelta=0,this.before=0}}class vt{constructor(){this.reset()}reset(){this.index=NaN,this.indexBuffer=NaN,this.position=NaN}}class yt{constructor(){this.reset()}reset(){this.index=NaN,this.indexBuffer=NaN}}class St{constructor(){this.callCount=0,this.positions=new wt,this.first=new vt,this.last=new yt,this.reset()}reset(){this._newItemsData=null,this.items=[],this.positions.reset(),this.first.reset(),this.last.reset(),this.hasAnotherPack=!1,this.firstVisibleIndex=NaN,this.firstVisibleItemDelta=NaN,this.negativeSize=0,this.direction=null,this.cancel=null,this.simulate=!1,this.isPrepend=!1,this.isCheck=!1,this.doRemove=!1}get newItemsData(){return this._newItemsData}set newItemsData(e){this._newItemsData=e,e&&e.length&&this.callCount++}get shouldFetch(){return!!this.count}get hasNewItems(){return!(!this._newItemsData||!this._newItemsData.length)}get index(){return this.first.index}get count(){return isNaN(this.first.index)||isNaN(this.last.index)?0:this.last.index-this.first.index+1}startSimulate(e){this.simulate=!0,this._newItemsData=e.map((e=>e.data)),this.items=e,this.hasAnotherPack=!1,this.negativeSize=0}stopSimulate(){this.simulate=!1,this.isPrepend=!1,this.isCheck=!1,this.doRemove=!1}append(e){this.startSimulate(e),this.last.index=e[e.length-1].$index,this.first.index=e[0].$index,this.direction=I.forward}prepend(e){this.startSimulate(e),this.last.index=e[0].$index,this.first.index=e[e.length-1].$index,this.direction=I.backward,this.isPrepend=!0}check(e){this.startSimulate(e),this.last.index=e[0].$index,this.first.index=e[e.length-1].$index,this.isCheck=!0}remove(){this.startSimulate([]),this.doRemove=!0}update(e,t,s,i){this.startSimulate(s),this.firstVisibleIndex=e,this.firstVisibleItemDelta=t,this.doRemove=i.length>0}}class zt{constructor(){this.callCount=0,this.reset()}get force(){return this.forceForward||this.forceBackward}reset(e){this.doClip=!1,e||(this.forceForward=!1,this.forceBackward=!1)}}class kt{constructor(){this.reset()}get noSize(){return this.sizeBefore===this.sizeAfter}reset(){this.sizeBefore=0,this.sizeAfter=0,this.positionBefore=0,this.renderTimer=null}}class $t{constructor(){this.reset()}reset(){this.previous=null,this.current=null,this.syntheticPosition=null,this.syntheticFulfill=!1,this.positionBeforeAsync=null,this.positionBeforeAdjust=null,this.positionAfterAdjust=null,this.cleanupTimers()}cleanupTimers(){this.scrollTimer&&(clearTimeout(this.scrollTimer),this.scrollTimer=null),this.animationFrameId&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=0)}hasPositionChanged(e){const t=this.positionBeforeAdjust,s=this.positionAfterAdjust;return null===t||t!==e||null===s||s!==e}}class Nt{constructor(e,t,s){this.packageInfo=e,this.settings=t,this.initTime=Number(new Date),this.cycle=new It(this.settings.instanceIndex,s?s.cycle:void 0),this.fetch=new St,this.clip=new zt,this.render=new kt,this.scrollState=new $t}get time(){return Number(new Date)-this.initTime}endInnerLoop(){const{fetch:e,render:t,cycle:s}=this;e.cancel&&(e.cancel(),e.cancel=null),t.renderTimer&&(clearTimeout(t.renderTimer),t.renderTimer=null),s.innerLoop.done()}startInnerLoop(){const{cycle:e,scrollState:t,fetch:s,render:i,clip:r}=this;return e.innerLoop.start(),t.positionBeforeAsync=null,s.simulate||s.reset(),r.reset(r.force),i.reset(),Object.assign({},e.innerLoop.first?{process:e.initiator,doRender:s.simulate&&s.items.length>0}:{})}dispose(){this.cycle.dispose(),this.endInnerLoop(),this.scrollState.cleanupTimers()}}const Et=h(),Mt=(e,t)=>"object"==typeof e&&null!==e&&Object.prototype.hasOwnProperty.call(e,t),Vt=(e,t,s)=>{let i=t;if(!Mt(t,"items")){const r=Array.isArray(t)?t:[t];i=e?{items:r,bof:s}:{items:r,eof:s}}return i};class Ot{constructor(e,i,r){this.source={},this.box={},this.demand={},this.wanted={},this.getWorkflow=i,this.logger=r,this.relax$=null,this.relaxRun=null,this.reloadCounter=0;const n=e&&u.get(e.id)||{},o=e?Et.map((t=>{let s=e[t.name];if(e.augmented){const e=n[t.name];e&&(s=e.default)}return Object.assign(Object.assign({},t),{value:s})})):h();Object.entries(n).forEach((([e,t])=>{const s=o.find((({name:t})=>t===e));s&&t&&(s.value=t.default)})),o.filter((({type:e,permanent:t})=>e===s.Scalar&&t)).forEach((({name:e,value:t})=>Object.defineProperty(this,e,{configurable:!0,get:()=>t}))),o.filter((e=>e.type===s.Reactive)).forEach((({name:e,value:t})=>{this.source[e]=t,Object.defineProperty(this,e,{configurable:!0,get:()=>{const t=Et.find((({wanted:t,reactive:s})=>t&&s===e));return t&&(this.wanted[t.name]=!0),this.source[e]}})})),o.filter((e=>e.type===s.Scalar&&!!e.reactive)).forEach((({name:e,value:t,reactive:s,wanted:i})=>{i&&(this.wanted[e]=!1),this.box[e]=t,Object.defineProperty(this,e,{configurable:!0,set:t=>{if(t!==this.box[e]){this.box[e]=t,this.source[s].set(t);const i=n[s];i&&i.emit(i.source,t)}},get:()=>(i&&(this.wanted[e]=!0),this.box[e])})})),o.filter((e=>e.type===s.Scalar&&e.onDemand)).forEach((({name:e,value:t})=>{this.demand[e]=t,Object.defineProperty(this,e,{configurable:!0,get:()=>this.demand[e]})})),e&&(o.forEach((({name:i,type:r,value:o,permanent:a})=>{let l=this[i];r===s.Function?l=l.bind(this):r===s.WorkflowRunner?l=this.getPromisifiedMethod(l,o):r===s.Reactive&&n[i]?l=e[i]:i===t.augmented&&(l=!0),Object.defineProperty(e,i,{configurable:!0,get:()=>a||r!==s.Scalar?l:this[i]})})),this.externalContext=e)}get workflow(){return this.getWorkflow()}get reloadCount(){return this.reloadCounter}get reloadId(){return this.id+"."+this.reloadCounter}getPromisifiedMethod(e,t){return(...s)=>this.relax$?new Promise((t=>{this.relax$&&this.relax$.once((e=>t(e))),e.apply(this,s)})):t.apply(this,s)}initialize(s,i,r,n){if(Object.defineProperty(this.demand,t.itemsCount,{get:()=>s.getVisibleItemsCount()}),Object.defineProperty(this.demand,t.bufferInfo,{get:()=>({firstIndex:s.firstIndex,lastIndex:s.lastIndex,minIndex:s.minIndex,maxIndex:s.maxIndex,absMinIndex:s.absMinIndex,absMaxIndex:s.absMaxIndex,defaultSize:s.defaultSize})}),this.bof=s.bof.get(),s.bof.on((e=>this.bof=e)),this.eof=s.eof.get(),s.eof.on((e=>this.eof=e)),Object.defineProperty(this.demand,t.packageInfo,{get:()=>i.packageInfo}),this.loopPending=i.cycle.innerLoop.busy.get(),i.cycle.innerLoop.busy.on((e=>this.loopPending=e)),this.isLoading=i.cycle.busy.get(),i.cycle.busy.on((e=>this.isLoading=e)),this.logger=r,n){this.relax$||(this.relax$=new e);const t=this.relax$;n.on((({status:e,payload:s})=>{let i=()=>{};e===se.start?i=this.isLoading$.on((e=>{e||(i(),t.set({success:!0,immediate:!1,details:null}))})):e!==se.done&&e!==se.error||(i(),t.set({success:e!==se.error,immediate:!0,details:e===se.error&&s?String(s.error):null}))}))}this.init=!0}dispose(){this.relax$&&this.relax$.dispose(),this.externalContext&&this.resetContext(),Object.getOwnPropertyNames(this).forEach((e=>{delete this[e]}))}resetContext(){const e=u.get(this.externalContext.id);Et.forEach((({type:t,permanent:i,name:r,value:n})=>{if(t===s.Reactive||i||Object.defineProperty(this.externalContext,r,{configurable:!0,get:()=>n}),t===s.Reactive&&e){const t=e[r];t&&(t.default.reset(),t.emit(t.source,t.default.get()))}}))}reset(e){this.reloadCounter++,this.logger.logAdapterMethod("reset",e,` of ${this.reloadId}`),this.workflow.call({process:te.reset,status:se.start,payload:{options:e}})}reload(e){this.reloadCounter++,this.logger.logAdapterMethod("reload",e,` of ${this.reloadId}`),this.workflow.call({process:te.reload,status:se.start,payload:{options:e}})}append(e,t){const s=Vt(!1,e,t);this.logger.logAdapterMethod("append",[s.items,s.eof]),this.workflow.call({process:te.append,status:se.start,payload:{options:s}})}prepend(e,t){const s=Vt(!0,e,t);this.logger.logAdapterMethod("prepend",[s.items,s.bof]),this.workflow.call({process:te.prepend,status:se.start,payload:{options:s}})}check(){this.logger.logAdapterMethod("check"),this.workflow.call({process:te.check,status:se.start})}remove(e){e=(e=>{Mt(e,"predicate")||Mt(e,"indexes")||(e={predicate:e});return e})(e),this.logger.logAdapterMethod("remove",e),this.workflow.call({process:te.remove,status:se.start,payload:{options:e}})}clip(e){this.logger.logAdapterMethod("clip",e),this.workflow.call({process:te.clip,status:se.start,payload:{options:e}})}insert(e){this.logger.logAdapterMethod("insert",e),this.workflow.call({process:te.insert,status:se.start,payload:{options:e}})}replace(e){this.logger.logAdapterMethod("replace",e),this.workflow.call({process:te.replace,status:se.start,payload:{options:e}})}update(e){this.logger.logAdapterMethod("update",e),this.workflow.call({process:te.update,status:se.start,payload:{options:e}})}fix(e){this.logger.logAdapterMethod("fix",e),this.workflow.call({process:te.fix,status:se.start,payload:{options:e}})}relaxUnchained(e,t){const s=()=>"function"==typeof e&&t===this.reloadId&&e();return this.isLoading||s(),new Promise((e=>{this.isLoading?this.isLoading$.once((()=>{s(),e(!1)})):e(!0)})).then((e=>{const s=t===this.reloadId;return this.logger.log((()=>s?void 0:`relax promise cancelled due to ${t} != ${this.reloadId}`)),{immediate:e,success:s,details:s?null:"Interrupted by reload or reset"}}))}relax(e){const t=this.reloadId;return this.logger.logAdapterMethod("relax",e,` of ${t}`),this.init?this.relaxRun=this.relaxRun?this.relaxRun.then((()=>this.relaxUnchained(e,t))):this.relaxUnchained(e,t).then((e=>(this.relaxRun=null,e))):Promise.resolve(o)}showLog(){this.logger.logAdapterMethod("showLog"),this.logger.logForce()}}const At="Invalid datasource:";let Tt=0;class Pt{constructor({datasource:e,consumer:t,element:s,workflow:i,scroller:r}){const{params:{get:n}}=R(e,D);if(!n.isValid)throw new Error(`Invalid datasource: ${n.errors[0]}`);const o=r?r.state.packageInfo:{consumer:t,core:f};s=r?r.viewport.element:s,i=r?r.workflow:i,this.workflow=i,this.settings=new Pe(e.settings,e.devSettings,++Tt),this.logger=new lt(this,o,e.adapter),this.routines=new ct(this.settings),this.state=new Nt(o,this.settings,r?r.state:void 0),this.buffer=new xt(this.settings,i.onDataChanged,this.logger),this.viewport=new ut(s,this.settings,this.routines,this.state,this.logger),this.logger.object("vscroll settings object",this.settings,!0),this.initDatasource(e,r)}initDatasource(e,t){if(t)return this.datasource=e,void(this.adapter=t.adapter);const s=e instanceof m,i=!s&&!this.settings.adapter;if(s)this.datasource=e;else{const t=x((()=>({mock:i})));this.datasource=new t(e),this.settings.adapter&&(e.adapter=this.datasource.adapter)}const r=i?null:this.datasource.adapter;this.adapter=new Ot(r,(()=>this.workflow),this.logger)}init(e){this.viewport.reset(this.buffer.startIndex),this.logger.stat("initialization"),this.adapter.initialize(this.buffer,this.state,this.logger,e)}dispose(e){e&&this.adapter.dispose(),this.buffer.dispose(),this.state.dispose()}finalize(){}}class Rt{constructor({element:t,datasource:s,consumer:i,run:r}){this.isInitialized=!1,this.initTimer=null,this.adapterRun$=new e,this.cyclesDone=0,this.interruptionCount=0,this.errors=[],this.disposeScrollEventHandler=()=>null,this.propagateChanges=r,this.stateMachineMethods={run:this.runProcess(),interrupt:this.interrupt.bind(this),done:this.done.bind(this),onError:this.onError.bind(this)},this.scroller=new Pt({element:t,datasource:s,consumer:i,workflow:this.getUpdater()}),this.scroller.settings.initializeDelay?this.initTimer=setTimeout((()=>{this.initTimer=null,this.init()}),this.scroller.settings.initializeDelay):this.init()}init(){this.scroller.init(this.adapterRun$),this.isInitialized=!0,this.callWorkflow({process:ee.init,status:se.start});const{scrollEventReceiver:e}=this.scroller.viewport,t=e=>this.callWorkflow({process:ee.scroll,status:se.start,payload:{event:e}});e.addEventListener("scroll",t),this.disposeScrollEventHandler=()=>e.removeEventListener("scroll",t)}changeItems(e){this.propagateChanges(e)}callWorkflow(e){if(!this.isInitialized)return;const{process:t,status:s}=e;t&&t.startsWith("adapter")&&s!==se.next&&this.adapterRun$.set(e),this.process(e)}getUpdater(){return{call:this.callWorkflow.bind(this),onDataChanged:this.changeItems.bind(this)}}process(e){const{status:t,process:s,payload:i}=e;this.scroller.settings.logProcessRun&&this.scroller.logger.log((()=>["%cfire%c","color: #cc7777;","color: #000000;",s,`"${t}"`,...void 0!==i?[i]:[]])),this.scroller.logger.logProcess(e),s===ee.end&&this.scroller.finalize(),(({input:{process:e,status:t,payload:s={}},methods:{run:i,interrupt:r,done:n,onError:o}})=>{if(t===se.error)return o(e,s),void(e.startsWith("adapter")||i(at)(s));const{options:a}=s;switch(e){case ee.init:t===se.start&&i(Le)(e),t===se.next&&i(Ze)();break;case ee.scroll:t===se.start&&i(De)(s),t===se.next&&i(Le)(e);break;case te.reset:case te.reload:t===se.start&&(e===te.reset?i(Be)(a):i(je)(a)),t===se.next&&(r(Object.assign({process:e},s)),s.finalize?i(at)():i(Le)(e));break;case te.append:case te.prepend:t===se.start&&i(Ue)({process:e,options:a}),t===se.next&&i(Le)(e);break;case te.check:t===se.start&&i(We)(),t===se.next&&i(Le)(e);break;case te.remove:t===se.start&&i(qe)(a),t===se.next&&i(Le)(e);break;case te.clip:t===se.start&&i(He)(a),t===se.next&&i(Le)(e);break;case te.insert:t===se.start&&i(Xe)(a),t===se.next&&i(Le)(e);break;case te.replace:t===se.start&&i(Ye)(a),t===se.next&&i(Le)(e);break;case te.update:t===se.start&&i(Ge)(a),t===se.next&&i(Le)(e);break;case te.fix:t===se.start&&i(Qe)(a),t===se.next&&i(Le)(e);break;case ee.start:switch(s.process){case te.append:case te.check:case te.insert:i(st)();break;case te.remove:i(it)();break;case te.replace:case te.update:s.doRender?i(st)():i(it)();break;default:i(Ke)()}break;case ee.preFetch:if(t===se.next)switch(s.process){case te.clip:i(rt)();break;default:i(et)()}t===se.done&&i(at)();break;case ee.fetch:i(tt)();break;case ee.postFetch:t===se.next&&i(st)(),t===se.done&&i(at)();break;case ee.render:if(t===se.next)switch(s.process){case te.append:case te.check:case te.insert:case te.replace:case te.update:i(it)();break;default:i(rt)()}t===se.done&&i(at)();break;case ee.preClip:s.doClip?i(nt)():i(it)();break;case ee.clip:i(it)();break;case ee.adjust:i(at)();break;case ee.end:if(t===se.next)switch(s.process){case te.reset:case te.reload:n(),i(Le)(s.process);break;default:i(Ze)()}t===se.done&&n()}})({input:e,methods:this.stateMachineMethods})}runProcess(){return({run:e,process:t,name:s})=>(...i)=>{this.scroller.settings.logProcessRun&&this.scroller.logger.log((()=>["%crun%c","color: #333399;","color: #000000;",t||s,...i])),e(this.scroller,...i)}}onError(e,t){const s=t&&String(t.error)||"",{time:i,cycle:r}=this.scroller.state;this.errors.push({process:e,message:s,time:i,loop:r.loopIdNext}),this.scroller.logger.logError(s)}interrupt({process:e,finalize:t,datasource:s}){if(t){const{workflow:t,logger:s}=this.scroller;t.call=e=>s.log("[skip wf call]"),t.call.interrupted=!0,this.scroller.workflow=this.getUpdater(),this.interruptionCount++,s.log((()=>`workflow had been interrupted by the ${e} process (${this.interruptionCount})`))}s&&this.scroller.adapter.relax((()=>{this.scroller.logger.log("new Scroller instantiation");const e=new Pt({datasource:s,scroller:this.scroller});this.scroller.dispose(),this.scroller=e,this.scroller.init()}))}done(){const{state:e,logger:t}=this.scroller;this.cyclesDone++,t.logCycle(!1),e.cycle.done(this.cyclesDone+1),this.finalize()}dispose(){this.initTimer&&clearTimeout(this.initTimer),this.disposeScrollEventHandler(),this.adapterRun$.dispose(),this.scroller.dispose(!0),Object.getOwnPropertyNames(this).forEach((e=>{delete this[e]}))}finalize(){}}export{t as AdapterPropName,I as Direction,d as EMPTY_ITEM,At as INVALID_DATASOURCE_PREFIX,w as SizeStrategy,Rt as Workflow,h as getDefaultAdapterProps,x as makeDatasource,f as packageInfo};
//# sourceMappingURL=vscroll.esm6.min.js.map
