{"version":3,"file":"vscroll.esm6.js","sources":["../../src/classes/reactive.ts","../../src/classes/adapter/props.ts","../../src/version.ts","../../src/classes/adapter/context.ts","../../src/classes/datasource.ts","../../src/inputs/common.ts","../../src/inputs/validation.ts","../../src/inputs/datasource.ts","../../src/inputs/settings.ts","../../src/processes/misc/enums.ts","../../src/inputs/adapter.ts","../../src/classes/settings.ts","../../src/processes/misc/base.ts","../../src/processes/init.ts","../../src/processes/scroll.ts","../../src/processes/adapter/reset.ts","../../src/processes/adapter/reload.ts","../../src/classes/item.ts","../../src/processes/adapter/append.ts","../../src/processes/adapter/check.ts","../../src/processes/adapter/remove.ts","../../src/processes/adapter/clip.ts","../../src/processes/adapter/update.ts","../../src/processes/adapter/insert.ts","../../src/processes/adapter/replace.ts","../../src/processes/adapter/fix.ts","../../src/processes/start.ts","../../src/processes/preFetch.ts","../../src/processes/fetch.ts","../../src/processes/postFetch.ts","../../src/processes/render.ts","../../src/processes/adjust.ts","../../src/processes/preClip.ts","../../src/processes/clip.ts","../../src/processes/end.ts","../../src/classes/logger.ts","../../src/classes/domRoutines.ts","../../src/classes/paddings.ts","../../src/classes/viewport.ts","../../src/classes/buffer/defaultSize.ts","../../src/classes/buffer/cache.ts","../../src/classes/buffer.ts","../../src/classes/state/cycle.ts","../../src/classes/state/fetch.ts","../../src/classes/state/clip.ts","../../src/classes/state/render.ts","../../src/classes/state/scroll.ts","../../src/classes/state.ts","../../src/classes/adapter.ts","../../src/scroller.ts","../../src/workflow-transducer.ts","../../src/workflow.ts"],"sourcesContent":["type On<T> = (value: T) => void;\ntype Off = () => void;\n\ninterface Subscription<T> {\n  emit: On<T>;\n  off: Off;\n}\n\ninterface Options {\n  emitOnSubscribe?: boolean; // if set, emit right on subscribe (like rxjs BehaviorSubject)\n  emitEqual?: boolean; // if set, emit when new value is equal to the old one\n}\n\nexport class Reactive<T> {\n\n  private initialValue: T;\n  private value: T;\n  private id: number;\n  private options: Options;\n  private subscriptions: Map<number, Subscription<T>>;\n\n  constructor(value?: T, options?: Options) {\n    this.id = 0;\n    if (value !== void 0) {\n      this.value = value;\n      this.initialValue = value;\n    }\n    this.options = options || {};\n    this.subscriptions = new Map();\n  }\n\n  set(value: T): void {\n    if (this.value === value && !this.options.emitEqual) {\n      return;\n    }\n    this.value = value;\n    for (const [, sub] of this.subscriptions) {\n      sub.emit(value);\n      if (this.value !== value) {\n        break;\n      }\n    }\n  }\n\n  get(): T {\n    return this.value;\n  }\n\n  on(func: On<T>): Off {\n    const id = this.id++;\n    const subscription: Subscription<T> = {\n      emit: func,\n      off: () => {\n        subscription.emit = () => null;\n        this.subscriptions.delete(id);\n      }\n    };\n    this.subscriptions.set(id, subscription);\n    if (this.options.emitOnSubscribe) {\n      subscription.emit(this.value);\n    }\n    return () => subscription.off();\n  }\n\n  once(func: On<T>): Off {\n    const off = this.on(v => {\n      off();\n      func(v);\n    });\n    return off;\n  }\n\n  reset(): void {\n    this.set(this.initialValue);\n  }\n\n  dispose(): void {\n    this.subscriptions.forEach(sub => sub.off());\n  }\n}\n","import { Reactive } from '../reactive';\nimport {\n  IAdapterProp, IBufferInfo, ItemAdapter, IPackages, AdapterMethodResult, IReactivePropsStore\n} from '../../interfaces/index';\n\nexport enum AdapterPropName {\n  id = 'id',\n  mock = 'mock',\n  augmented = 'augmented',\n  version = 'version',\n  init = 'init',\n  init$ = 'init$',\n  packageInfo = 'packageInfo',\n  itemsCount = 'itemsCount',\n  bufferInfo = 'bufferInfo',\n  isLoading = 'isLoading',\n  isLoading$ = 'isLoading$',\n  loopPending = 'loopPending',\n  loopPending$ = 'loopPending$',\n  firstVisible = 'firstVisible',\n  firstVisible$ = 'firstVisible$',\n  lastVisible = 'lastVisible',\n  lastVisible$ = 'lastVisible$',\n  bof = 'bof',\n  bof$ = 'bof$',\n  eof = 'eof',\n  eof$ = 'eof$',\n  reset = 'reset',\n  reload = 'reload',\n  append = 'append',\n  prepend = 'prepend',\n  check = 'check',\n  remove = 'remove',\n  clip = 'clip',\n  insert = 'insert',\n  replace = 'replace',\n  update = 'update',\n  fix = 'fix',\n  relax = 'relax',\n  showLog = 'showLog',\n}\n\nexport enum AdapterPropType {\n  Scalar,\n  Reactive,\n  WorkflowRunner,\n  Function,\n}\n\nconst Name = AdapterPropName;\nconst Type = AdapterPropType;\n\nconst noop = () => null;\n\nexport const methodPreResult: AdapterMethodResult = {\n  immediate: true,\n  success: true,\n  details: 'Adapter is not initialized'\n};\n\nconst noopWF = () => Promise.resolve(methodPreResult);\n\nconst emptyPackageInfo: IPackages = {\n  core: {\n    name: '',\n    version: ''\n  },\n  consumer: {\n    name: '',\n    version: ''\n  }\n};\n\nconst bufferInfoDefault: IBufferInfo = {\n  firstIndex: NaN,\n  lastIndex: NaN,\n  minIndex: NaN,\n  maxIndex: NaN,\n  absMinIndex: -Infinity,\n  absMaxIndex: +Infinity,\n  defaultSize: NaN,\n};\n\nexport const EMPTY_ITEM = {\n  data: {},\n  element: {}\n} as ItemAdapter;\n\nexport const getDefaultAdapterProps = (): IAdapterProp[] => [\n  {\n    type: Type.Scalar,\n    name: Name.id,\n    value: 0,\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.mock,\n    value: true,\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.augmented,\n    value: false,\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.version,\n    value: '',\n    permanent: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.init,\n    value: false,\n    reactive: Name.init$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.packageInfo,\n    value: emptyPackageInfo,\n    onDemand: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.itemsCount,\n    value: 0,\n    onDemand: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.bufferInfo,\n    value: bufferInfoDefault,\n    onDemand: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.isLoading,\n    value: false,\n    reactive: Name.isLoading$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.loopPending,\n    value: false,\n    reactive: Name.loopPending$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.firstVisible,\n    value: EMPTY_ITEM,\n    reactive: Name.firstVisible$,\n    wanted: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.lastVisible,\n    value: EMPTY_ITEM,\n    reactive: Name.lastVisible$,\n    wanted: true\n  },\n  {\n    type: Type.Scalar,\n    name: Name.bof,\n    value: false,\n    reactive: Name.bof$\n  },\n  {\n    type: Type.Scalar,\n    name: Name.eof,\n    value: false,\n    reactive: Name.eof$\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.reset,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.reload,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.append,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.prepend,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.check,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.remove,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.clip,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.insert,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.replace,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.update,\n    value: noopWF\n  },\n  {\n    type: Type.WorkflowRunner,\n    name: Name.fix,\n    value: noopWF\n  },\n  {\n    type: Type.Function,\n    name: Name.relax,\n    value: noop\n  },\n  {\n    type: Type.Function,\n    name: Name.showLog,\n    value: noop\n  },\n  {\n    type: Type.Reactive,\n    name: Name.init$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.isLoading$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.loopPending$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.firstVisible$,\n    value: new Reactive<ItemAdapter>(EMPTY_ITEM, { emitOnSubscribe: true })\n  },\n  {\n    type: Type.Reactive,\n    name: Name.lastVisible$,\n    value: new Reactive<ItemAdapter>(EMPTY_ITEM, { emitOnSubscribe: true })\n  },\n  {\n    type: Type.Reactive,\n    name: Name.bof$,\n    value: new Reactive<boolean>()\n  },\n  {\n    type: Type.Reactive,\n    name: Name.eof$,\n    value: new Reactive<boolean>()\n  }\n];\n\nexport const reactiveConfigStorage = new Map<number, IReactivePropsStore>();\n","export default {\n  name: 'vscroll',\n  version: '1.2.0'\n};\n","import { AdapterPropName, AdapterPropType, getDefaultAdapterProps, reactiveConfigStorage } from './props';\nimport core from '../../version';\nimport { Reactive } from '../reactive';\nimport { IReactivePropsStore, IAdapterConfig } from '../../interfaces/index';\n\nlet instanceCount = 0;\n\nexport class AdapterContext {\n\n  constructor(config: IAdapterConfig) {\n    const { mock, reactive } = config;\n    const id = ++instanceCount;\n    const conf = { configurable: true };\n    const reactivePropsStore: IReactivePropsStore = {};\n\n    // set up permanent props\n    Object.defineProperty(this, AdapterPropName.id, { get: () => id, ...conf });\n    Object.defineProperty(this, AdapterPropName.mock, { get: () => mock, ...conf });\n    Object.defineProperty(this, AdapterPropName.augmented, { get: () => false, ...conf });\n    Object.defineProperty(this, AdapterPropName.version, { get: () => core.version, ...conf });\n\n    // set up default props, they will be reassigned during the Adapter instantiation\n    getDefaultAdapterProps()\n      .filter(({ permanent }) => !permanent)\n      .forEach(({ name, value, type }) => {\n\n        // reactive props might be reconfigured by the vscroll consumer\n        if (reactive && type === AdapterPropType.Reactive) {\n          const react = reactive[name];\n          if (react) {\n            // here we have a configured reactive property that came from the outer config\n            // this prop must be exposed via Adapter, but at the same time we need to\n            // persist the original default value as it will be used by the Adapter internally\n            reactivePropsStore[name] = {\n              ...react,\n              default: value as Reactive<unknown> // persisting the default native Reactive prop\n            };\n            value = react.source; // exposing the configured prop instead of the default one\n          }\n        }\n\n        Object.defineProperty(this, name, {\n          get: () => value,\n          ...conf\n        });\n      });\n\n    if (reactive) { // save both configured and default reactive props in the store\n      reactiveConfigStorage.set(id, reactivePropsStore);\n    }\n  }\n}\n","import { AdapterContext } from './adapter/context';\r\nimport { reactiveConfigStorage } from './adapter/props';\r\nimport {\r\n  IDatasource,\r\n  IDatasourceConstructed,\r\n  DatasourceGet,\r\n  Settings,\r\n  DevSettings,\r\n  IAdapter,\r\n  IAdapterConfig,\r\n} from '../interfaces/index';\r\n\r\nexport class DatasourceGeneric<Data> implements IDatasourceConstructed<Data> {\r\n  get: DatasourceGet<Data>;\r\n  settings?: Settings<Data>;\r\n  devSettings?: DevSettings;\r\n  adapter: IAdapter<Data>;\r\n\r\n  constructor(datasource: IDatasource<Data>, config?: IAdapterConfig) {\r\n    this.get = datasource.get;\r\n    if (datasource.settings) {\r\n      this.settings = datasource.settings;\r\n    }\r\n    if (datasource.devSettings) {\r\n      this.devSettings = datasource.devSettings;\r\n    }\r\n    const adapterContext = new AdapterContext(config || { mock: false });\r\n    this.adapter = adapterContext as IAdapter<Data>;\r\n  }\r\n\r\n  dispose(): void { // todo: should it be published?\r\n    reactiveConfigStorage.delete(this.adapter.id);\r\n  }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport const makeDatasource = (getConfig?: () => IAdapterConfig) =>\r\n  class <Data = unknown> extends DatasourceGeneric<Data> {\r\n    constructor(datasource: IDatasource<Data>) {\r\n      const config = typeof getConfig === 'function' ? getConfig() : void 0;\r\n      super(datasource, config);\r\n    }\r\n  };\r\n\r\nexport const Datasource = makeDatasource();\r\n","export enum Direction {\n  forward = 'forward',\n  backward = 'backward'\n}\n\nexport enum SizeStrategy {\n  Average = 'average',\n  Constant = 'constant',\n  Frequent = 'frequent'\n}\n","import { IValidationContext } from '../interfaces/validation';\nimport {\n  IValidator,\n  ValidatedValue,\n  IValidatedData,\n  IValidatedCommonProps,\n  ICommonProps,\n  ICommonProp,\n} from '../interfaces/index';\n\nexport enum ValidatorType {\n  number = 'must be a number',\n  integer = 'must be an integer',\n  integerUnlimited = 'must be an integer or infinity',\n  moreOrEqual = 'must be a number greater than (or equal to) {arg1}',\n  itemList = 'must be an array of items {arg1}',\n  boolean = 'must be a boolean',\n  object = 'must be an object',\n  element = 'must be an html element',\n  function = 'must be a function',\n  funcOfxArguments = 'must have {arg1} argument(s)',\n  funcOfxAndMoreArguments = 'must have at least {arg1} argument(s)',\n  funcOfXToYArguments = 'must have {arg1} to {arg2} arguments',\n  oneOfCan = 'can be present as only one item of {arg1} list',\n  oneOfMust = 'must be present as only one item of {arg1} list',\n  or = 'must satisfy at least 1 validator from {arg1} list',\n  enum = 'must belong to {arg1} list',\n}\n\nconst getError = (msg: ValidatorType, args?: string[]) =>\n  (args || ['']).reduce((acc, arg, index) => acc.replace(`{arg${index + 1}}`, arg), msg);\n\nconst getNumber = (value: unknown): number =>\n  typeof value === 'number' || (typeof value === 'string' && value !== '')\n    ? Number(value)\n    : NaN;\n\nconst onNumber = (value: unknown): ValidatedValue => {\n  const parsedValue = getNumber(value);\n  const errors = [];\n  if (Number.isNaN(parsedValue)) {\n    errors.push(ValidatorType.number);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onInteger = (value: unknown): ValidatedValue => {\n  const errors = [];\n  value = getNumber(value);\n  const parsedValue = parseInt(String(value), 10);\n  if (value !== parsedValue) {\n    errors.push(ValidatorType.integer);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onIntegerUnlimited = (value: unknown): ValidatedValue => {\n  let parsedValue = value;\n  const errors = [];\n  value = getNumber(value);\n  if (!Number.isFinite(value)) {\n    parsedValue = value;\n  } else {\n    parsedValue = parseInt(String(value), 10);\n  }\n  if (value !== parsedValue) {\n    errors.push(ValidatorType.integerUnlimited);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onMoreOrEqual = (limit: number, fallback?: boolean) => (value: unknown): ValidatedValue => {\n  const result = onNumber(value);\n  if (!result.isValid) {\n    return result;\n  }\n  let parsedValue = result.value as number;\n  const errors = [];\n  if (parsedValue < limit) {\n    if (!fallback) {\n      errors.push(getError(ValidatorType.moreOrEqual, [String(limit)]));\n    } else {\n      parsedValue = limit;\n    }\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onBoolean = (value: unknown): ValidatedValue => {\n  const errors = [];\n  let parsedValue = value;\n  if (value === 'true') {\n    parsedValue = true;\n  } else if (value === 'false') {\n    parsedValue = false;\n  }\n  if (typeof parsedValue !== 'boolean') {\n    errors.push(ValidatorType.boolean);\n  }\n  return { value: parsedValue, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onObject = (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    errors.push(ValidatorType.object);\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onHtmlElement = (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (!(value instanceof Element) && !(value instanceof HTMLDocument)) {\n    errors.push(ValidatorType.element);\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onItemList = (value: unknown): ValidatedValue => {\n  let parsedValue = value;\n  const errors = [];\n  if (!Array.isArray(value)) {\n    errors.push(ValidatorType.itemList);\n    parsedValue = [];\n  } else if (!value.length) {\n    errors.push(getError(ValidatorType.itemList, ['with at least 1 item']));\n  } else if (value.length > 1) {\n    const type = typeof value[0];\n    if (value.some((v: unknown) => typeof v !== type)) {\n      errors.push(getError(ValidatorType.itemList, ['of items of the same type']));\n    }\n  }\n  return { value: parsedValue as unknown[], isSet: true, isValid: !errors.length, errors };\n};\n\ntype Func = (...args: any[]) => void;\n\nconst onFunction = (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (typeof value !== 'function') {\n    errors.push(ValidatorType.function);\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onFunctionWithXArguments = (argsCount: number) => (value: unknown) => {\n  const result = onFunction(value);\n  if (!result.isValid) {\n    return result;\n  }\n  value = result.value;\n  const errors = [];\n  if ((value as Func).length !== argsCount) {\n    errors.push(getError(ValidatorType.funcOfxArguments, [String(argsCount)]));\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onFunctionWithXAndMoreArguments = (argsCount: number) => (value: unknown): ValidatedValue => {\n  const result = onFunction(value);\n  if (!result.isValid) {\n    return result;\n  }\n  value = result.value;\n  const errors = [];\n  if ((value as Func).length < argsCount) {\n    errors.push(getError(ValidatorType.funcOfxArguments, [String(argsCount)]));\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onFunctionWithXToYArguments = (from: number, to: number) => (value: unknown): ValidatedValue => {\n  const result = onFunction(value);\n  if (!result.isValid) {\n    return result;\n  }\n  value = result.value;\n  const errors = [];\n  if ((value as Func).length < from || (value as Func).length > to) {\n    errors.push(getError(ValidatorType.funcOfXToYArguments, [String(from), String(to)]));\n  }\n  return { value: value as Func, isSet: true, isValid: !errors.length, errors };\n};\n\nconst onOneOf = (tokens: string[], must: boolean) => (value: unknown, context?: IValidationContext): ValidatedValue => {\n  const errors = [];\n  const isSet = value !== void 0;\n  let noOneIsPresent = !isSet;\n  const err = must ? ValidatorType.oneOfMust : ValidatorType.oneOfCan;\n  if (!Array.isArray(tokens) || !tokens.length) {\n    errors.push(getError(err, ['undefined']));\n  } else {\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (typeof token !== 'string') {\n        errors.push(getError(err, [tokens.join('\", \"')]) + ' (non-string token)');\n        break;\n      }\n      const isAnotherPresent = context && Object.prototype.hasOwnProperty.call(context, token);\n      if (isSet && isAnotherPresent) {\n        errors.push(getError(err, [tokens.join('\", \"')]) + ` (${token} is present)`);\n        break;\n      }\n      if (noOneIsPresent && isAnotherPresent) {\n        noOneIsPresent = false;\n      }\n    }\n    if (must && noOneIsPresent) {\n      errors.push(getError(err, [tokens.join('\", \"')]));\n    }\n  }\n  return { value, isSet, isValid: !errors.length, errors };\n};\n\nconst onOr = (validators: IValidator[]) => (value: unknown): ValidatedValue => {\n  const errors = [];\n  if (validators.every(validator => !validator.method(value).isValid)) {\n    errors.push(validators.map(v => v.type).join(' OR '));\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nenum AbstractEnum { }\ntype TEnum = typeof AbstractEnum;\n\nconst onEnum = (list: TEnum) => (value: unknown): ValidatedValue => {\n  const errors = [];\n  const values = Object.keys(list).filter(k => isNaN(Number(k))).map(k => list[k as unknown as number]);\n  if (!values.some(item => item === value)) {\n    errors.push(getError(ValidatorType.enum, ['[' + values.join(',') + ']']));\n  }\n  return { value, isSet: true, isValid: !errors.length, errors };\n};\n\nexport const VALIDATORS = {\n  NUMBER: {\n    type: ValidatorType.number,\n    method: onNumber\n  },\n  INTEGER: {\n    type: ValidatorType.integer,\n    method: onInteger\n  },\n  INTEGER_UNLIMITED: {\n    type: ValidatorType.integerUnlimited,\n    method: onIntegerUnlimited\n  },\n  MORE_OR_EQUAL: (limit: number, fallback?: boolean): IValidator => ({\n    type: ValidatorType.moreOrEqual,\n    method: onMoreOrEqual(limit, fallback)\n  }),\n  BOOLEAN: {\n    type: ValidatorType.boolean,\n    method: onBoolean\n  },\n  OBJECT: {\n    type: ValidatorType.object,\n    method: onObject\n  },\n  ITEM_LIST: {\n    type: ValidatorType.itemList,\n    method: onItemList\n  },\n  ELEMENT: {\n    type: ValidatorType.element,\n    method: onHtmlElement\n  },\n  FUNC: {\n    type: ValidatorType.function,\n    method: onFunction\n  },\n  FUNC_WITH_X_ARGUMENTS: (count: number): IValidator => ({\n    type: ValidatorType.funcOfxArguments,\n    method: onFunctionWithXArguments(count)\n  }),\n  FUNC_WITH_X_AND_MORE_ARGUMENTS: (count: number): IValidator => ({\n    type: ValidatorType.funcOfxAndMoreArguments,\n    method: onFunctionWithXAndMoreArguments(count)\n  }),\n  FUNC_WITH_X_TO_Y_ARGUMENTS: (from: number, to: number): IValidator => ({\n    type: ValidatorType.funcOfXToYArguments,\n    method: onFunctionWithXToYArguments(from, to)\n  }),\n  ONE_OF_CAN: (list: string[]): IValidator => ({\n    type: ValidatorType.oneOfCan,\n    method: onOneOf(list, false)\n  }),\n  ONE_OF_MUST: (list: string[]): IValidator => ({\n    type: ValidatorType.oneOfMust,\n    method: onOneOf(list, true)\n  }),\n  OR: (list: IValidator[]): IValidator => ({\n    type: ValidatorType.or,\n    method: onOr(list)\n  }),\n  ENUM: (list: TEnum): IValidator => ({\n    type: ValidatorType.enum,\n    method: onEnum(list)\n  })\n};\n\nexport class ValidatedData implements IValidatedData {\n\n  context: IValidationContext;\n  isValidContext: boolean;\n  isValid: boolean;\n  errors: string[];\n  params: IValidatedCommonProps<PropertyKey>;\n\n  private contextErrors: string[];\n\n  constructor(context: unknown) {\n    this.params = {};\n    this.contextErrors = [];\n    this.errors = [];\n    this.isValid = true;\n    this.setContext(context);\n  }\n\n  private setContext(context: unknown): void {\n    if (!context || Object.prototype.toString.call(context) !== '[object Object]') {\n      this.setCommonError('context is not an object');\n      this.isValidContext = false;\n    } else {\n      this.isValidContext = true;\n    }\n    this.context = context as IValidationContext;\n  }\n\n  private setValidity() {\n    this.errors = Object.keys(this.params).reduce((acc: string[], key: string) => [\n      ...acc, ...this.params[key].errors\n    ], []);\n    this.isValid = !this.errors.length;\n  }\n\n  setCommonError(error: string): void {\n    this.contextErrors.push(error);\n    this.errors.push(error);\n    this.isValid = false;\n  }\n\n  setParam(token: string, value: ValidatedValue): void {\n    if (!value.isValid) {\n      value.errors = !value.isSet\n        ? [`\"${token}\" must be set`]\n        : value.errors.map((err: string) =>\n          `\"${token}\" ${err}`\n        );\n    }\n    this.params[token] = value;\n    this.setValidity();\n  }\n\n  showErrors(): string {\n    return this.errors.length\n      ? 'validation failed: ' + this.errors.join(', ')\n      : '';\n  }\n}\n\nexport const runValidator = (\n  current: ValidatedValue,\n  validator: IValidator,\n  context: IValidationContext\n): ValidatedValue => {\n  const { value, errors } = current;\n  const result = validator.method(value, context);\n  const _errors = [...errors, ...result.errors];\n  return {\n    value: result.value,\n    isSet: result.isSet,\n    isValid: !_errors.length,\n    errors: _errors\n  };\n};\n\nconst getDefault = (value: unknown, prop: ICommonProp): ValidatedValue => {\n  const empty = value === void 0;\n  const auto = !prop.mandatory && prop.defaultValue !== void 0;\n  return {\n    value: !empty ? value : (auto ? prop.defaultValue : void 0),\n    isSet: !empty || auto,\n    isValid: !empty || !prop.mandatory,\n    errors: []\n  };\n};\n\nexport const validateOne = (\n  context: IValidationContext, name: string, prop: ICommonProp\n): ValidatedValue => {\n  const result = getDefault(context[name], prop);\n  if (!result.isSet) {\n    const oneOfMust = prop.validators.find(v => v.type === ValidatorType.oneOfMust);\n    if (oneOfMust) {\n      return runValidator(result, oneOfMust, context);\n    }\n  } else {\n    for (const validator of Object.values(prop.validators)) {\n      const current = runValidator(result, validator, context);\n      if (!current.isValid && prop.defaultValue !== void 0) {\n        return {\n          value: prop.defaultValue,\n          isSet: true,\n          isValid: true,\n          errors: []\n        };\n      }\n      Object.assign(result, current);\n    }\n  }\n  return result;\n};\n\nexport const validate = (\n  context: unknown, params: ICommonProps<PropertyKey>\n): IValidatedData => {\n  const data = new ValidatedData(context);\n  Object.entries(params).forEach(([key, prop]) =>\n    data.setParam(key, data.isValidContext\n      ? validateOne(data.context, key, prop)\n      : getDefault(void 0, prop)\n    )\n  );\n  return data;\n};\n","import { VALIDATORS } from './validation';\nimport { ICommonProps } from '../interfaces/index';\n\nconst { OBJECT, FUNC_WITH_X_AND_MORE_ARGUMENTS } = VALIDATORS;\n\nexport enum DatasourceProps {\n  get = 'get',\n  settings = 'settings',\n  devSettings = 'devSettings',\n}\n\nexport const DATASOURCE: ICommonProps<DatasourceProps> = {\n  [DatasourceProps.get]: {\n    validators: [FUNC_WITH_X_AND_MORE_ARGUMENTS(2)],\n    mandatory: true\n  },\n  [DatasourceProps.settings]: {\n    validators: [OBJECT]\n  },\n  [DatasourceProps.devSettings]: {\n    validators: [OBJECT]\n  }\n};\n","import { VALIDATORS } from './validation';\nimport { ICommonProps } from '../interfaces/index';\nimport { SizeStrategy } from './common';\n\nconst { NUMBER, INTEGER, INTEGER_UNLIMITED, MORE_OR_EQUAL, BOOLEAN, ELEMENT, FUNC, OR, ENUM } = VALIDATORS;\n\nenum Settings {\n  adapter = 'adapter',\n  startIndex = 'startIndex',\n  minIndex = 'minIndex',\n  maxIndex = 'maxIndex',\n  itemSize = 'itemSize',\n  bufferSize = 'bufferSize',\n  padding = 'padding',\n  infinite = 'infinite',\n  horizontal = 'horizontal',\n  windowViewport = 'windowViewport',\n  viewportElement = 'viewportElement',\n  inverse = 'inverse',\n  onBeforeClip = 'onBeforeClip',\n  sizeStrategy = 'sizeStrategy',\n}\n\nenum DevSettings {\n  debug = 'debug',\n  immediateLog = 'immediateLog',\n  logProcessRun = 'logProcessRun',\n  logTime = 'logTime',\n  throttle = 'throttle',\n  initDelay = 'initDelay',\n  initWindowDelay = 'initWindowDelay',\n  cacheData = 'cacheData',\n  cacheOnReload = 'cacheOnReload',\n  changeOverflow = 'changeOverflow',\n  dismissOverflowAnchor = 'dismissOverflowAnchor',\n}\n\nexport const MIN = {\n  [Settings.itemSize]: 1,\n  [Settings.bufferSize]: 1,\n  [Settings.padding]: 0.01,\n  [DevSettings.throttle]: 0,\n  [DevSettings.initDelay]: 0,\n  [DevSettings.initWindowDelay]: 0,\n};\n\nexport const SETTINGS: ICommonProps<Settings> = {\n  [Settings.adapter]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.startIndex]: {\n    validators: [INTEGER],\n    defaultValue: 1\n  },\n  [Settings.minIndex]: {\n    validators: [INTEGER_UNLIMITED],\n    defaultValue: -Infinity\n  },\n  [Settings.maxIndex]: {\n    validators: [INTEGER_UNLIMITED],\n    defaultValue: Infinity\n  },\n  [Settings.itemSize]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[Settings.itemSize], true)],\n    defaultValue: NaN\n  },\n  [Settings.bufferSize]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[Settings.bufferSize], true)],\n    defaultValue: 5\n  },\n  [Settings.padding]: {\n    validators: [NUMBER, MORE_OR_EQUAL(MIN[Settings.padding], true)],\n    defaultValue: 0.5\n  },\n  [Settings.infinite]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.horizontal]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.windowViewport]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.viewportElement]: {\n    validators: [OR([ELEMENT, FUNC])],\n    defaultValue: null\n  },\n  [Settings.inverse]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [Settings.onBeforeClip]: {\n    validators: [FUNC],\n    defaultValue: null\n  },\n  [Settings.sizeStrategy]: {\n    validators: [ENUM(SizeStrategy)],\n    defaultValue: SizeStrategy.Average\n  },\n};\n\nexport const DEV_SETTINGS: ICommonProps<DevSettings> = {\n  [DevSettings.debug]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.immediateLog]: {\n    validators: [BOOLEAN],\n    defaultValue: true\n  },\n  [DevSettings.logProcessRun]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.logTime]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.throttle]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[DevSettings.throttle], true)],\n    defaultValue: 40\n  },\n  [DevSettings.initDelay]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[DevSettings.initDelay], true)],\n    defaultValue: 1\n  },\n  [DevSettings.initWindowDelay]: {\n    validators: [INTEGER, MORE_OR_EQUAL(MIN[DevSettings.initWindowDelay], true)],\n    defaultValue: 40\n  },\n  [DevSettings.cacheData]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.cacheOnReload]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.changeOverflow]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n  [DevSettings.dismissOverflowAnchor]: {\n    validators: [BOOLEAN],\n    defaultValue: true\n  },\n};\n","export enum CommonProcess {\n  init = 'init',\n  scroll = 'scroll',\n  start = 'start',\n  preFetch = 'preFetch',\n  fetch = 'fetch',\n  postFetch = 'postFetch',\n  render = 'render',\n  preClip = 'preClip',\n  clip = 'clip',\n  adjust = 'adjust',\n  end = 'end',\n}\n\nexport enum AdapterProcess {\n  reset = 'adapter.reset',\n  reload = 'adapter.reload',\n  append = 'adapter.append',\n  prepend = 'adapter.prepend',\n  check = 'adapter.check',\n  remove = 'adapter.remove',\n  replace = 'adapter.replace',\n  update = 'adapter.update',\n  clip = 'adapter.clip',\n  insert = 'adapter.insert',\n  fix = 'adapter.fix',\n}\n\nexport enum ProcessStatus {\n  start = 'start',\n  next = 'next',\n  done = 'done',\n  error = 'error'\n}\n","import { VALIDATORS } from './validation';\nimport { DatasourceProps as AdapterResetParams } from './datasource';\nimport { AdapterProcess as Process } from '../processes/misc/enums';\nimport { ICommonProps, AdapterProcessMap } from '../interfaces/index';\n\nconst {\n  INTEGER,\n  INTEGER_UNLIMITED,\n  BOOLEAN,\n  OBJECT,\n  ITEM_LIST,\n  FUNC_WITH_X_ARGUMENTS,\n  FUNC_WITH_X_AND_MORE_ARGUMENTS,\n  FUNC_WITH_X_TO_Y_ARGUMENTS,\n  ONE_OF_MUST,\n  ONE_OF_CAN,\n  OR,\n} = VALIDATORS;\n\nenum AdapterNoParams { }\nconst NO_METHOD_PARAMS: ICommonProps<AdapterNoParams> = {};\n\nconst RESET_METHOD_PARAMS: ICommonProps<AdapterResetParams> = {\n  [AdapterResetParams.get]: {\n    validators: [FUNC_WITH_X_AND_MORE_ARGUMENTS(2)]\n  },\n  [AdapterResetParams.settings]: {\n    validators: [OBJECT]\n  },\n  [AdapterResetParams.devSettings]: {\n    validators: [OBJECT]\n  },\n};\n\nenum AdapterReloadParams {\n  reloadIndex = 'reloadIndex',\n}\n\nconst RELOAD_METHOD_PARAMS: ICommonProps<AdapterReloadParams> = {\n  [AdapterReloadParams.reloadIndex]: {\n    validators: [INTEGER]\n  },\n};\n\nenum AdapterAppendParams {\n  items = 'items',\n  bof = 'bof',\n  eof = 'eof',\n}\n\nconst APPEND_METHOD_PARAMS: ICommonProps<AdapterAppendParams> = {\n  [AdapterAppendParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterAppendParams.bof]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterAppendParams.eof])]\n  },\n  [AdapterAppendParams.eof]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterAppendParams.bof])]\n  },\n};\n\nenum AdapterRemoveParams {\n  predicate = 'predicate',\n  indexes = 'indexes',\n  increase = 'increase',\n}\n\nconst REMOVE_METHOD_PARAMS: ICommonProps<AdapterRemoveParams> = {\n  [AdapterRemoveParams.predicate]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterRemoveParams.indexes])]\n  },\n  [AdapterRemoveParams.indexes]: {\n    validators: [ITEM_LIST, ONE_OF_MUST([AdapterRemoveParams.predicate])]\n  },\n  [AdapterRemoveParams.increase]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterClipParams {\n  backwardOnly = 'backwardOnly',\n  forwardOnly = 'forwardOnly',\n}\n\nconst CLIP_METHOD_PARAMS: ICommonProps<AdapterClipParams> = {\n  [AdapterClipParams.backwardOnly]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterClipParams.forwardOnly])],\n    defaultValue: false\n  },\n  [AdapterClipParams.forwardOnly]: {\n    validators: [BOOLEAN, ONE_OF_CAN([AdapterClipParams.backwardOnly])],\n    defaultValue: false\n  },\n};\n\nenum AdapterInsertParams {\n  items = 'items',\n  before = 'before',\n  after = 'after',\n  decrease = 'decrease',\n}\n\nconst INSERT_METHOD_PARAMS: ICommonProps<AdapterInsertParams> = {\n  [AdapterInsertParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterInsertParams.before]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterInsertParams.after])]\n  },\n  [AdapterInsertParams.after]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterInsertParams.before])]\n  },\n  [AdapterInsertParams.decrease]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterReplaceParams {\n  items = 'items',\n  predicate = 'predicate',\n  fixRight = 'fixRight',\n}\n\nconst REPLACE_METHOD_PARAMS: ICommonProps<AdapterReplaceParams> = {\n  [AdapterInsertParams.items]: {\n    validators: [ITEM_LIST],\n    mandatory: true\n  },\n  [AdapterReplaceParams.predicate]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1)],\n    mandatory: true\n  },\n  [AdapterReplaceParams.fixRight]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  }\n};\n\nenum AdapterUpdateParams {\n  predicate = 'predicate',\n  fixRight = 'fixRight',\n}\n\nconst UPDATE_METHOD_PARAMS: ICommonProps<AdapterUpdateParams> = {\n  [AdapterUpdateParams.predicate]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1)],\n    mandatory: true\n  },\n  [AdapterUpdateParams.fixRight]: {\n    validators: [BOOLEAN],\n    defaultValue: false\n  },\n};\n\nenum AdapterFixParams {\n  scrollPosition = 'scrollPosition',\n  minIndex = 'minIndex',\n  maxIndex = 'maxIndex',\n  updater = 'updater',\n  scrollToItem = 'scrollToItem',\n  scrollToItemOpt = 'scrollToItemOpt',\n}\n\nconst FIX_METHOD_PARAMS: ICommonProps<AdapterFixParams> = {\n  [AdapterFixParams.scrollPosition]: {\n    validators: [INTEGER_UNLIMITED]\n  },\n  [AdapterFixParams.minIndex]: {\n    validators: [INTEGER_UNLIMITED]\n  },\n  [AdapterFixParams.maxIndex]: {\n    validators: [INTEGER_UNLIMITED]\n  },\n  [AdapterFixParams.updater]: {\n    validators: [FUNC_WITH_X_TO_Y_ARGUMENTS(1, 2)]\n  },\n  [AdapterFixParams.scrollToItem]: {\n    validators: [FUNC_WITH_X_ARGUMENTS(1)]\n  },\n  [AdapterFixParams.scrollToItemOpt]: {\n    validators: [OR([BOOLEAN, OBJECT])]\n  },\n};\n\nexport const AdapterMethods: AdapterProcessMap<{ [key: string]: string }> = {\n  [Process.reset]: AdapterResetParams,\n  [Process.reload]: AdapterReloadParams,\n  [Process.append]: AdapterAppendParams,\n  [Process.prepend]: AdapterAppendParams,\n  [Process.check]: AdapterNoParams,\n  [Process.remove]: AdapterRemoveParams,\n  [Process.clip]: AdapterClipParams,\n  [Process.insert]: AdapterInsertParams,\n  [Process.replace]: AdapterReplaceParams,\n  [Process.update]: AdapterUpdateParams,\n  [Process.fix]: AdapterFixParams,\n};\n\nexport const ADAPTER_METHODS: AdapterProcessMap<ICommonProps<PropertyKey>> = {\n  [Process.reset]: RESET_METHOD_PARAMS,\n  [Process.reload]: RELOAD_METHOD_PARAMS,\n  [Process.append]: APPEND_METHOD_PARAMS,\n  [Process.prepend]: APPEND_METHOD_PARAMS,\n  [Process.check]: NO_METHOD_PARAMS,\n  [Process.remove]: REMOVE_METHOD_PARAMS,\n  [Process.clip]: CLIP_METHOD_PARAMS,\n  [Process.insert]: INSERT_METHOD_PARAMS,\n  [Process.replace]: REPLACE_METHOD_PARAMS,\n  [Process.update]: UPDATE_METHOD_PARAMS,\n  [Process.fix]: FIX_METHOD_PARAMS,\n};\n","import { SETTINGS, DEV_SETTINGS, validate, validateOne, VALIDATORS, SizeStrategy } from '../inputs/index';\nimport { Settings as ISettings, DevSettings as IDevSettings, ICommonProps, ItemsProcessor } from '../interfaces/index';\n\nexport class Settings<Data = unknown> implements ISettings, IDevSettings {\n\n  // user settings\n  adapter: boolean;\n  startIndex: number;\n  minIndex: number;\n  maxIndex: number;\n  itemSize: number;\n  bufferSize: number;\n  padding: number;\n  infinite: boolean;\n  horizontal: boolean;\n  windowViewport: boolean;\n  viewportElement: HTMLElement | (() => void) | null;\n  inverse: boolean; // if true, bwd padding element will have a priority when filling the viewport (if lack of items)\n  onBeforeClip: ItemsProcessor | null; // if set, it will be run before clipping items from Buffer after they are hidden\n  sizeStrategy: SizeStrategy; // \"average\" | \"frequent\", determines behavior of unknown items\n\n  // development settings\n  debug: boolean; // if true, logging is enabled; need to turn off when release\n  immediateLog: boolean; // if false, logging is not immediate and could be done via Workflow.logForce call\n  logTime: boolean; // if true, time differences will be logged\n  logProcessRun: boolean; // if true, process fire/run info will be logged\n  throttle: number; // if > 0, scroll event handling is throttled (ms)\n  initDelay: number; // if set, the Workflow initialization will be postponed (ms)\n  initWindowDelay: number; // if set and the entire window is scrollable, the Workflow init will be postponed (ms)\n  cacheData: boolean; // if true, item's data will be cached along with item's size and index\n  cacheOnReload: boolean; // if true, cache will not be flushed on reload\n  changeOverflow: boolean; // if true, scroll will be disabled per each item's average size change\n  dismissOverflowAnchor: boolean; // if true, the viewport will receive \"overflowAnchor: none\"\n\n  // internal settings, managed by scroller itself\n  instanceIndex: number;\n  initializeDelay: number;\n  viewport: HTMLElement | null;\n\n  constructor(\n    settings: ISettings<Data> | undefined, devSettings: IDevSettings | undefined, instanceIndex: number\n  ) {\n    this.parseInput(settings, SETTINGS);\n    this.parseInput(devSettings, DEV_SETTINGS);\n    this.instanceIndex = instanceIndex;\n    this.initializeDelay = this.getInitializeDelay();\n    this.viewport = this.getViewport();\n    // todo: min/max indexes must be ignored if infinite mode is enabled ??\n  }\n\n  parseInput(input: ISettings<Data> | IDevSettings | undefined, props: ICommonProps<PropertyKey>): void {\n    const result = validate(input, props);\n    if (!result.isValid) {\n      throw new Error('Invalid settings');\n    }\n    Object.entries(result.params).forEach(([key, par]) =>\n      Object.assign(this, { [key]: par.value })\n    );\n  }\n\n  getInitializeDelay(): number {\n    let result = 0;\n    if (this.windowViewport && this.initWindowDelay && !('scrollRestoration' in history)) {\n      result = this.initWindowDelay;\n    }\n    if (this.initDelay > 0) {\n      result = Math.max(result, this.initDelay);\n    }\n    return result;\n  }\n\n  getViewport(): HTMLElement | null {\n    if (typeof this.viewportElement !== 'function') {\n      return this.viewportElement;\n    }\n    const value = this.viewportElement();\n    const result = validateOne({ value }, 'value', { validators: [VALIDATORS.ELEMENT] });\n    if (!result.isValid) {\n      return null; // fallback to default (null) if Function didn't return HTML element synchronously\n    }\n    return result.value as HTMLElement;\n  }\n}\n","import { AdapterProcess, ProcessStatus } from './enums';\nimport { Scroller } from '../../scroller';\nimport { ADAPTER_METHODS, validate } from '../../inputs/index';\nimport { ProcessName, IBaseProcess, IBaseAdapterProcess, IAdapterInput } from '../../interfaces/index';\n\nexport const BaseProcessFactory = (process: ProcessName): IBaseProcess =>\n\n  class BaseProcess {\n\n    static process: ProcessName = process;\n\n  };\n\nexport const BaseAdapterProcessFactory = (process: AdapterProcess): IBaseAdapterProcess =>\n\n  class BaseAdapterProcess extends (BaseProcessFactory(process) as IBaseProcess) {\n\n    static process: AdapterProcess = process;\n\n    static parseInput<T>(scroller: Scroller, options: T, ignoreErrors = false): IAdapterInput<T> {\n      const result: IAdapterInput<T> = {\n        data: validate(options, ADAPTER_METHODS[process])\n      };\n\n      if (result.data.isValid) {\n        result.params = Object.entries(result.data.params)\n          .reduce((acc, [key, { value }]) => ({\n            ...acc,\n            [key]: value\n          }), {} as T);\n      } else {\n        scroller.logger.log(() => result.data.showErrors());\n        if (!ignoreErrors) {\n          scroller.workflow.call({\n            process,\n            status: ProcessStatus.error,\n            payload: { error: `Wrong argument of the \"${process}\" method call` }\n          });\n        }\n      }\n\n      return result;\n    }\n\n  };\n","import { BaseProcessFactory, CommonProcess, AdapterProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { ProcessName } from '../interfaces/index';\n\nconst initProcesses = [CommonProcess.init, AdapterProcess.reset, AdapterProcess.reload];\n\nexport default class Init extends BaseProcessFactory(CommonProcess.init) {\n\n  static run(scroller: Scroller, process: ProcessName): void {\n    const { state: { cycle }, workflow } = scroller;\n    const isInitial = initProcesses.includes(process);\n    scroller.logger.logCycle(true);\n    cycle.start(isInitial, process);\n    workflow.call({\n      process: Init.process,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\nimport { ScrollEventData, ScrollerWorkflow } from '../interfaces/index';\n\nexport default class Scroll extends BaseProcessFactory(CommonProcess.scroll) {\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static run(scroller: Scroller, payload?: { event?: Event }): void {\n    const { workflow, viewport } = scroller;\n    const position = viewport.scrollPosition;\n\n    if (Scroll.onSynthetic(scroller, position)) {\n      return;\n    }\n\n    Scroll.onThrottle(scroller, position, () =>\n      Scroll.onScroll(scroller, workflow)\n    );\n  }\n\n  static onSynthetic(scroller: Scroller, position: number): boolean {\n    const { scrollState } = scroller.state;\n    const synthPos = scrollState.syntheticPosition;\n    if (synthPos !== null) {\n      if (scrollState.syntheticFulfill) {\n        scrollState.syntheticPosition = null;\n      }\n      if (!scrollState.syntheticFulfill || synthPos === position) {\n        scroller.logger.log(() => [\n          'skipping scroll', position, `[${scrollState.syntheticFulfill ? '' : 'pre-'}synthetic]`\n        ]);\n        return true;\n      }\n      scroller.logger.log(() => [\n        'synthetic scroll has been fulfilled:', position, position < synthPos ? '<' : '>', synthPos\n      ]);\n    }\n    return false;\n  }\n\n  static onThrottle(scroller: Scroller, position: number, done: () => void): void {\n    const { state: { scrollState }, settings: { throttle }, logger } = scroller;\n    scrollState.current = Scroll.getScrollEvent(position, scrollState.previous);\n    const { direction, time } = scrollState.current;\n    const timeDiff = scrollState.previous ? time - scrollState.previous.time : Infinity;\n    const delta = throttle - timeDiff;\n    const shouldDelay = isFinite(delta) && delta > 0;\n    const alreadyDelayed = !!scrollState.scrollTimer;\n    logger.log(() => [\n      direction === Direction.backward ? '\\u2934' : '\\u2935',\n      position,\n      shouldDelay ? (timeDiff + 'ms') : '0ms',\n      shouldDelay ? (alreadyDelayed ? 'delayed' : `/ ${delta}ms delay`) : ''\n    ]);\n    if (!shouldDelay) {\n      if (scrollState.scrollTimer) {\n        clearTimeout(scrollState.scrollTimer);\n        scrollState.scrollTimer = null;\n      }\n      done();\n      return;\n    }\n    if (!alreadyDelayed) {\n      scrollState.scrollTimer = setTimeout(() => {\n        logger.log(() => {\n          const curr = Scroll.getScrollEvent(scroller.viewport.scrollPosition, scrollState.current);\n          return [\n            curr.direction === Direction.backward ? '\\u2934' : '\\u2935',\n            curr.position,\n            (curr.time - time) + 'ms',\n            'triggered by timer set on',\n            position\n          ];\n        });\n        scrollState.scrollTimer = null;\n        done();\n      }, delta);\n    }\n  }\n\n  static getScrollEvent(position: number, previous: ScrollEventData | null): ScrollEventData {\n    const time = Number(new Date());\n    let direction: Direction | null = Direction.forward;\n    if (previous) {\n      if (position === previous.position) {\n        direction = previous.direction;\n      } else if (position < previous.position) {\n        direction = Direction.backward;\n      }\n    }\n    return { position, direction, time };\n  }\n\n  static onScroll(scroller: Scroller, workflow: ScrollerWorkflow): void {\n    const { state: { scrollState, cycle } } = scroller;\n    scrollState.previous = { ...(scrollState.current as ScrollEventData) };\n    scrollState.current = null;\n\n    if (cycle.busy.get()) {\n      scroller.logger.log(() => ['skipping scroll', (scrollState.previous as ScrollEventData).position, '[pending]']);\n      return;\n    }\n\n    workflow.call({\n      process: Scroll.process,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { DatasourceProps } from '../../inputs/index';\nimport { Datasource } from '../../classes/datasource';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { IDatasourceOptional, ProcessPayload } from '../../interfaces/index';\n\nexport default class Reset extends BaseAdapterProcessFactory(AdapterProcess.reset) {\n\n  static run(scroller: Scroller, options?: IDatasourceOptional): void {\n    const { datasource, buffer, viewport: { paddings }, state: { cycle } } = scroller;\n\n    if (options) {\n      const { data } = Reset.parseInput(scroller, options);\n      if (!data.isValid) {\n        return;\n      }\n      const constructed = options instanceof Datasource;\n      Object.keys(DatasourceProps).forEach(key => {\n        const param = data.params[key];\n        const ds = datasource as unknown as { [key: string]: unknown };\n        if (param.isSet || (constructed && ds[key])) {\n          ds[key] = param.value;\n        }\n      });\n    }\n\n    buffer.reset(true);\n    paddings.backward.reset();\n    paddings.forward.reset();\n\n    const payload: ProcessPayload = { datasource };\n    if (cycle.busy.get()) {\n      payload.finalize = true;\n      cycle.interrupter = Reset.process;\n    }\n\n    scroller.workflow.call({\n      process: Reset.process,\n      status: ProcessStatus.next,\n      payload\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { ProcessPayload } from '../../interfaces/index';\n\nexport default class Reload extends BaseAdapterProcessFactory(AdapterProcess.reload) {\n\n  static run(scroller: Scroller, reloadIndex: number): void {\n    const { viewport, state, buffer } = scroller;\n\n    const { params } = Reload.parseInput(scroller, { reloadIndex }, true);\n\n    buffer.reset(false, params ? params.reloadIndex : void 0);\n    viewport.reset(buffer.startIndex);\n\n    const payload: ProcessPayload = {};\n    if (state.cycle.busy.get()) {\n      state.scrollState.cleanupTimers();\n      payload.finalize = true;\n      state.cycle.interrupter = Reload.process;\n    }\n\n    scroller.workflow.call({\n      process: Reload.process,\n      status: ProcessStatus.next,\n      payload\n    });\n  }\n\n}\n","import { Routines } from './domRoutines';\nimport { Direction } from '../inputs/index';\nimport { Item as _Item, ItemAdapter } from '../interfaces/index';\n\nexport class Item<Data = unknown> implements _Item<Data> {\n  nodeId: string;\n  routines: Routines;\n  size: number;\n  invisible: boolean;\n  toRemove: boolean;\n  toInsert: boolean;\n  removeDirection: Direction;\n\n  private container: ItemAdapter<Data>;\n\n  get $index(): number {\n    return this.container.$index;\n  }\n  set $index(value: number) {\n    this.container.$index = value;\n  }\n\n  get data(): Data {\n    return this.container.data;\n  }\n  set data(value: Data) {\n    this.container.data = value;\n  }\n\n  get element(): HTMLElement {\n    return this.container.element as HTMLElement;\n  }\n  set element(value: HTMLElement) {\n    this.container.element = value;\n  }\n\n  constructor($index: number, data: Data, routines: Routines) {\n    this.container = {\n      $index,\n      data\n    };\n    this.nodeId = String($index);\n    this.routines = routines;\n    this.invisible = true;\n    this.toRemove = false;\n    this.toInsert = false;\n  }\n\n  dispose(): void {\n    delete this.container.element;\n  }\n\n  setSize(): void {\n    this.size = this.routines.getSize(this.element);\n  }\n\n  hide(): void {\n    if (this.element) {\n      this.routines.hideElement(this.element);\n    }\n  }\n\n  scrollTo(argument?: boolean | ScrollIntoViewOptions): void {\n    if (this.element) {\n      this.routines.scrollTo(this.element, argument);\n    }\n  }\n\n  updateIndex(index: number): void {\n    this.$index = index;\n    this.nodeId = String(index);\n  }\n\n  get(): ItemAdapter<Data> {\n    return this.container;\n  }\n}\n","import { Scroller } from '../../scroller';\nimport { Item } from '../../classes/item';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterAppendOptions, AdapterPrependOptions } from '../../interfaces/index';\n\ntype AdapterAppendPrependOptions = AdapterAppendOptions & AdapterPrependOptions;\n\ninterface AppendRunOptions {\n  process: AdapterProcess;\n  options: AdapterAppendPrependOptions;\n}\n\nexport default class Append extends BaseAdapterProcessFactory(AdapterProcess.append) {\n\n  static run(scroller: Scroller, { process, options }: AppendRunOptions): void {\n\n    const { params } = Append.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n    const { items, bof, eof } = params;\n    const prepend = process !== AdapterProcess.append;\n    const _eof = !!(prepend ? bof : eof);\n\n    // virtual prepend case: shift abs min index and update viewport params\n    if (\n      (prepend && _eof && !scroller.buffer.bof.get()) ||\n      (!prepend && _eof && !scroller.buffer.eof.get())\n    ) {\n      Append.doVirtualize(scroller, items, prepend);\n      scroller.workflow.call({\n        process: Append.process,\n        status: ProcessStatus.done\n      });\n      return;\n    }\n\n    Append.simulateFetch(scroller, items, _eof, prepend);\n\n    scroller.workflow.call({\n      process: Append.process,\n      status: ProcessStatus.next\n    });\n  }\n\n  static doVirtualize(scroller: Scroller, items: unknown[], prepend: boolean): void {\n    const { buffer, viewport: { paddings } } = scroller;\n    const bufferToken = prepend ? 'absMinIndex' : 'absMaxIndex';\n    if (isFinite(buffer[bufferToken])) {\n      const size = items.length * buffer.defaultSize;\n      const padding = prepend ? paddings.backward : paddings.forward;\n      buffer[bufferToken] += (prepend ? -1 : 1) * items.length;\n      padding.size += size;\n      if (prepend) {\n        scroller.viewport.scrollPosition += size;\n      }\n      scroller.logger.log(() => `buffer.${[bufferToken]} value is set to ${buffer[bufferToken]}`);\n      scroller.logger.stat(`after virtual ${prepend ? 'prepend' : 'append'}`);\n    }\n  }\n\n  static simulateFetch(scroller: Scroller, items: unknown[], eof: boolean, prepend: boolean): boolean {\n    const { buffer, state: { fetch } } = scroller;\n    const bufferToken = prepend ? 'absMinIndex' : 'absMaxIndex';\n    let indexToAdd = buffer.getIndexToAdd(eof, prepend);\n    let bufferLimit = buffer[bufferToken];\n    const newItems: Item[] = [];\n\n    for (let i = 0; i < items.length; i++) {\n      const itemToAdd = new Item(indexToAdd, items[i], scroller.routines);\n      if (isFinite(bufferLimit) && (\n        (prepend && indexToAdd < bufferLimit) ||\n        (!prepend && indexToAdd > bufferLimit)\n      )) {\n        bufferLimit += (prepend ? -1 : 1);\n      }\n      (prepend ? Array.prototype.unshift : Array.prototype.push).apply(newItems, [itemToAdd]);\n      // (prepend ? newItems.unshift : newItems.push)(itemToAdd);\n      indexToAdd += (prepend ? -1 : 1);\n    }\n\n    if (bufferLimit !== buffer[bufferToken]) {\n      buffer[bufferToken] = bufferLimit;\n      scroller.logger.log(() => `buffer.${bufferToken} value is set to ${buffer[bufferToken]}`);\n    }\n\n    (prepend ? fetch.prepend : fetch.append).call(fetch, newItems);\n    (prepend ? buffer.prepend : buffer.append).call(buffer, newItems);\n    fetch.first.indexBuffer = !isNaN(buffer.firstIndex) ? buffer.firstIndex : indexToAdd;\n    fetch.last.indexBuffer = !isNaN(buffer.lastIndex) ? buffer.lastIndex : indexToAdd;\n\n    return true;\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { Direction } from '../../inputs/index';\n\nexport default class Check extends BaseAdapterProcessFactory(AdapterProcess.check) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, buffer, state: { fetch }, viewport } = scroller;\n    let min = Infinity, max = -Infinity;\n\n    buffer.items.forEach(item => {\n      const size = item.size;\n      item.setSize();\n      if (item.size !== size) {\n        buffer.cacheItem(item);\n        min = Math.min(min, item.$index);\n        max = Math.max(max, item.$index);\n      }\n    });\n\n    if (Number.isFinite(min)) {\n      fetch.first.indexBuffer = buffer.firstIndex;\n      fetch.last.indexBuffer = buffer.lastIndex;\n      const { index: firstIndex, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n      fetch.firstVisibleIndex = firstIndex;\n      if (!isNaN(firstIndex)) {\n        fetch.firstVisibleItemDelta = - buffer.getSizeByIndex(firstIndex) + diff;\n      }\n      fetch.check(\n        buffer.items.filter(item => item.$index >= min && item.$index <= max)\n      );\n    }\n\n    scroller.logger.stat('check');\n\n    workflow.call({\n      process: Check.process,\n      status: Number.isFinite(min) ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { Direction } from '../../inputs/index';\nimport { AdapterRemoveOptions, ItemsPredicate } from '../../interfaces/index';\n\nexport default class Remove extends BaseAdapterProcessFactory(AdapterProcess.remove) {\n\n  static run(scroller: Scroller, options: AdapterRemoveOptions): void {\n    const { params } = Remove.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n    const shouldRemove = Remove.doRemove(scroller, params);\n\n    scroller.workflow.call({\n      process: Remove.process,\n      status: shouldRemove ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static doRemove(scroller: Scroller, params: AdapterRemoveOptions, sequenceOnly = false): boolean {\n    const { fetch } = scroller.state;\n    fetch.firstVisibleIndex = NaN;\n    const bufferRemoveList = Remove.removeBufferedItems(scroller, params);\n    if (params.indexes && params.indexes.length) { // to avoid duplicate buffer-virtual removals\n      params.indexes = params.indexes.filter(i => !bufferRemoveList.includes(i));\n    }\n    const shouldRemoveBuffered = bufferRemoveList.length > 0;\n    const shouldRemoveVirtual = Remove.removeVirtualItems(scroller, params, sequenceOnly);\n    if (!shouldRemoveBuffered && !shouldRemoveVirtual) {\n      return false;\n    }\n    if (!isNaN(fetch.firstVisibleIndex)) {\n      fetch.remove();\n    }\n    scroller.logger.stat('after remove');\n    return true;\n  }\n\n  static removeBufferedItems(scroller: Scroller, options: AdapterRemoveOptions): number[] {\n    const { predicate, indexes, increase } = options;\n    let result: number[] = [];\n    if (predicate) {\n      result = Remove.runPredicateOverBuffer(scroller, predicate, !!increase);\n    }\n    if (indexes) {\n      const indexPredicate: ItemsPredicate = ({ $index }) => indexes.indexOf($index) >= 0;\n      result = Remove.runPredicateOverBuffer(scroller, indexPredicate, !!increase);\n    }\n    return result;\n  }\n\n  static runPredicateOverBuffer(scroller: Scroller, predicate: ItemsPredicate, increase: boolean): number[] {\n    const { viewport, buffer, buffer: { items }, state: { fetch } } = scroller;\n\n    // get items to remove\n    const clipList = [];\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      if (predicate(item.get())) {\n        clipList.push(item);\n        item.toRemove = true;\n      } else if (clipList.length) {\n        break; // allow only first strict uninterrupted sequence\n      }\n    }\n    if (!clipList.length) {\n      return [];\n    }\n\n    // what item should be shown after remove (1-4)\n    const firstClipIndex = clipList[0].$index, lastClipIndex = clipList[clipList.length - 1].$index;\n    // 1) current first visible item will remain\n    const { index: firstIndex, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n    if (firstIndex < firstClipIndex || firstIndex > lastClipIndex) {\n      fetch.firstVisibleIndex = firstIndex;\n      fetch.firstVisibleItemDelta = - buffer.getSizeByIndex(firstIndex) + diff;\n    }\n    // 2) next after the last removed item\n    if (isNaN(fetch.firstVisibleIndex) && lastClipIndex < buffer.finiteAbsMaxIndex) {\n      fetch.firstVisibleIndex = lastClipIndex + 1;\n    }\n    // 3) prev before the first removed item\n    if (isNaN(fetch.firstVisibleIndex) && firstClipIndex > buffer.finiteAbsMinIndex) {\n      fetch.firstVisibleIndex = firstClipIndex - 1;\n    }\n    // 4) prev before the first removed item\n    if (isNaN(fetch.firstVisibleIndex)) {\n      fetch.firstVisibleIndex = buffer.finiteAbsMinIndex;\n    }\n\n    // logical removal\n    const indexListToRemove = clipList.map(item => item.$index);\n    scroller.logger.log(() =>\n      `going to remove ${clipList.length} item(s) from Buffer: [${indexListToRemove.join(',')}]`\n    );\n    buffer.removeItems(indexListToRemove, increase, false);\n    buffer.checkDefaultSize();\n    Remove.shiftFirstVisibleIndex(scroller, indexListToRemove, increase);\n\n    // physical removal (hiding)\n    clipList.forEach(item => item.hide());\n\n    return indexListToRemove;\n  }\n\n  static removeVirtualItems(scroller: Scroller, params: AdapterRemoveOptions, sequenceOnly: boolean): boolean {\n    const { indexes, increase } = params;\n    if (!indexes || !indexes.length) {\n      return false;\n    }\n    const { buffer, viewport, state: { fetch } } = scroller;\n\n    // get items to remove\n    const { finiteAbsMinIndex, firstIndex, finiteAbsMaxIndex, lastIndex } = buffer;\n    const toRemove = [];\n    let last = NaN;\n    for (let i = 0, len = indexes.length; i < len; i++) {\n      const index = indexes[i];\n      if (index >= finiteAbsMinIndex && !isNaN(firstIndex) && index < firstIndex) {\n        toRemove.push(index); // backward;\n      } else if (index <= finiteAbsMaxIndex && !isNaN(lastIndex) && index > lastIndex) {\n        toRemove.push(index); // forward;\n      } else {\n        continue;\n      }\n      if (sequenceOnly && !isNaN(last) && Math.abs(last - index) > 1) {\n        // allow only first strict uninterrupted sequence\n        break;\n      }\n      last = index;\n    }\n\n    if (!toRemove.length) {\n      return false;\n    }\n\n    // what should be shown after remove; Buffer removal has priority\n    if (isNaN(fetch.firstVisibleIndex)) {\n      const { index, diff } = viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n      if (!isNaN(index)) {\n        fetch.firstVisibleIndex = index;\n        fetch.firstVisibleItemDelta = - buffer.getSizeByIndex(index) + diff;\n      }\n    }\n\n    // virtual removal\n    scroller.logger.log(() => `going to remove ${toRemove.length} item(s) virtually`);\n    buffer.removeItems(toRemove, !!increase, true);\n    buffer.checkDefaultSize();\n    Remove.shiftFirstVisibleIndex(scroller, toRemove, !!increase);\n\n    return true;\n  }\n\n  static shiftFirstVisibleIndex({ state: { fetch } }: Scroller, listToRemove: number[], increase: boolean): void {\n    if (isNaN(fetch.firstVisibleIndex)) {\n      return;\n    }\n    const shift = listToRemove.reduce((acc, index) => acc + (\n      ((increase && index > fetch.firstVisibleIndex) || (!increase && index < fetch.firstVisibleIndex)) ? 1 : 0\n    ), 0);\n    fetch.firstVisibleIndex = fetch.firstVisibleIndex + (increase ? shift : -shift);\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterClipOptions } from '../../interfaces/index';\n\nexport default class UserClip extends BaseAdapterProcessFactory(AdapterProcess.clip) {\n\n  static run(scroller: Scroller, options?: AdapterClipOptions): void {\n    const { params } = UserClip.parseInput(scroller, options);\n\n    scroller.state.clip.forceForward = !(params && params.backwardOnly);\n    scroller.state.clip.forceBackward = !(params && params.forwardOnly);\n\n    scroller.workflow.call({\n      process: UserClip.process,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { Item } from '../../classes/item';\nimport { Direction } from '../../inputs/index';\nimport { AdapterUpdateOptions } from '../../interfaces/index';\n\nexport default class Update extends BaseAdapterProcessFactory(AdapterProcess.update) {\n\n  static run(scroller: Scroller, options: AdapterUpdateOptions): void {\n    const { params } = Update.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n\n    const shouldUpdate = Update.doUpdate(scroller, params);\n\n    scroller.workflow.call({\n      process: Update.process,\n      status: shouldUpdate ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static doUpdate(scroller: Scroller, params: AdapterUpdateOptions): boolean {\n    const { buffer, viewport, state: { fetch }, routines, logger } = scroller;\n    if (!buffer.items) {\n      logger.log(() => 'no items in Buffer');\n      return false;\n    }\n    const before = [...buffer.items];\n    const { item: firstItem, index: firstIndex, diff: firstItemDiff } =\n      viewport.getEdgeVisibleItem(buffer.items, Direction.backward);\n\n    const trackedIndex = buffer.updateItems(\n      params.predicate,\n      (index, data) => new Item(index, data, routines),\n      firstIndex,\n      !!params.fixRight\n    );\n\n    let delta = 0;\n    const trackedItem = buffer.get(trackedIndex);\n    if (firstItem && firstItem === trackedItem) {\n      delta = - buffer.getSizeByIndex(trackedIndex) + firstItemDiff;\n    }\n\n    const itemsToRemove = before.filter(({ toRemove }) => toRemove);\n    itemsToRemove.forEach(item => item.hide());\n    logger.log(() => itemsToRemove.length\n      ? 'items to remove: [' + itemsToRemove.map(({ $index }) => $index).join(',') + ']'\n      : 'no items to remove'\n    );\n\n    const itemsToRender = buffer.items.filter(({ toInsert }) => toInsert);\n    logger.log(() => itemsToRender.length\n      ? 'items to render: [' + itemsToRender.map(({ $index }) => $index).join(',') + ']'\n      : 'no items to render'\n    );\n\n    fetch.update(trackedIndex, delta, itemsToRender, itemsToRemove);\n    return !!itemsToRemove.length || !!itemsToRender.length;\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport Update from './update';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterInsertOptions, AdapterUpdateOptions, ItemsPredicate } from '../../interfaces/index';\n\nexport default class Insert extends BaseAdapterProcessFactory(AdapterProcess.insert) {\n\n  static run(scroller: Scroller, options: AdapterInsertOptions): void {\n    const { params } = Insert.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n    const shouldInsert = Insert.doInsert(scroller, params);\n\n    scroller.workflow.call({\n      process: Insert.process,\n      status: shouldInsert ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static doInsert(scroller: Scroller, params: AdapterInsertOptions): boolean {\n    const { before, after, items, decrease } = params;\n    const method = (before || after) as ItemsPredicate;\n    const found = scroller.buffer.items.find(item => method(item.get()));\n    if (!found) {\n      scroller.logger.log('no item to insert found');\n      return false;\n    }\n\n    const indexToInsert = found.$index;\n    const updateOptions: AdapterUpdateOptions = {\n      predicate: ({ $index, data }) => {\n        if (indexToInsert === $index) {\n          return before ? [...items, data] : [data, ...items];\n        }\n        return true;\n      },\n      fixRight: decrease\n    };\n\n    return Update.doUpdate(scroller, updateOptions);\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport Update from './update';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport { AdapterReplaceOptions, AdapterUpdateOptions } from '../../interfaces/index';\n\nexport default class Replace extends BaseAdapterProcessFactory(AdapterProcess.replace) {\n\n  static run(scroller: Scroller, options: AdapterReplaceOptions): void {\n    const { params } = Replace.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n    const shouldReplace = Replace.doReplace(scroller, params);\n\n    scroller.workflow.call({\n      process: Replace.process,\n      status: shouldReplace ? ProcessStatus.next : ProcessStatus.done,\n    });\n  }\n\n  static doReplace(scroller: Scroller, params: AdapterReplaceOptions): boolean {\n    const toRemove = scroller.buffer.items\n      .filter(item => params.predicate(item))\n      .map(item => item.$index);\n\n    if (!toRemove.length) {\n      scroller.logger.log('no items to be replaced');\n      return false;\n    }\n\n    let injected = false;\n    const updateOptions: AdapterUpdateOptions = {\n      predicate: ({ $index }) => {\n        if (!toRemove.includes($index)) {\n          return true;\n        }\n        if (!injected) {\n          injected = true;\n          return params.items;\n        }\n        return false;\n      },\n      fixRight: params.fixRight\n    };\n\n    return Update.doUpdate(scroller, updateOptions);\n  }\n\n}\n","import { Scroller } from '../../scroller';\nimport { AdapterMethods } from '../../inputs/index';\nimport { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';\nimport {\n  ItemsPredicate,\n  ItemsUpdater,\n  AdapterFixOptions,\n  IValidatedData,\n} from '../../interfaces/index';\n\nconst { [AdapterProcess.fix]: FixParams } = AdapterMethods;\n\nexport default class Fix extends BaseAdapterProcessFactory(AdapterProcess.fix) {\n\n  static run(scroller: Scroller, options: AdapterFixOptions): void {\n    const { workflow } = scroller;\n\n    const { data, params } = Fix.parseInput(scroller, options);\n    if (!params) {\n      return;\n    }\n\n    Object.entries(data.params).forEach(([key, value]) => {\n      if (value.isSet && value.isValid) {\n        Fix.runByType(scroller, key, value.value, data);\n      }\n    });\n\n    workflow.call({\n      process: Fix.process,\n      status: ProcessStatus.done\n    });\n  }\n\n  static runByType(scroller: Scroller, token: string, value: unknown, methodData: IValidatedData): void {\n    switch (token) {\n      case FixParams.scrollPosition:\n        return Fix.setScrollPosition(scroller, value as number);\n      case FixParams.minIndex:\n        return Fix.setMinIndex(scroller, value as number);\n      case FixParams.maxIndex:\n        return Fix.setMaxIndex(scroller, value as number);\n      case FixParams.updater:\n        return Fix.updateItems(scroller, value as ItemsUpdater);\n      case FixParams.scrollToItem:\n        if (methodData.params) {\n          const scrollToItemOpt = methodData.params[FixParams.scrollToItemOpt];\n          const options = scrollToItemOpt ? scrollToItemOpt.value as AdapterFixOptions['scrollToItemOpt'] : void 0;\n          return Fix.scrollToItem(scroller, value as ItemsPredicate, options);\n        }\n        return;\n      case FixParams.scrollToItemOpt:\n        return;\n    }\n  }\n\n  static setScrollPosition({ viewport }: Scroller, value: number): void {\n    let result = value;\n    if (value === -Infinity) {\n      result = 0;\n    } else if (value === Infinity) {\n      result = viewport.getScrollableSize();\n    }\n    viewport.setPosition(result);\n  }\n\n  static setMinIndex({ buffer, settings }: Scroller, value: number): void {\n    settings.minIndex = value;\n    buffer.absMinIndex = value;\n  }\n\n  static setMaxIndex({ buffer, settings }: Scroller, value: number): void {\n    settings.maxIndex = value;\n    buffer.absMaxIndex = value;\n  }\n\n  static updateItems({ buffer, logger }: Scroller, value: ItemsUpdater): void {\n    let updateReference = false;\n    const updater = () => updateReference = true;\n    buffer.items.forEach(item => value(item.get(), updater));\n    if (updateReference) {\n      logger.log(() => 'update Buffer.items reference');\n      buffer.items = [...buffer.items];\n    }\n  }\n\n  static scrollToItem(scroller: Scroller, value: ItemsPredicate, options?: boolean | ScrollIntoViewOptions): void {\n    const found = scroller.buffer.items.find(item => value(item.get()));\n    if (!found) {\n      scroller.logger.log(() => 'scrollToItem cancelled, item not found');\n      return;\n    }\n    found.scrollTo(options);\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\n\nexport default class Start extends BaseProcessFactory(CommonProcess.start) {\n\n  static run(scroller: Scroller): void {\n    const payload = scroller.state.startInnerLoop();\n\n    scroller.workflow.call({\n      process: Start.process,\n      status: ProcessStatus.next,\n      payload\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, AdapterProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\n\nexport default class PreFetch extends BaseProcessFactory(CommonProcess.preFetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, buffer, state: { fetch, cycle } } = scroller;\n    fetch.minIndex = buffer.minIndex;\n\n    // set first and last indexes of items to fetch\n    PreFetch.setPositionsAndIndexes(scroller);\n\n    // skip indexes that are in buffer\n    PreFetch.skipBufferedItems(scroller);\n\n    if (scroller.settings.infinite) {\n      // fill indexes to include buffer if no clip\n      PreFetch.checkBufferGaps(scroller);\n    }\n\n    // add indexes if there are too few items to fetch (clip padding)\n    PreFetch.checkFetchPackSize(scroller);\n\n    // set fetch direction\n    PreFetch.setFetchDirection(scroller);\n\n    workflow.call({\n      process: PreFetch.process,\n      status: PreFetch.getStatus(scroller),\n      payload: { process: cycle.initiator }\n    });\n  }\n\n  static setPositionsAndIndexes(scroller: Scroller): void {\n    PreFetch.setPositions(scroller);\n    PreFetch.setFirstIndex(scroller);\n    PreFetch.setLastIndex(scroller);\n    scroller.logger.fetch();\n  }\n\n  static setPositions(scroller: Scroller): void {\n    const { state: { fetch: { positions } }, viewport } = scroller;\n    const paddingDelta = viewport.getBufferPadding();\n    positions.before = viewport.scrollPosition;\n    positions.startDelta = PreFetch.getStartDelta(scroller);\n    positions.relative = positions.before - positions.startDelta;\n    positions.start = positions.relative - paddingDelta;\n    positions.end = positions.relative + viewport.getSize() + paddingDelta;\n  }\n\n  static getStartDelta(scroller: Scroller): number { // calculate size before start index\n    const { buffer, viewport: { offset } } = scroller;\n    let startDelta = 0;\n    if (offset) {\n      startDelta += offset;\n    }\n    if (!buffer.defaultSize) {\n      return startDelta;\n    }\n    for (let index = buffer.finiteAbsMinIndex; index < buffer.startIndex; index++) {\n      startDelta += buffer.getSizeByIndex(index);\n    }\n    scroller.logger.log(() => [\n      `start delta is ${startDelta}`, ...(offset ? [` (+${offset} offset)`] : [])\n    ]);\n    return startDelta;\n  }\n\n  static setFirstIndex(scroller: Scroller): void {\n    const { state, buffer } = scroller;\n    const { positions: { start }, first } = state.fetch;\n    let firstIndex = buffer.startIndex;\n    let firstIndexPosition = 0;\n    if (state.cycle.innerLoop.isInitial) {\n      scroller.logger.log('skipping fetch backward direction [initial loop]');\n    } else if (!buffer.defaultSize) {\n      scroller.logger.log('skipping fetch backward direction [no item size]');\n    } else {\n      let position = firstIndexPosition;\n      let index = firstIndex;\n      while (1) { // eslint-disable-line no-constant-condition\n        if (start >= 0) {\n          const size = buffer.getSizeByIndex(index);\n          const diff = (position + size) - start;\n          if (diff > 0) {\n            firstIndex = index;\n            firstIndexPosition = position;\n            break;\n          }\n          position += size;\n          index++;\n          if (index < buffer.absMinIndex) {\n            break;\n          }\n        }\n        if (start < 0) {\n          index--;\n          if (index < buffer.absMinIndex) {\n            break;\n          }\n          position -= buffer.getSizeByIndex(index);\n          const diff = position - start;\n          firstIndex = index;\n          firstIndexPosition = position;\n          if (diff <= 0) {\n            break;\n          }\n        }\n      }\n    }\n    first.index = first.indexBuffer = Math.max(firstIndex, buffer.absMinIndex);\n    first.position = firstIndexPosition;\n  }\n\n  static setLastIndex(scroller: Scroller): void {\n    const { state: { fetch, cycle }, buffer, settings } = scroller;\n    const { positions: { relative, end }, first, last } = fetch;\n    let lastIndex;\n    if (!buffer.defaultSize) {\n      // just to fetch forward bufferSize items if neither averageItemSize nor itemSize are present\n      lastIndex = buffer.startIndex + settings.bufferSize - 1;\n      scroller.logger.log('forcing fetch forward direction [no item size]');\n    } else {\n      let index = first.indexBuffer;\n      let position = first.position;\n      lastIndex = index;\n      while (1) { // eslint-disable-line no-constant-condition\n        lastIndex = index;\n        const size = buffer.getSizeByIndex(index);\n        position += size;\n        if (isNaN(fetch.firstVisibleIndex) && position > relative) {\n          fetch.firstVisibleIndex = index;\n          if (!cycle.innerLoop.isInitial) {\n            fetch.firstVisibleItemDelta = position - size - relative;\n          }\n        }\n        if (position >= end) {\n          break;\n        }\n        if (index++ > buffer.absMaxIndex) {\n          break;\n        }\n      }\n    }\n    last.index = last.indexBuffer = Math.min(lastIndex, buffer.absMaxIndex);\n  }\n\n  static skipBufferedItems(scroller: Scroller): void {\n    const { buffer } = scroller;\n    if (!buffer.size) {\n      return;\n    }\n    const { fetch } = scroller.state;\n    const firstIndex = fetch.first.index;\n    const lastIndex = fetch.last.index;\n    const packs: number[][] = [[]];\n    let p = 0;\n    for (let i = firstIndex; i <= lastIndex; i++) {\n      if (!buffer.get(i)) {\n        packs[p].push(i);\n      } else if (packs[p].length) {\n        packs[++p] = [];\n      }\n    }\n    let pack = packs[0];\n    if (packs[0].length && packs[1] && packs[1].length) {\n      fetch.hasAnotherPack = true;\n      // todo: need to look for biggest pack in visible area\n      // todo: or think about merging two requests in a single Fetch process\n      if (packs[1].length >= packs[0].length) {\n        pack = packs[1];\n      }\n    }\n    fetch.first.index = Math.max(pack[0], buffer.absMinIndex);\n    fetch.last.index = Math.min(pack[pack.length - 1], buffer.absMaxIndex);\n    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {\n      scroller.logger.fetch('after Buffer flushing');\n    }\n  }\n\n  static checkBufferGaps(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (!buffer.size) {\n      return;\n    }\n    const fetchFirst = fetch.first.index;\n    const bufferLast = buffer.lastIndex;\n    if (fetchFirst > bufferLast) {\n      fetch.first.index = fetch.first.indexBuffer = bufferLast + 1;\n    }\n    const bufferFirst = buffer.firstIndex;\n    const fetchLast = fetch.last.index;\n    if (fetchLast < bufferFirst) {\n      fetch.last.index = fetch.last.indexBuffer = bufferFirst - 1;\n    }\n    if (fetch.first.index !== fetchFirst || fetch.last.index !== fetchLast) {\n      scroller.logger.fetch('after Buffer filling (no clip case)');\n    }\n  }\n\n  static checkFetchPackSize(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (!fetch.shouldFetch) {\n      return;\n    }\n    const firstIndex = fetch.first.index;\n    const lastIndex = fetch.last.index;\n    const diff = scroller.settings.bufferSize - (lastIndex - firstIndex + 1);\n    if (diff <= 0) {\n      return;\n    }\n    if (!buffer.size || lastIndex > buffer.items[0].$index) { // forward\n      const newLastIndex = Math.min(lastIndex + diff, buffer.absMaxIndex);\n      if (newLastIndex > lastIndex) {\n        fetch.last.index = fetch.last.indexBuffer = newLastIndex;\n      }\n    } else {\n      const newFirstIndex = Math.max(firstIndex - diff, buffer.absMinIndex);\n      if (newFirstIndex < firstIndex) {\n        fetch.first.index = fetch.first.indexBuffer = newFirstIndex;\n      }\n    }\n    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {\n      scroller.logger.fetch('after bufferSize adjustment');\n      PreFetch.skipBufferedItems(scroller);\n    }\n  }\n\n  static setFetchDirection(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (fetch.last.index) {\n      let direction = Direction.forward;\n      if (buffer.size) {\n        direction = fetch.last.index < buffer.items[0].$index ? Direction.backward : Direction.forward;\n      }\n      fetch.direction = direction;\n      scroller.logger.log(() => `fetch direction is \"${direction}\"`);\n    }\n  }\n\n  static getStatus(scroller: Scroller): ProcessStatus {\n    const { cycle, fetch } = scroller.state;\n    if (cycle.initiator === AdapterProcess.clip) {\n      scroller.logger.log(() => `going to skip fetch due to \"${AdapterProcess.clip}\" process`);\n      return ProcessStatus.next;\n    }\n    if (fetch.shouldFetch) {\n      scroller.logger.log(() => `going to fetch ${fetch.count} items started from index ${fetch.index}`);\n      return ProcessStatus.next;\n    }\n    return ProcessStatus.done;\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { ObservableLike } from '../interfaces/index';\n\ninterface Immediate {\n  data: unknown[] | null;\n  error: unknown | null;\n  isError: boolean;\n}\n\ntype FetchGetResult = Immediate | Promise<unknown>;\n\ninterface FetchBox {\n  success: (value: unknown[]) => void;\n  fail: (value: unknown) => void;\n}\n\nexport default class Fetch extends BaseProcessFactory(CommonProcess.fetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow } = scroller;\n\n    const box = {\n      success: (data: unknown[]) => {\n        scroller.logger.log(() =>\n          `resolved ${data.length} items ` +\n          `(index = ${scroller.state.fetch.index}, count = ${scroller.state.fetch.count})`\n        );\n        scroller.state.fetch.newItemsData = data;\n        workflow.call({\n          process: Fetch.process,\n          status: ProcessStatus.next\n        });\n      },\n      fail: (error: unknown) =>\n        workflow.call({\n          process: Fetch.process,\n          status: ProcessStatus.error,\n          payload: { error }\n        })\n    };\n\n    const result = Fetch.get(scroller);\n    Fetch.complete(scroller, box, result);\n  }\n\n  static complete(scroller: Scroller, box: FetchBox, result: FetchGetResult): void {\n    if (Object.prototype.hasOwnProperty.call(result, 'data')) {\n      const { data, error, isError } = result as Immediate;\n      if (!isError) {\n        box.success(data || []);\n      } else {\n        box.fail(error);\n      }\n    } else {\n      const { state: { scrollState, fetch }, viewport } = scroller;\n      if (scrollState.positionBeforeAsync === null) {\n        scrollState.positionBeforeAsync = viewport.scrollPosition;\n      }\n      fetch.cancel = () => {\n        box.success = () => null;\n        box.fail = () => null;\n      };\n      (result as Promise<unknown[]>).then(\n        (data) => box.success(data),\n        (error) => box.fail(error)\n      );\n    }\n  }\n\n  static get(scroller: Scroller): FetchGetResult {\n    const _get = scroller.datasource.get;\n    const { index, count } = scroller.state.fetch;\n\n    let immediateData, immediateError;\n    let resolve: (value: unknown) => void, reject: (value: unknown) => void;\n\n    const done = (data: unknown[]) => {\n      if (!resolve) {\n        immediateData = data || null;\n        return;\n      }\n      resolve(data);\n    };\n    const fail = (error: unknown) => {\n      if (!reject) {\n        immediateError = error || null;\n        return;\n      }\n      reject(error);\n    };\n\n    const getResult = _get(index, count, done, fail);\n\n    if (getResult && typeof getResult === 'object' && getResult !== null) {\n      if (typeof (getResult as PromiseLike<unknown>).then === 'function') {\n        return getResult as Promise<unknown>;\n      } else if (typeof (getResult as ObservableLike).subscribe === 'function') {\n        const sub = (getResult as ObservableLike).subscribe(done, fail, () => {\n          if (sub && typeof sub === 'object' && typeof sub.unsubscribe === 'function') {\n            sub.unsubscribe();\n          }\n        });\n      }\n    }\n\n    if (immediateData || immediateError) { // callback case or immediate observable\n      return {\n        data: immediateError ? null : (immediateData || []),\n        error: immediateError,\n        isError: !!immediateError\n      };\n    }\n\n    return new Promise((_resolve, _reject) => {\n      resolve = _resolve;\n      reject = _reject;\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Item } from '../classes/item';\n\nexport default class PostFetch extends BaseProcessFactory(CommonProcess.postFetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow } = scroller;\n    if (PostFetch.setItems(scroller)) {\n      PostFetch.setBufferLimits(scroller);\n      workflow.call({\n        process: PostFetch.process,\n        status: scroller.state.fetch.hasNewItems\n          ? ProcessStatus.next\n          : ProcessStatus.done\n      });\n    } else {\n      workflow.call({\n        process: PostFetch.process,\n        status: ProcessStatus.error,\n        payload: { error: 'Can\\'t set buffer items' }\n      });\n    }\n  }\n\n  static setBufferLimits(scroller: Scroller): void {\n    const { buffer, state: { fetch, fetch: { items }, cycle: { innerLoop } } } = scroller;\n    const first = fetch.first.index;\n    const last = fetch.last.index;\n    if (!items.length) {\n      if (last < buffer.minIndex || innerLoop.isInitial) {\n        buffer.absMinIndex = buffer.minIndex;\n      }\n      if (first > buffer.maxIndex || innerLoop.isInitial) {\n        buffer.absMaxIndex = buffer.maxIndex;\n      }\n    } else {\n      const lastIndex = items.length - 1;\n      if (first < items[0].$index) {\n        buffer.absMinIndex = items[0].$index;\n      }\n      if (last > items[lastIndex].$index) {\n        buffer.absMaxIndex = items[lastIndex].$index;\n      }\n    }\n  }\n\n  static setItems(scroller: Scroller): boolean {\n    const { buffer, state: { fetch, cycle } } = scroller;\n    const items = fetch.newItemsData;\n    if (!items || !items.length) { // empty result\n      return true;\n    }\n    // eof/bof case, need to shift fetch index if bof\n    let fetchIndex = fetch.index;\n    if (items.length < fetch.count) {\n      if (cycle.innerLoop.isInitial) {\n        // let's treat initial poor fetch as startIndex-bof\n        fetchIndex = buffer.startIndex;\n      } else if (fetch.first.index < buffer.minIndex) { // normal bof\n        fetchIndex = buffer.minIndex - items.length;\n      }\n    }\n    fetch.items = items.map((item, index: number) =>\n      new Item(fetchIndex + index, item, scroller.routines)\n    );\n    fetch.isPrepend = !!buffer.items.length && buffer.items[0].$index > fetch.items[fetch.items.length - 1].$index;\n    return buffer.setItems(fetch.items);\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Item } from '../classes/item';\n\nexport default class Render extends BaseProcessFactory(CommonProcess.render) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, state: { cycle, render, scrollState }, viewport } = scroller;\n    scroller.logger.stat('before new items render');\n    if (scrollState.positionBeforeAsync === null) {\n      scrollState.positionBeforeAsync = viewport.scrollPosition;\n    }\n    render.renderTimer = setTimeout(() => {\n      render.renderTimer = null;\n      if (Render.doRender(scroller)) {\n        workflow.call({\n          process: Render.process,\n          status: render.noSize ? ProcessStatus.done : ProcessStatus.next,\n          payload: { process: cycle.initiator }\n        });\n      } else {\n        workflow.call({\n          process: Render.process,\n          status: ProcessStatus.error,\n          payload: { error: 'Can\\'t associate item with element' }\n        });\n      }\n    }, 0);\n  }\n\n  static doRender(scroller: Scroller): boolean {\n    const { state: { fetch, render }, viewport, buffer, logger } = scroller;\n    render.positionBefore = viewport.scrollPosition;\n    if (!fetch.isCheck) {\n      render.sizeBefore = viewport.getScrollableSize();\n      if (\n        fetch.items.map(item => Render.processElement(scroller, item)).some(x => !x)\n      ) {\n        return false;\n      }\n    }\n    buffer.checkDefaultSize();\n    render.sizeAfter = viewport.getScrollableSize();\n    logger.stat('after new items render');\n    logger.log(() => render.noSize ? 'viewport size has not been changed' : void 0);\n    return true;\n  }\n\n  static processElement(scroller: Scroller, item: Item): boolean {\n    const { state: { fetch }, viewport, buffer } = scroller;\n    const element = viewport.element.querySelector(`[data-sid=\"${item.nodeId}\"]`);\n    if (!element) {\n      return false;\n    }\n    item.element = element as HTMLElement;\n    item.element.style.left = '';\n    item.element.style.top = '';\n    item.element.style.position = '';\n    item.invisible = false;\n    item.setSize();\n    buffer.cacheItem(item);\n    if (item.$index < fetch.minIndex) {\n      fetch.negativeSize += item.size;\n    }\n    return true;\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\r\nimport { Scroller } from '../scroller';\r\n\r\nexport default class Adjust extends BaseProcessFactory(CommonProcess.adjust) {\r\n\r\n  static run(scroller: Scroller): void {\r\n    const { workflow, viewport, state: { scrollState } } = scroller;\r\n\r\n    scrollState.positionBeforeAdjust = viewport.scrollPosition;\r\n    Adjust.setPaddings(scroller);\r\n    scrollState.positionAfterAdjust = viewport.scrollPosition;\r\n\r\n    // scroll position adjustments\r\n    const position = Adjust.calculatePosition(scroller);\r\n\r\n    // set new position using animation frame\r\n    Adjust.setPosition(scroller, position, () =>\r\n      workflow.call({\r\n        process: Adjust.process,\r\n        status: ProcessStatus.done\r\n      })\r\n    );\r\n  }\r\n\r\n  static setPaddings(scroller: Scroller): void {\r\n    const { viewport, buffer, settings: { inverse }, state: { fetch } } = scroller;\r\n    const firstItem = buffer.getFirstVisibleItem();\r\n    const lastItem = buffer.getLastVisibleItem();\r\n    let first, last;\r\n    if (firstItem && lastItem) {\r\n      first = firstItem.$index;\r\n      last = lastItem.$index;\r\n    } else {\r\n      first = !isNaN(fetch.firstVisibleIndex) ? fetch.firstVisibleIndex : buffer.startIndex;\r\n      last = first - 1;\r\n    }\r\n    const { forward, backward } = viewport.paddings;\r\n    let index, bwdSize = 0, fwdSize = 0;\r\n\r\n    // new backward and forward paddings size\r\n    for (index = buffer.finiteAbsMinIndex; index < first; index++) {\r\n      bwdSize += buffer.getSizeByIndex(index);\r\n    }\r\n    for (index = last + 1; index <= buffer.finiteAbsMaxIndex; index++) {\r\n      fwdSize += buffer.getSizeByIndex(index);\r\n    }\r\n\r\n    // lack of items case\r\n    const bufferSize = viewport.getScrollableSize() - forward.size - backward.size;\r\n    const viewportSizeDiff = viewport.getSize() - (bwdSize + bufferSize + fwdSize);\r\n    if (viewportSizeDiff > 0) {\r\n      if (inverse) {\r\n        bwdSize += viewportSizeDiff;\r\n      } else {\r\n        fwdSize += viewportSizeDiff;\r\n      }\r\n      scroller.logger.log(() =>\r\n        inverse ? 'backward' : 'forward' + ` padding will be increased by ${viewportSizeDiff} to fill the viewport`\r\n      );\r\n    }\r\n\r\n    backward.size = bwdSize;\r\n    forward.size = fwdSize;\r\n\r\n    scroller.logger.stat('after paddings adjustments');\r\n  }\r\n\r\n  static calculatePosition(scroller: Scroller): number {\r\n    const { viewport, buffer, state } = scroller;\r\n    const { fetch, render, scrollState } = state;\r\n    let position = viewport.paddings.backward.size;\r\n\r\n    // backward outlet increase\r\n    if (!isNaN(fetch.firstVisibleIndex) && !isNaN(buffer.firstIndex)) {\r\n      for (let i = buffer.firstIndex; i < fetch.firstVisibleIndex; i++) {\r\n        position += buffer.getSizeByIndex(i);\r\n      }\r\n      if (fetch.firstVisibleItemDelta) {\r\n        position -= fetch.firstVisibleItemDelta;\r\n      }\r\n    } else {\r\n      if (fetch.isPrepend && fetch.negativeSize) {\r\n        position += fetch.negativeSize;\r\n      }\r\n    }\r\n\r\n    // change per slow fetch/render\r\n    if (scrollState.positionBeforeAsync !== null) {\r\n      const diff = render.positionBefore - scrollState.positionBeforeAsync;\r\n      if (diff !== 0) {\r\n        scroller.logger.log(`shift position due to fetch-render difference (${diff})`);\r\n        position += diff;\r\n      }\r\n    }\r\n\r\n    // offset increase\r\n    if (viewport.offset > 0 && (position || fetch.positions.before)) {\r\n      position += viewport.offset;\r\n    }\r\n\r\n    return Math.round(position);\r\n  }\r\n\r\n  static setPosition(scroller: Scroller, position: number, done: () => void): void {\r\n    const { state: { scrollState }, viewport } = scroller;\r\n    if (!scrollState.hasPositionChanged(position)) {\r\n      return done();\r\n    }\r\n    scrollState.syntheticPosition = position;\r\n    scrollState.syntheticFulfill = false;\r\n\r\n    scrollState.animationFrameId = requestAnimationFrame(() => {\r\n      const inertiaDiff = (scrollState.positionAfterAdjust as number) - viewport.scrollPosition;\r\n      let diffLog = '';\r\n      if (inertiaDiff > 0) {\r\n        position -= inertiaDiff;\r\n        scrollState.syntheticPosition = position;\r\n        diffLog = ` (-${inertiaDiff})`;\r\n      }\r\n      scrollState.syntheticFulfill = true;\r\n      viewport.scrollPosition = position;\r\n      scroller.logger.stat('after scroll adjustment' + diffLog);\r\n      done();\r\n    });\r\n  }\r\n\r\n}\r\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\n\nexport default class PreClip extends BaseProcessFactory(CommonProcess.preClip) {\n\n  static run(scroller: Scroller): void {\n    PreClip.prepareClip(scroller);\n\n    scroller.workflow.call({\n      process: PreClip.process,\n      status: ProcessStatus.next,\n      payload: {\n        doClip: scroller.state.clip.doClip\n      }\n    });\n  }\n\n  static prepareClip(scroller: Scroller): void {\n    const { state: { fetch, clip } } = scroller;\n    if (PreClip.shouldNotClip(scroller)) {\n      return;\n    }\n    const firstIndex = fetch.first.indexBuffer;\n    const lastIndex = fetch.last.indexBuffer;\n    scroller.logger.log(() =>\n      `looking for ${fetch.direction ? 'anti-' + fetch.direction + ' ' : ''}items ` +\n      `that are out of [${firstIndex}..${lastIndex}] range`);\n    if (PreClip.isBackward(scroller, firstIndex)) {\n      PreClip.prepareClipByDirection(scroller, Direction.backward, firstIndex);\n    }\n    if (PreClip.isForward(scroller, lastIndex)) {\n      PreClip.prepareClipByDirection(scroller, Direction.forward, lastIndex);\n    }\n    if (!clip.doClip) {\n      scroller.logger.log('skipping clip [no items to clip]');\n    }\n    return;\n  }\n\n  static shouldNotClip(scroller: Scroller): boolean {\n    const { settings, buffer, state } = scroller;\n    if (settings.infinite && !state.clip.force) {\n      scroller.logger.log('skipping clip [infinite mode]');\n      return true;\n    }\n    if (!buffer.size) {\n      scroller.logger.log('skipping clip [empty buffer]');\n      return true;\n    }\n    if (state.cycle.isInitial) {\n      scroller.logger.log('skipping clip [initial cycle]');\n      return true;\n    }\n    return false;\n  }\n\n  static isBackward(scroller: Scroller, firstIndex: number): boolean {\n    const { buffer, state: { clip, fetch } } = scroller;\n    if (clip.force) {\n      return clip.forceBackward;\n    }\n    if (fetch.direction !== Direction.backward) {\n      if (firstIndex - 1 >= buffer.absMinIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static isForward(scroller: Scroller, lastIndex: number): boolean {\n    const { buffer, state: { clip, fetch } } = scroller;\n    if (clip.force) {\n      return clip.forceForward;\n    }\n    if (fetch.direction !== Direction.forward) {\n      if (lastIndex + 1 <= buffer.absMaxIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static prepareClipByDirection(scroller: Scroller, direction: Direction, edgeIndex: number): void {\n    const forward = direction === Direction.forward;\n    scroller.buffer.items.forEach(item => {\n      if (\n        (!forward && item.$index < edgeIndex) ||\n        (forward && item.$index > edgeIndex)\n      ) {\n        item.toRemove = true;\n        item.removeDirection = direction;\n        scroller.state.clip.doClip = true;\n      }\n    });\n  }\n\n}\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\r\nimport { Scroller } from '../scroller';\r\nimport { Direction } from '../inputs/index';\r\n\r\nexport default class Clip extends BaseProcessFactory(CommonProcess.clip) {\r\n\r\n  static run(scroller: Scroller): void {\r\n    const { workflow } = scroller;\r\n\r\n    Clip.doClip(scroller);\r\n\r\n    workflow.call({\r\n      process: Clip.process,\r\n      status: ProcessStatus.next\r\n    });\r\n  }\r\n\r\n  static doClip(scroller: Scroller): void {\r\n    const { buffer, viewport: { paddings }, state: { clip }, logger } = scroller;\r\n    const size = { [Direction.backward]: 0, [Direction.forward]: 0 };\r\n\r\n    logger.stat(`before clip (${++clip.callCount})`);\r\n\r\n    const itemsToRemove = buffer.items.filter(item => {\r\n      if (!item.toRemove) {\r\n        return false;\r\n      }\r\n      item.hide();\r\n      size[item.removeDirection] += item.size;\r\n      return true;\r\n    });\r\n\r\n    if (itemsToRemove.length) {\r\n      if (size[Direction.backward]) {\r\n        paddings.byDirection(Direction.backward).size += size[Direction.backward];\r\n      }\r\n      if (size[Direction.forward]) {\r\n        paddings.byDirection(Direction.forward).size += size[Direction.forward];\r\n      }\r\n      if (scroller.settings.onBeforeClip) {\r\n        scroller.settings.onBeforeClip(itemsToRemove.map(item => item.get()));\r\n      }\r\n    }\r\n\r\n    buffer.clip();\r\n\r\n    logger.log(() => {\r\n      const list = itemsToRemove.map(({ $index }) => $index);\r\n      return list.length\r\n        ? [\r\n          `clipped ${list.length} item(s) from Buffer` +\r\n          (size.backward ? `, +${size.backward} fwd px` : '') +\r\n          (size.forward ? `, +${size.forward} bwd px` : '') +\r\n          `, range: [${list[0]}..${list[list.length - 1]}]`\r\n        ]\r\n        : 'clipped 0 items from Buffer';\r\n    });\r\n\r\n    logger.stat('after clip');\r\n  }\r\n\r\n}\r\n","import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\nimport { EMPTY_ITEM } from '../classes/adapter/props';\nimport { ScrollerWorkflow } from '../interfaces/index';\n\nconst isInterrupted = ({ call }: ScrollerWorkflow): boolean => !!call.interrupted;\n\nexport default class End extends BaseProcessFactory(CommonProcess.end) {\n\n  static run(scroller: Scroller, { error }: { error?: unknown } = {}): void {\n    const { workflow, state: { cycle: { interrupter } } } = scroller;\n\n    if (!error && !interrupter) {\n      // set out params accessible via Adapter\n      End.calculateParams(scroller, workflow);\n    }\n\n    // explicit interruption for we don't want to go through the inner loop finalizing\n    if (isInterrupted(workflow)) {\n      workflow.call({ process: End.process, status: ProcessStatus.done });\n      return;\n    }\n\n    const next = End.finalizeInnerLoop(scroller, error);\n\n    workflow.call({\n      process: End.process,\n      status: next ? ProcessStatus.next : ProcessStatus.done,\n      payload: { ...(interrupter ? { process: interrupter } : {}) }\n    });\n  }\n\n  static calculateParams(scroller: Scroller, workflow: ScrollerWorkflow): void {\n    const { adapter, viewport, buffer: { items } } = scroller;\n\n    if (adapter.wanted.firstVisible) {\n      const { item } = viewport.getEdgeVisibleItem(items, Direction.backward);\n      if (!item || item.element !== adapter.firstVisible.element) {\n        adapter.firstVisible = item ? item.get() : EMPTY_ITEM;\n      }\n    }\n\n    // the workflow can be interrupter on firstVisible change\n    if (adapter.wanted.lastVisible && !isInterrupted(workflow)) {\n      const { item } = viewport.getEdgeVisibleItem(items, Direction.forward);\n      if (!item || item.element !== adapter.lastVisible.element) {\n        adapter.lastVisible = item ? item.get() : EMPTY_ITEM;\n      }\n    }\n  }\n\n  static finalizeInnerLoop(scroller: Scroller, error: unknown): boolean {\n    const { state, state: { cycle, clip, fetch } } = scroller;\n    const next = !!cycle.interrupter || (error ? false : End.getNext(scroller));\n    cycle.innerLoop.isInitial = false;\n    fetch.stopSimulate();\n    clip.reset(true);\n    state.endInnerLoop();\n    return next;\n  }\n\n  static getNext(scroller: Scroller): boolean {\n    const { state: { fetch, render } } = scroller;\n    if (fetch.simulate && fetch.isCheck && !render.noSize) { // Adapter.check\n      return true;\n    }\n    if (fetch.simulate && fetch.doRemove) { // Adapter.remove or Adapter.update with clip\n      return true;\n    }\n    if ( // common inner loop (App start, Scroll, Adapter.clip) accompanied by fetch\n      !fetch.simulate && ((fetch.hasNewItems && !render.noSize) || fetch.hasAnotherPack)\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n}\n","import { Scroller } from '../scroller';\nimport { CommonProcess, AdapterProcess, ProcessStatus as Status } from '../processes/index';\nimport { IPackages, ProcessSubject } from '../interfaces/index';\n\ntype LogType = [unknown?, ...unknown[]];\n\nexport class Logger {\n\n  readonly debug: boolean;\n  readonly immediateLog: boolean;\n  readonly logTime: boolean;\n  readonly getTime: () => string;\n  readonly getStat: () => string;\n  readonly getFetchRange: () => string;\n  readonly getWorkflowCycleData: () => string;\n  readonly getLoopId: () => string;\n  readonly getLoopIdNext: () => string;\n  readonly getScrollPosition: (element: HTMLElement) => number;\n  private logs: unknown[][] = [];\n\n  constructor(scroller: Scroller, packageInfo: IPackages, adapter?: { id: number }) {\n    const { settings } = scroller;\n    this.debug = settings.debug;\n    this.immediateLog = settings.immediateLog;\n    this.logTime = settings.logTime;\n    this.getTime = (): string =>\n      scroller.state && ` // time: ${scroller.state.time}`;\n    this.getStat = (): string => {\n      const { buffer, viewport } = scroller;\n      const first = buffer.getFirstVisibleItem();\n      const last = buffer.getLastVisibleItem();\n      return 'pos: ' + viewport.scrollPosition + ', ' +\n        'size: ' + viewport.getScrollableSize() + ', ' +\n        'bwd_p: ' + viewport.paddings.backward.size + ', ' +\n        'fwd_p: ' + viewport.paddings.forward.size + ', ' +\n        'default: ' + (buffer.defaultSize || 'no') + ', ' +\n        'items: ' + buffer.getVisibleItemsCount() + ', ' +\n        'range: ' + (first && last ? `[${first.$index}..${last.$index}]` : 'no');\n    };\n    this.getFetchRange = (): string => {\n      const { first: { index: first }, last: { index: last } } = scroller.state.fetch;\n      return !Number.isNaN(first) && !Number.isNaN(last)\n        ? `[${first}..${last}]`\n        : 'no';\n    };\n    this.getLoopId = (): string => scroller.state.cycle.loopId;\n    this.getLoopIdNext = (): string => scroller.state.cycle.loopIdNext;\n    this.getWorkflowCycleData = (): string =>\n      `${settings.instanceIndex}-${scroller.state.cycle.count}`;\n    this.getScrollPosition = (element: HTMLElement) => scroller.routines.getScrollPosition(element);\n    this.log(() =>\n      'vscroll Workflow has been started, ' +\n      `core: ${packageInfo.core.name} v${packageInfo.core.version}, ` +\n      `consumer: ${packageInfo.consumer.name} v${packageInfo.consumer.version}, ` +\n      `workflow instance: ${settings.instanceIndex}, adapter ` +\n      (!adapter ? 'is not instantiated' : `instance: ${adapter.id}`)\n    );\n  }\n\n  object(str: string, obj: unknown, stringify?: boolean): void {\n    this.log(() => [\n      str,\n      stringify\n        ? JSON.stringify(obj, (k, v) => {\n          if (Number.isNaN(v)) {\n            return 'NaN';\n          }\n          if (v === Infinity) {\n            return 'Infinity';\n          }\n          if (v === -Infinity) {\n            return '-Infinity';\n          }\n          if (v instanceof Element) {\n            return 'HTMLElement';\n          }\n          if (v instanceof HTMLDocument) {\n            return 'HTMLDocument';\n          }\n          if (typeof v === 'function') {\n            return 'Function';\n          }\n          return v;\n        })\n          .replace(/\"/g, '')\n          .replace(/(\\{|:|,)/g, '$1 ')\n          .replace(/(\\})/g, ' $1')\n        : obj\n    ]);\n  }\n\n  stat(str?: string): void {\n    if (this.debug) {\n      const logStyles = [\n        'color: #888; border: dashed #888 0; border-bottom-width: 0px',\n        'color: #000; border-width: 0'\n      ];\n      this.log(() => ['%cstat' + (str ? ` ${str}` : '') + ',%c ' + this.getStat(), ...logStyles]);\n    }\n  }\n\n  fetch(str?: string): void {\n    if (this.debug) {\n      const _text = 'fetch interval' + (str ? ` ${str}` : '');\n      const logStyles = ['color: #888', 'color: #000'];\n      this.log(() => [`%c${_text}: %c${this.getFetchRange()}`, ...logStyles]);\n    }\n  }\n\n  prepareForLog(data: unknown): unknown {\n    return data instanceof Event && data.target\n      ? this.getScrollPosition(data.target as HTMLElement)\n      : data;\n  }\n\n  logProcess(data: ProcessSubject): void {\n    if (!this.debug) {\n      return;\n    }\n    const { process, status, payload } = data;\n\n    // inner loop start-end log\n    const loopLog: string[] = [];\n    if (\n      process === CommonProcess.init && status === Status.next\n    ) {\n      loopLog.push(`%c---=== loop ${this.getLoopIdNext()} start`);\n    } else if (\n      process === CommonProcess.end\n    ) {\n      loopLog.push(`%c---=== loop ${this.getLoopId()} done`);\n      const parent = payload && payload.process;\n      if (status === Status.next && (parent !== AdapterProcess.reset && parent !== AdapterProcess.reload)) {\n        loopLog[0] += `, loop ${this.getLoopIdNext()} start`;\n      }\n    }\n    if (loopLog.length) {\n      this.log(() => [...loopLog, 'color: #006600;']);\n    }\n  }\n\n  logCycle(start = true): void {\n    const logData = this.getWorkflowCycleData();\n    const border = start ? '1px 0 0 1px' : '0 0 1px 1px';\n    const logStyles = `color: #0000aa; border: solid #555 1px; border-width: ${border}; margin-left: -2px`;\n    this.log(() => [`%c   ~~~ WF Cycle ${logData} ${start ? 'STARTED' : 'FINALIZED'} ~~~  `, logStyles]);\n  }\n\n  logError(str: string): void {\n    if (this.debug) {\n      const logStyles = ['color: #a00;', 'color: #000'];\n      this.log(() => ['error:%c' + (str ? ` ${str}` : '') + `%c (loop ${this.getLoopIdNext()})`, ...logStyles]);\n    }\n  }\n\n  logAdapterMethod = (methodName: string, args?: unknown, add?: string): void => {\n    if (!this.debug) {\n      return;\n    }\n    const params = (\n      args === void 0 ? [] : (Array.isArray(args) ? args : [args])\n    )\n      .map((arg: unknown) => {\n        if (typeof arg === 'function') {\n          return 'func';\n        } else if (typeof arg !== 'object' || !arg) {\n          return arg;\n        } else if (Array.isArray(arg)) {\n          return `[of ${arg.length}]`;\n        }\n        return '{ ' + Object.keys(arg).join(', ') + ' }';\n      })\n      .join(', ');\n    this.log(`adapter: ${methodName}(${params || ''})${add || ''}`);\n  }\n\n  log(...args: any[]): void {\n    if (this.debug) {\n      if (typeof args[0] === 'function') {\n        args = args[0]();\n        if (!Array.isArray(args)) {\n          args = [args];\n        }\n      }\n      if (args.every(item => item === void 0)) {\n        return;\n      }\n      if (this.logTime) {\n        args = [...args, this.getTime()];\n      }\n      args = args.map((arg: unknown) => this.prepareForLog(arg));\n      if (this.immediateLog) {\n        console.log.apply(this, args as LogType);\n      } else {\n        this.logs.push(args);\n      }\n    }\n  }\n\n  // logNow(...args: any[]) {\n  //   const immediateLog = this.immediateLog;\n  //   const debug = this.debug;\n  //   (this as any).debug = true;\n  //   (this as any).immediateLog = true;\n  //   this.log.apply(this, args);\n  //   (this as any).debug = debug;\n  //   (this as any).immediateLog = immediateLog;\n  // }\n\n  logForce(...args: unknown[]): void {\n    if (this.debug) {\n      if (!this.immediateLog && this.logs.length) {\n        this.logs.forEach(logArgs => console.log.apply(this, logArgs));\n        this.logs = [];\n      }\n      if (args.length) {\n        console.log.apply(this, args as LogType);\n      }\n    }\n  }\n}\n","import { Settings } from './settings';\nimport { Direction } from '../inputs/index';\n\nexport class Routines {\n\n  readonly horizontal: boolean;\n  readonly window: boolean;\n\n  constructor(settings: Settings) {\n    this.horizontal = settings.horizontal;\n    this.window = settings.windowViewport;\n  }\n\n  checkElement(element: HTMLElement): void {\n    if (!element) {\n      throw new Error('HTML element is not defined');\n    }\n  }\n\n  getScrollPosition(element: HTMLElement): number {\n    if (this.window) {\n      return window.pageYOffset;\n    }\n    this.checkElement(element);\n    return element[this.horizontal ? 'scrollLeft' : 'scrollTop'];\n  }\n\n  setScrollPosition(element: HTMLElement, value: number): void {\n    value = Math.max(0, value);\n    if (this.window) {\n      if (this.horizontal) {\n        window.scrollTo(value, window.scrollY);\n      } else {\n        window.scrollTo(window.scrollX, value);\n      }\n      return;\n    }\n    this.checkElement(element);\n    element[this.horizontal ? 'scrollLeft' : 'scrollTop'] = value;\n  }\n\n  getParams(element: HTMLElement, doNotBind?: boolean): ClientRect {\n    this.checkElement(element);\n    if (this.window && doNotBind) {\n      return {\n        'height': element.clientHeight,\n        'width': element.clientWidth,\n        'top': element.clientTop,\n        'bottom': element.clientTop + element.clientHeight,\n        'left': element.clientLeft,\n        'right': element.clientLeft + element.clientWidth\n      };\n    }\n    return element.getBoundingClientRect();\n  }\n\n  getSize(element: HTMLElement, doNotBind?: boolean): number {\n    return this.getParams(element, doNotBind)[this.horizontal ? 'width' : 'height'];\n  }\n\n  getSizeStyle(element: HTMLElement): number {\n    this.checkElement(element);\n    const size = element.style[this.horizontal ? 'width' : 'height'];\n    return parseFloat(size as string) || 0;\n  }\n\n  setSizeStyle(element: HTMLElement, value: number): void {\n    this.checkElement(element);\n    value = Math.max(0, Math.round(value));\n    element.style[this.horizontal ? 'width' : 'height'] = `${value}px`;\n  }\n\n  getEdge(element: HTMLElement, direction: Direction, doNotBind?: boolean): number {\n    const params = this.getParams(element, doNotBind);\n    const isFwd = direction === Direction.forward;\n    return params[isFwd ? (this.horizontal ? 'right' : 'bottom') : (this.horizontal ? 'left' : 'top')];\n  }\n\n  getEdge2(element: HTMLElement, direction: Direction, relativeElement: HTMLElement, opposite: boolean): number {\n    // vertical only ?\n    return element.offsetTop - (relativeElement ? relativeElement.scrollTop : 0) +\n      (direction === (!opposite ? Direction.forward : Direction.backward) ? this.getSize(element) : 0);\n  }\n\n  hideElement(element: HTMLElement): void {\n    this.checkElement(element);\n    element.style.display = 'none';\n  }\n\n  getOffset(element: HTMLElement): number {\n    this.checkElement(element);\n    return (this.horizontal ? element.offsetLeft : element.offsetTop) || 0;\n  }\n\n  scrollTo(element: HTMLElement, argument?: boolean | ScrollIntoViewOptions): void {\n    this.checkElement(element);\n    element.scrollIntoView(argument);\n  }\n\n}\n","import { Routines } from './domRoutines';\r\nimport { Settings } from './settings';\r\nimport { Direction } from '../inputs/index';\r\n\r\nexport class Padding {\r\n\r\n  element: HTMLElement;\r\n  direction: Direction;\r\n  routines: Routines;\r\n\r\n  constructor(element: HTMLElement, direction: Direction, routines: Routines) {\r\n    this.element = element.querySelector(`[data-padding-${direction}]`) as HTMLElement;\r\n    this.direction = direction;\r\n    this.routines = routines;\r\n  }\r\n\r\n  reset(size?: number): void {\r\n    this.size = size || 0;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.routines.getSizeStyle(this.element);\r\n  }\r\n\r\n  set size(value: number) {\r\n    this.routines.setSizeStyle(this.element, value);\r\n  }\r\n\r\n}\r\n\r\nexport class Paddings {\r\n  settings: Settings;\r\n  forward: Padding;\r\n  backward: Padding;\r\n\r\n  constructor(element: HTMLElement, routines: Routines, settings: Settings) {\r\n    this.settings = settings;\r\n    this.forward = new Padding(element, Direction.forward, routines);\r\n    this.backward = new Padding(element, Direction.backward, routines);\r\n  }\r\n\r\n  byDirection(direction: Direction, opposite?: boolean): Padding {\r\n    return direction === Direction.backward\r\n      ? (opposite ? this.forward : this.backward)\r\n      : (opposite ? this.backward : this.forward);\r\n  }\r\n\r\n  reset(viewportSize: number, startIndex: number, offset: number): void {\r\n    const positive = this.getPositiveSize(startIndex, viewportSize, offset);\r\n    const negative = this.getNegativeSize(startIndex);\r\n    if (this.settings.inverse) {\r\n      this.forward.reset(negative);\r\n      this.backward.reset(positive);\r\n      const diff = viewportSize - this.backward.size - offset;\r\n      if (diff > 0) {\r\n        this.backward.size += diff;\r\n        this.forward.size -= diff;\r\n      }\r\n    } else {\r\n      this.forward.reset(positive);\r\n      this.backward.reset(negative);\r\n      const diff = viewportSize - this.forward.size - offset;\r\n      if (diff > 0) {\r\n        this.backward.size -= diff;\r\n        this.forward.size += diff;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  getPositiveSize(startIndex: number, viewportSize: number, offset: number): number {\r\n    const { settings } = this;\r\n    let positiveSize = viewportSize;\r\n    if (isFinite(settings.maxIndex)) {\r\n      positiveSize = (settings.maxIndex - startIndex + 1) * settings.itemSize;\r\n    }\r\n    if (offset) {\r\n      positiveSize = Math.max(positiveSize - offset, 0);\r\n    }\r\n    return positiveSize;\r\n  }\r\n\r\n  getNegativeSize(startIndex: number): number {\r\n    const { settings } = this;\r\n    let negativeSize = 0;\r\n    if (isFinite(settings.minIndex)) {\r\n      negativeSize = (startIndex - settings.minIndex) * settings.itemSize;\r\n    }\r\n    return negativeSize;\r\n  }\r\n}\r\n","import { Paddings } from './paddings';\nimport { Settings } from './settings';\nimport { Routines } from './domRoutines';\nimport { Item } from './item';\nimport { State } from './state';\nimport { Logger } from './logger';\nimport { Direction } from '../inputs/index';\n\nexport class Viewport {\n\n  offset: number;\n  paddings: Paddings;\n\n  readonly element: HTMLElement;\n  readonly settings: Settings;\n  readonly routines: Routines;\n  readonly state: State;\n  readonly logger: Logger;\n\n  readonly hostElement: HTMLElement;\n  readonly scrollEventReceiver: HTMLElement | Window;\n\n  private disabled: boolean;\n\n  constructor(element: HTMLElement, settings: Settings, routines: Routines, state: State, logger: Logger) {\n    this.element = element;\n    this.settings = settings;\n    this.routines = routines;\n    this.state = state;\n    this.logger = logger;\n    this.disabled = false;\n\n    if (settings.windowViewport) {\n      this.hostElement = document.documentElement as HTMLElement;\n      this.scrollEventReceiver = window;\n    } else {\n      this.hostElement = settings.viewport || this.element.parentElement as HTMLElement;\n      this.scrollEventReceiver = this.hostElement;\n    }\n\n    this.paddings = new Paddings(this.element, this.routines, settings);\n\n    if (settings.windowViewport && 'scrollRestoration' in history) {\n      history.scrollRestoration = 'manual';\n    }\n\n    if (settings.dismissOverflowAnchor) {\n      this.hostElement.style.overflowAnchor = 'none';\n    }\n  }\n\n  reset(startIndex: number): void {\n    this.setOffset();\n    this.paddings.reset(this.getSize(), startIndex, this.offset);\n    this.scrollPosition = this.paddings.backward.size || 0;\n    this.state.scrollState.reset();\n  }\n\n  setPosition(value: number): number {\n    const oldPosition = this.scrollPosition;\n    if (oldPosition === value) {\n      this.logger.log(() => ['setting scroll position at', value, '[cancelled]']);\n      return value;\n    }\n    this.routines.setScrollPosition(this.hostElement, value);\n    const position = this.scrollPosition;\n    this.logger.log(() => [\n      'setting scroll position at', position, ...(position !== value ? [`(${value})`] : [])\n    ]);\n    return position;\n  }\n\n  get scrollPosition(): number {\n    return this.routines.getScrollPosition(this.hostElement);\n  }\n\n  set scrollPosition(value: number) {\n    this.setPosition(value);\n  }\n\n  disableScrollForOneLoop(): void {\n    if (this.disabled) {\n      return;\n    }\n    const { style } = this.hostElement;\n    if (style.overflowY === 'hidden') {\n      return;\n    }\n    this.disabled = true;\n    const overflow = style.overflowY;\n    setTimeout(() => {\n      this.disabled = false;\n      style.overflowY = overflow;\n    });\n    style.overflowY = 'hidden';\n  }\n\n  getSize(): number {\n    return this.routines.getSize(this.hostElement, true);\n  }\n\n  getScrollableSize(): number {\n    return this.routines.getSize(this.element);\n  }\n\n  getBufferPadding(): number {\n    return this.getSize() * this.settings.padding;\n  }\n\n  getEdge(direction: Direction): number {\n    return this.routines.getEdge(this.hostElement, direction, true);\n  }\n\n  setOffset(): void {\n    this.offset = this.routines.getOffset(this.element);\n    if (!this.settings.windowViewport) {\n      this.offset -= this.routines.getOffset(this.hostElement);\n    }\n  }\n\n  getEdgeVisibleItem(items: Item[], direction: Direction): { item?: Item, index: number, diff: number } {\n    const bwd = direction === Direction.backward;\n    const opposite = bwd ? Direction.forward : Direction.backward;\n    const viewportEdge = this.getEdge(direction);\n    let item, diff = 0;\n    for (\n      let i = bwd ? 0 : items.length - 1;\n      bwd ? i <= items.length - 1 : i >= 0;\n      i += bwd ? 1 : -1\n    ) {\n      const itemEdge = this.routines.getEdge(items[i].element, opposite);\n      diff = itemEdge - viewportEdge;\n      if (bwd && diff > 0 || !bwd && diff < 0) {\n        item = items[i];\n        break;\n      }\n    }\n    return { item, index: item ? item.$index : NaN, diff };\n  }\n\n}\n","import { SizeStrategy } from '../../inputs/index';\n\ninterface ItemSize {\n  size: number;\n  newSize?: number;\n}\n\nexport class SizesRecalculation {\n  newItems: ItemSize[];\n  oldItems: ItemSize[];\n  removed: ItemSize[];\n\n  constructor() {\n    this.reset();\n  }\n\n  reset(): void {\n    this.newItems = [];\n    this.oldItems = [];\n    this.removed = [];\n  }\n}\n\nexport class DefaultSize {\n  private readonly itemSize: number;\n  private readonly sizeStrategy: SizeStrategy;\n  private sizeMap: Map<number, number>;\n  private recalculation: SizesRecalculation;\n\n  private constantSize: number;\n  private frequentSize: number;\n  private averageSize: number;\n  private averageSizeFloat: number;\n\n  constructor(itemSize: number, sizeStrategy: SizeStrategy) {\n    this.itemSize = itemSize;\n    this.sizeStrategy = sizeStrategy;\n    this.sizeMap = new Map<number, number>();\n    this.recalculation = new SizesRecalculation();\n  }\n\n  reset(force: boolean): void {\n    if (force) {\n      this.constantSize = this.itemSize;\n      this.frequentSize = this.itemSize;\n      this.averageSize = this.itemSize;\n      this.averageSizeFloat = this.itemSize;\n      this.sizeMap.clear();\n    }\n    this.recalculation.reset();\n  }\n\n  get(): number {\n    switch (this.sizeStrategy) {\n      case SizeStrategy.Average:\n        return this.averageSize;\n      case SizeStrategy.Frequent:\n        return this.frequentSize;\n      default:\n        return this.constantSize;\n    }\n  }\n\n  private recalculateAverageSize(cacheSize: number): void {\n    const { oldItems, newItems, removed } = this.recalculation;\n    if (oldItems.length) {\n      const oldSize = oldItems.reduce((acc, item) => acc + item.size, 0);\n      const newSize = oldItems.reduce((acc, item) => acc + (item.newSize as number), 0);\n      const averageSize = this.averageSizeFloat || 0;\n      this.averageSizeFloat = averageSize - (oldSize - newSize) / (cacheSize - newItems.length);\n    }\n    if (newItems.length) {\n      const newSize = newItems.reduce((acc, item) => acc + item.size, 0);\n      const averageSize = this.averageSizeFloat || 0;\n      this.averageSizeFloat = ((cacheSize - newItems.length) * averageSize + newSize) / cacheSize;\n    }\n    if (removed.length) {\n      const removedSize = removed.reduce((acc, item) => acc + item.size, 0);\n      const averageSize = this.averageSizeFloat || 0;\n      this.averageSizeFloat = ((cacheSize + removed.length) * averageSize - removedSize) / cacheSize;\n    }\n    this.averageSize = Math.round(this.averageSizeFloat);\n  }\n\n  private recalculateFrequentSize(): void {\n    const { oldItems, newItems, removed } = this.recalculation;\n    const oldFrequentSizeCount = this.sizeMap.get(this.frequentSize);\n    if (newItems.length) {\n      newItems.forEach(({ size }) => this.sizeMap.set(size, (this.sizeMap.get(size) || 0) + 1));\n    }\n    if (oldItems.length) {\n      oldItems.forEach(({ size }) => this.sizeMap.set(size, Math.max((this.sizeMap.get(size) || 0) - 1, 0)));\n      oldItems.forEach(({ newSize: s }) => this.sizeMap.set(s as number, (this.sizeMap.get(s as number) || 0) + 1));\n    }\n    if (removed.length) {\n      removed.forEach(({ size }) => this.sizeMap.set(size, Math.max((this.sizeMap.get(size) || 0) - 1, 0)));\n    }\n    const sorted = [...this.sizeMap.entries()].sort((a, b) => b[1] - a[1]);\n    const mostFrequentCount = sorted[0][1];\n    const listEqual = sorted.filter(i => i[1] === mostFrequentCount);\n    if (listEqual.length > 1 && listEqual.find(i => i[0] === oldFrequentSizeCount)) {\n      // if there are more than 1 most frequent sizes, but the old one is present\n      return;\n    }\n    this.frequentSize = sorted[0][0];\n  }\n\n  recalculate(cacheSize: number): boolean {\n    if (this.sizeStrategy === SizeStrategy.Constant) {\n      return false;\n    }\n    const { oldItems, newItems, removed } = this.recalculation;\n    if (!oldItems.length && !newItems.length && !removed.length) {\n      return false;\n    }\n    const oldValue = this.get();\n    if (this.sizeStrategy === SizeStrategy.Average) {\n      this.recalculateAverageSize(cacheSize);\n    } else {\n      this.recalculateFrequentSize();\n    }\n    this.recalculation.reset();\n    return this.get() !== oldValue;\n  }\n\n  setExisted(oldItem: ItemSize, newItem: ItemSize): void {\n    if (this.sizeStrategy !== SizeStrategy.Constant) {\n      this.recalculation.oldItems.push({\n        size: oldItem.size,\n        newSize: newItem.size\n      });\n    }\n  }\n\n  setNew(newItem: ItemSize): void {\n    if (this.sizeStrategy !== SizeStrategy.Constant) {\n      this.recalculation.newItems.push({\n        size: newItem.size\n      });\n    } else {\n      if (!this.constantSize) {\n        this.constantSize = newItem.size;\n      }\n    }\n  }\n\n  setRemoved(oldItem: ItemSize): void {\n    if (this.sizeStrategy !== SizeStrategy.Constant) {\n      this.recalculation.removed.push({\n        size: oldItem.size\n      });\n    }\n  }\n}\n","import { DefaultSize } from './defaultSize';\nimport { Item } from '../item';\nimport { Settings } from '../settings';\nimport { Logger } from '../logger';\nimport { SizeStrategy } from '../../inputs/index';\n\nexport class ItemCache<Data = unknown> {\n  $index: number;\n  nodeId: string;\n  data: Data | null;\n  size: number;\n  position: number;\n\n  constructor(item: Item<Data>, saveData: boolean) {\n    this.$index = item.$index;\n    this.nodeId = item.nodeId;\n    this.data = saveData ? item.data : null;\n    this.size = item.size;\n  }\n\n  changeIndex(value: number): void {\n    this.$index = value;\n    this.nodeId = String(value);\n  }\n}\n\nexport class Cache<Data = unknown> {\n  minIndex: number;\n  maxIndex: number;\n\n  readonly itemSize: number;\n  readonly saveData: boolean;\n  readonly cacheOnReload: boolean;\n  readonly sizeStrategy: SizeStrategy;\n  readonly logger: Logger;\n  private items: Map<number, ItemCache<Data>>;\n  private defaultSize: DefaultSize;\n\n  constructor({ itemSize, cacheData, cacheOnReload, sizeStrategy }: Settings, logger: Logger) {\n    this.itemSize = itemSize;\n    this.saveData = cacheData;\n    this.cacheOnReload = cacheOnReload;\n    this.sizeStrategy = sizeStrategy;\n    this.logger = logger;\n    this.items = new Map<number, ItemCache<Data>>();\n    this.defaultSize = new DefaultSize(itemSize, sizeStrategy);\n    this.reset(true);\n  }\n\n  reset(force: boolean): void {\n    force = force || !this.cacheOnReload;\n    if (force) {\n      this.minIndex = +Infinity;\n      this.maxIndex = -Infinity;\n      this.items.clear();\n    }\n    this.defaultSize.reset(force);\n  }\n\n  get size(): number {\n    return this.items.size;\n  }\n\n  get(index: number): ItemCache<Data> | undefined {\n    return this.items.get(index);\n  }\n\n  getItemSize(index: number): number {\n    const item = this.get(index);\n    return item ? item.size : 0;\n  }\n\n  getDefaultSize(): number {\n    return this.defaultSize.get();\n  }\n\n  recalculateDefaultSize(): boolean {\n    if (this.defaultSize.recalculate(this.size)) {\n      this.logger.log(() => `default size has been updated: ${this.defaultSize.get()}`);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Adds item to Set by $index, replaces existed item if $index matches.\n   * Maintains min/max indexes and default item size.\n   *\n   * @param {Item<Data>} item A Buffer item to be cached, an objects with { $index, data, size } props.\n   * \n   * @returns {ItemCache<Data>} Cached item.\n   */\n  add(item: Item<Data>): ItemCache<Data> {\n    let itemCache = this.get(item.$index);\n    if (itemCache) { // adding item is already cached\n      if (this.saveData) {\n        itemCache.data = item.data;\n      }\n      if (itemCache.size !== item.size) { // size changes\n        if (itemCache.size !== void 0) {\n          this.defaultSize.setExisted(itemCache, item);\n        } else {\n          this.defaultSize.setNew(item);\n        }\n        itemCache.size = item.size;\n      }\n    } else {\n      itemCache = new ItemCache<Data>(item, this.saveData);\n      this.items.set(item.$index, itemCache);\n      this.defaultSize.setNew(itemCache);\n    }\n    if (item.$index < this.minIndex) {\n      this.minIndex = item.$index;\n    }\n    if (item.$index > this.maxIndex) {\n      this.maxIndex = item.$index;\n    }\n    return itemCache;\n  }\n\n  /**\n   * Removes items from Set, shifts $indexes of items that remain.\n   * Replaces current Set with a new one with new regular $indexes.\n   * Maintains min/max indexes and default item size.\n   *\n   * @param {number[]} toRemove List of indexes to be removed.\n   * @param {boolean} fixRight Defines indexes shifting strategy.\n   * If false, indexes that are greater than the removed ones will be decreased.\n   * If true, indexes that are less than than the removed ones will be increased.\n   */\n  removeItems(toRemove: number[], fixRight: boolean): void {\n    const items = new Map<number, ItemCache<Data>>();\n    let min = Infinity, max = -Infinity;\n    this.items.forEach(item => {\n      if (toRemove.some(index => index === item.$index)) {\n        if (item.size !== void 0) {\n          this.defaultSize.setRemoved(item);\n        }\n        return;\n      }\n      const diff = fixRight\n        ? toRemove.reduce((acc, index) => acc + (item.$index < index ? 1 : 0), 0)\n        : toRemove.reduce((acc, index) => acc - (item.$index > index ? 1 : 0), 0);\n      item.changeIndex(item.$index + diff);\n      items.set(item.$index, item);\n      min = item.$index < min ? item.$index : min;\n      max = item.$index > max ? item.$index : max;\n    });\n    this.items = items;\n    this.minIndex = min;\n    this.maxIndex = max;\n  }\n\n  /**\n   * Destructively updates Set based on subset (before-after) changes.\n   * Replaces current Set with a new one with new regular $indexes.\n   * Maintains min/max indexes. Maintains default item size on remove only.\n   * Inserted and replaced items will be taken into account on Cache.add async calls after render.\n   *\n   * @param {number[]} before Initial subset of indexes to be replaced by \"after\". Must be incremental.\n   * @param {Item<Data>[]} after Transformed subset that replaces \"before\". Must be be $index-incremental.\n   * Must contain at least 1 $index from \"before\" or be empty.\n   * @param {boolean} fixRight This is to fix right indexes during subset collapsing. Acts only if \"after\" is empty.\n   */\n  updateSubset(before: number[], after: Item<Data>[], fixRight?: boolean): void {\n    if (!this.size || !before.length) {\n      return;\n    }\n    const minB = before[0], maxB = before[before.length - 1];\n    let leftDiff: number, rightDiff: number, found;\n    if (after.length) {\n      const minA = after[0].$index, maxA = after[after.length - 1].$index;\n      leftDiff = minA - minB;\n      rightDiff = maxA - maxB;\n    } else {\n      leftDiff = fixRight ? maxB - minB + 1 : 0;\n      rightDiff = fixRight ? 0 : minB - maxB - 1;\n    }\n    const items = new Map<number, ItemCache<Data>>();\n    this.items.forEach(item => {\n      if (item.$index < minB) { // items to the left of the subset\n        item.changeIndex(item.$index + leftDiff);\n        items.set(item.$index, item);\n        return;\n      } else if (item.$index > maxB) { // items to the right of the subset\n        item.changeIndex(item.$index + rightDiff);\n        items.set(item.$index, item);\n        return;\n      }\n    });\n    after.forEach(item => // subset items\n      items.set(item.$index, new ItemCache<Data>(item, this.saveData))\n    );\n    before.forEach(index => { // removed items immediately affect the default size\n      if (!after.some(({ $index }) => index === $index) && (found = this.get(index))) {\n        this.defaultSize.setRemoved(found);\n      }\n    });\n    this.minIndex += leftDiff;\n    this.maxIndex += rightDiff;\n    this.items = items;\n  }\n}\n","import { Cache } from './buffer/cache';\nimport { Item } from './item';\nimport { Settings } from './settings';\nimport { Logger } from './logger';\nimport { Reactive } from './reactive';\nimport { Direction } from '../inputs/index';\nimport { OnDataChanged, BufferUpdater } from '../interfaces/index';\n\nexport class Buffer<Data> {\n\n  private _items: Item<Data>[] = [];\n  private _absMinIndex: number;\n  private _absMaxIndex: number;\n  bof: Reactive<boolean>;\n  eof: Reactive<boolean>;\n\n  changeItems: OnDataChanged<Data>;\n  minIndexUser: number;\n  maxIndexUser: number;\n  startIndexUser: number;\n  startIndex: number;\n\n  private pristine: boolean;\n  private cache: Cache<Data>;\n  private readonly logger: Logger;\n\n  constructor(settings: Settings<Data>, onDataChanged: OnDataChanged<Data>, logger: Logger) {\n    this.logger = logger;\n    this.changeItems = onDataChanged;\n    this.bof = new Reactive<boolean>(false);\n    this.eof = new Reactive<boolean>(false);\n    this.cache = new Cache<Data>(settings, logger);\n    this.startIndexUser = settings.startIndex;\n    this.minIndexUser = settings.minIndex;\n    this.maxIndexUser = settings.maxIndex;\n    this.reset(true);\n  }\n\n  dispose(): void {\n    this.bof.dispose();\n    this.eof.dispose();\n    this._items.forEach(item => item.dispose());\n    this._items = [];\n  }\n\n  reset(force: boolean, startIndex?: number): void {\n    this.items.forEach(item => item.hide());\n    this.pristine = true;\n    this.items = [];\n    this.cache.reset(force);\n    this.absMinIndex = this.minIndexUser;\n    this.absMaxIndex = this.maxIndexUser;\n    this.setCurrentStartIndex(startIndex);\n    this.bof.set(false);\n    this.eof.set(false);\n    this.pristine = false;\n  }\n\n  setCurrentStartIndex(newStartIndex?: unknown): void {\n    const min = this.minIndexUser;\n    const max = this.maxIndexUser;\n    const start = this.startIndexUser;\n    let index = Number(newStartIndex);\n    if (Number.isNaN(index)) {\n      this.logger.log(() => `fallback startIndex to settings.startIndex (${start})`);\n      index = start;\n    }\n    if (index < min) {\n      this.logger.log(() => `setting startIndex to settings.minIndex (${min}) because ${index} < ${min}`);\n      index = min;\n    }\n    if (index > max) {\n      this.logger.log(() => `setting startIndex to settings.maxIndex (${max}) because ${index} > ${max}`);\n      index = max;\n    }\n    this.startIndex = index;\n  }\n\n  set items(items: Item<Data>[]) {\n    this._items = items;\n    this.changeItems(items);\n    if (!this.pristine) {\n      this.checkBOF();\n      this.checkEOF();\n    }\n  }\n\n  get items(): Item<Data>[] {\n    return this._items;\n  }\n\n  set absMinIndex(value: number) {\n    if (this._absMinIndex !== value) {\n      this._absMinIndex = Number.isFinite(this._absMaxIndex) && value > this._absMaxIndex ? this._absMaxIndex : value;\n    }\n    if (!this.pristine) {\n      this.checkBOF();\n    }\n  }\n\n  get absMinIndex(): number {\n    return this._absMinIndex;\n  }\n\n  set absMaxIndex(value: number) {\n    if (this._absMaxIndex !== value) {\n      this._absMaxIndex = Number.isFinite(this._absMinIndex) && value < this._absMinIndex ? this._absMinIndex : value;\n    }\n    if (!this.pristine) {\n      this.checkEOF();\n    }\n  }\n\n  get absMaxIndex(): number {\n    return this._absMaxIndex;\n  }\n\n  private checkBOF() {\n    // since bof has no setter, need to call checkBOF() on items and absMinIndex change\n    const bof = this.items.length\n      ? (this.items[0].$index === this.absMinIndex)\n      : isFinite(this.absMinIndex);\n    this.bof.set(bof);\n  }\n\n  private checkEOF() {\n    // since eof has no setter, need to call checkEOF() on items and absMaxIndex change\n    const eof = this.items.length\n      ? (this.items[this.items.length - 1].$index === this.absMaxIndex)\n      : isFinite(this.absMaxIndex);\n    this.eof.set(eof);\n  }\n\n  get size(): number {\n    return this._items.length;\n  }\n\n  get cacheSize(): number {\n    return this.cache.size;\n  }\n\n  get defaultSize(): number {\n    return this.cache.getDefaultSize();\n  }\n\n  get minIndex(): number {\n    return isFinite(this.cache.minIndex) ? this.cache.minIndex : this.startIndex;\n  }\n\n  get maxIndex(): number {\n    return isFinite(this.cache.maxIndex) ? this.cache.maxIndex : this.startIndex;\n  }\n\n  get firstIndex(): number {\n    return this.items.length ? this.items[0].$index : NaN;\n  }\n\n  get lastIndex(): number {\n    return this.items.length ? this.items[this.items.length - 1].$index : NaN;\n  }\n\n  get finiteAbsMinIndex(): number {\n    return isFinite(this.absMinIndex) ? this.absMinIndex : this.minIndex;\n  }\n\n  get finiteAbsMaxIndex(): number {\n    return isFinite(this.absMaxIndex) ? this.absMaxIndex : this.maxIndex;\n  }\n\n  get($index: number): Item<Data> | undefined {\n    return this.items.find(item => item.$index === $index);\n  }\n\n  setItems(items: Item<Data>[]): boolean {\n    if (!this.items.length) {\n      this.items = [...items];\n    } else if (this.items[0].$index > items[items.length - 1].$index) {\n      this.items = [...items, ...this.items];\n    } else if (items[0].$index > this.items[this.items.length - 1].$index) {\n      this.items = [...this.items, ...items];\n    } else {\n      return false;\n    }\n    return true;\n  }\n\n  clip(): void {\n    this.items = this.items.filter(({ toRemove }) => !toRemove);\n  }\n\n  append(items: Item<Data>[]): void {\n    this.items = [...this.items, ...items];\n  }\n\n  prepend(items: Item<Data>[]): void {\n    this.items = [...items, ...this.items];\n  }\n\n  private shiftExtremum(amount: number, fixRight: boolean) {\n    if (!fixRight) {\n      this.absMaxIndex += amount;\n    } else {\n      this.absMinIndex -= amount;\n      this.startIndex -= amount;\n    }\n    if (this.startIndex > this.absMaxIndex) {\n      this.startIndex = this.absMaxIndex;\n    } else if (this.startIndex < this.absMinIndex) {\n      this.startIndex = this.absMinIndex;\n    }\n  }\n\n  removeItems(indexes: number[], fixRight: boolean, virtual = false): void {\n    const result: Item<Data>[] = [];\n    const toRemove: number[] = virtual ? indexes : [];\n    const length = this.items.length;\n    let shifted = false;\n    for (\n      let i = fixRight ? length - 1 : 0;\n      fixRight ? i >= 0 : i < length;\n      fixRight ? i-- : i++\n    ) {\n      const item = this.items[i];\n      if (!virtual && indexes.indexOf(item.$index) >= 0) {\n        toRemove.push(item.$index);\n        continue;\n      }\n      const diff = toRemove.reduce((acc, index) => acc + (fixRight\n        ? (item.$index < index ? 1 : 0)\n        : (item.$index > index ? -1 : 0)\n      ), 0);\n      shifted = shifted || !!diff;\n      item.updateIndex(item.$index + diff);\n      if (!virtual) {\n        if (fixRight) {\n          result.unshift(item);\n        } else {\n          result.push(item);\n        }\n      }\n    }\n    this.shiftExtremum(-toRemove.length, fixRight);\n    if (!virtual) {\n      this.items = result;\n    } else if (shifted) {\n      this.items = [...this.items];\n    }\n    this.cache.removeItems(toRemove, fixRight);\n  }\n\n  updateItems(\n    predicate: BufferUpdater<Data>,\n    generator: (index: number, data: Data) => Item<Data>,\n    indexToTrack: number,\n    fixRight: boolean\n  ): number {\n    if (!this.size || Number.isNaN(this.firstIndex)) {\n      return NaN;\n    }\n    let _indexToTrack = indexToTrack;\n    let index = fixRight ? this.lastIndex : this.firstIndex;\n    const items: Item<Data>[] = [];\n    const diff = fixRight ? -1 : 1;\n    const initialIndexList = this.items.map(({ $index }) => $index);\n    (fixRight ? this.items.reverse() : this.items).forEach(item => {\n      const result = predicate(item);\n      // if predicate result is falsy or empty array -> delete\n      if (!result || (Array.isArray(result) && !result.length)) {\n        item.toRemove = true;\n        _indexToTrack += item.$index >= indexToTrack ? (fixRight ? 1 : 0) : (fixRight ? 0 : -1);\n        this.shiftExtremum(-1, fixRight);\n        return;\n      }\n      // if predicate result is truthy but not array -> leave\n      if (!Array.isArray(result)) {\n        item.updateIndex(index);\n        items.push(item);\n        index += diff;\n        return;\n      }\n      // if predicate result is non-empty array -> insert/replace\n      if (item.$index < indexToTrack) {\n        _indexToTrack += fixRight ? 0 : result.length - 1;\n      } else if (item.$index > indexToTrack) {\n        _indexToTrack += fixRight ? 1 - result.length : 0;\n      }\n      let toRemove = true;\n      const newItems: Item<Data>[] = [];\n      (fixRight ? [...result].reverse() : result).forEach((data, i) => {\n        let newItem: Item<Data>;\n        if (item.data === data) {\n          if (indexToTrack === item.$index) {\n            _indexToTrack = index + i * diff;\n          }\n          item.updateIndex(index + i * diff);\n          newItem = item;\n          toRemove = false; // insert case\n        } else {\n          newItem = generator(index + i * diff, data);\n          newItem.toInsert = true;\n        }\n        newItems.push(newItem);\n      });\n      item.toRemove = toRemove;\n      items.push(...newItems);\n      index += diff * result.length;\n      if (result.length > 1) {\n        this.shiftExtremum(result.length - 1, fixRight);\n      }\n    });\n    this.items = fixRight ? items.reverse() : items;\n    this.cache.updateSubset(initialIndexList, this.items, fixRight);\n\n    if (this.finiteAbsMinIndex === this.finiteAbsMaxIndex) {\n      _indexToTrack = NaN;\n    } else if (_indexToTrack > this.finiteAbsMaxIndex) {\n      _indexToTrack = this.finiteAbsMaxIndex;\n    } else if (_indexToTrack < this.finiteAbsMinIndex) {\n      _indexToTrack = this.finiteAbsMinIndex;\n    }\n    return _indexToTrack;\n  }\n\n  cacheItem(item: Item<Data>): void {\n    this.cache.add(item);\n  }\n\n  getFirstVisibleItemIndex(): number {\n    const length = this.items.length;\n    for (let i = 0; i < length; i++) {\n      if (!this.items[i].invisible) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  getLastVisibleItemIndex(): number {\n    for (let i = this.items.length - 1; i >= 0; i--) {\n      if (!this.items[i].invisible) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  getFirstVisibleItem(): Item<Data> | undefined {\n    const index = this.getFirstVisibleItemIndex();\n    if (index >= 0) {\n      return this.items[index];\n    }\n  }\n\n  getLastVisibleItem(): Item<Data> | undefined {\n    const index = this.getLastVisibleItemIndex();\n    if (index >= 0) {\n      return this.items[index];\n    }\n  }\n\n  getEdgeVisibleItem(direction: Direction, opposite?: boolean): Item<Data> | undefined {\n    return direction === (!opposite ? Direction.forward : Direction.backward) ?\n      this.getLastVisibleItem() : this.getFirstVisibleItem();\n  }\n\n  getVisibleItemsCount(): number {\n    return this.items.reduce((acc: number, item) => acc + (item.invisible ? 0 : 1), 0);\n  }\n\n  getSizeByIndex(index: number): number {\n    const item = this.cache.get(index);\n    return item ? item.size : this.defaultSize;\n  }\n\n  checkDefaultSize(): boolean {\n    return this.cache.recalculateDefaultSize();\n  }\n\n  getIndexToAppend(eof?: boolean): number {\n    return (!eof\n      ? (this.size ? this.items[this.size - 1].$index : this.maxIndex)\n      : this.absMaxIndex\n    ) + (this.size ? 1 : 0);\n  }\n\n  getIndexToPrepend(bof?: boolean): number {\n    return (!bof\n      ? (this.size ? this.items[0].$index : this.minIndex)\n      : this.absMinIndex\n    ) - (this.size ? 1 : 0);\n  }\n\n  getIndexToAdd(eof: boolean, prepend: boolean): number {\n    return prepend ? this.getIndexToPrepend(eof) : this.getIndexToAppend(eof);\n  }\n\n}\n","import { ProcessName } from '../../interfaces/index';\nimport { Reactive } from '../reactive';\n\nclass InnerLoopModel {\n  total: number;\n  count: number;\n  isInitial: boolean;\n  busy: Reactive<boolean>;\n\n  get first(): boolean {\n    return this.count === 0;\n  }\n\n  constructor(total: number) {\n    this.total = total;\n    this.isInitial = false;\n    this.busy = new Reactive<boolean>(false);\n  }\n\n  done() {\n    this.count++;\n    this.total++;\n    this.busy.set(false);\n  }\n\n  start() {\n    this.busy.set(true);\n  }\n\n  dispose() {\n    this.busy.dispose();\n  }\n}\n\nexport class WorkflowCycleModel {\n  instanceIndex: number;\n  count: number;\n  isInitial: boolean;\n  initiator: ProcessName;\n  innerLoop: InnerLoopModel;\n  interrupter: ProcessName | null;\n  busy: Reactive<boolean>;\n\n  get loopId(): string {\n    return `${this.instanceIndex}-${this.count}-${this.innerLoop.total}`;\n  }\n\n  get loopIdNext(): string {\n    return `${this.instanceIndex}-${this.count}-${this.innerLoop.total + 1}`;\n  }\n\n  constructor(instanceIndex: number, cycle?: WorkflowCycleModel) {\n    const cycleCount = cycle ? cycle.count : 1;\n    const loopCount = cycle ? cycle.innerLoop.count : 0;\n\n    this.instanceIndex = instanceIndex;\n    this.innerLoop = new InnerLoopModel(loopCount);\n    this.interrupter = null;\n    this.busy = new Reactive<boolean>(false);\n    this.done(cycleCount);\n  }\n\n  done(count: number): void {\n    this.count = count;\n    this.isInitial = false;\n    this.busy.set(false);\n  }\n\n  start(isInitial: boolean, initiator: ProcessName): void {\n    this.isInitial = isInitial;\n    this.initiator = initiator;\n    this.innerLoop.isInitial = isInitial;\n    this.innerLoop.count = 0;\n    this.interrupter = null;\n    this.busy.set(true);\n  }\n\n  dispose(forever?: boolean): void {\n    if (forever) {\n      // otherwise the value will be persisted during re-instantiation\n      this.busy.dispose();\n    }\n    this.innerLoop.dispose();\n  }\n}\n","import { Item } from '../item';\nimport { Direction } from '../../inputs/index';\n\nclass Positions {\n  startDelta: number;\n  before: number;\n  relative: number;\n  start: number;\n  end: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.startDelta = 0;\n    this.before = 0;\n  }\n}\n\nclass First {\n  index: number;\n  indexBuffer: number;\n  position: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.index = NaN;\n    this.indexBuffer = NaN;\n    this.position = NaN;\n  }\n}\n\nclass Last {\n  index: number;\n  indexBuffer: number;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.index = NaN;\n    this.indexBuffer = NaN;\n  }\n}\n\nexport class FetchModel {\n  private _newItemsData: unknown[] | null;\n\n  items: Item[];\n  positions: Positions;\n  first: First;\n  last: Last;\n  hasAnotherPack: boolean;\n  callCount: number;\n  minIndex: number;\n  firstVisibleIndex: number;\n  firstVisibleItemDelta: number;\n  negativeSize: number;\n  direction: Direction | null;\n  cancel: (() => void) | null;\n\n  simulate: boolean;\n  isPrepend: boolean;\n  isCheck: boolean;\n  doRemove: boolean;\n\n  constructor() {\n    this.callCount = 0;\n    this.positions = new Positions();\n    this.first = new First();\n    this.last = new Last();\n    this.reset();\n  }\n\n  reset(): void {\n    this._newItemsData = null;\n    this.items = [];\n    this.positions.reset();\n    this.first.reset();\n    this.last.reset();\n    this.hasAnotherPack = false;\n    this.firstVisibleIndex = NaN;\n    this.firstVisibleItemDelta = NaN;\n    this.negativeSize = 0;\n    this.direction = null;\n    this.cancel = null;\n    this.simulate = false;\n    this.isPrepend = false;\n    this.isCheck = false;\n    this.doRemove = false;\n  }\n\n  get newItemsData(): unknown[] | null {\n    return this._newItemsData;\n  }\n\n  set newItemsData(items: unknown[] | null) {\n    this._newItemsData = items;\n    if (items && items.length) {\n      this.callCount++;\n    }\n  }\n\n  get shouldFetch(): boolean {\n    return !!this.count;\n  }\n\n  get hasNewItems(): boolean {\n    return !!((this._newItemsData && this._newItemsData.length));\n  }\n\n  get index(): number {\n    return this.first.index;\n  }\n\n  get count(): number {\n    return !isNaN(this.first.index) && !isNaN(this.last.index) ? this.last.index - this.first.index + 1 : 0;\n  }\n\n  startSimulate(items: Item[]): void {\n    this.simulate = true;\n    this._newItemsData = items.map(item => item.data);\n    this.items = items;\n    this.hasAnotherPack = false;\n    this.negativeSize = 0;\n  }\n\n  stopSimulate(): void {\n    this.simulate = false;\n    this.isPrepend = false;\n    this.isCheck = false;\n    this.doRemove = false;\n  }\n\n  append(items: Item[]): void {\n    this.startSimulate(items);\n    this.last.index = items[items.length - 1].$index;\n    this.first.index = items[0].$index;\n    this.direction = Direction.forward;\n  }\n\n  prepend(items: Item[]): void {\n    this.startSimulate(items);\n    this.last.index = items[0].$index;\n    this.first.index = items[items.length - 1].$index;\n    this.direction = Direction.backward;\n    this.isPrepend = true;\n  }\n\n  check(items: Item[]): void {\n    this.startSimulate(items);\n    this.last.index = items[0].$index;\n    this.first.index = items[items.length - 1].$index;\n    this.isCheck = true;\n  }\n\n  remove(): void {\n    this.startSimulate([]);\n    this.doRemove = true;\n    // firstVisibleIndex & delta should be set inside process\n  }\n\n  update(index: number, delta: number, items: Item[], itemsToRemove: Item[]): void {\n    this.startSimulate(items);\n    this.firstVisibleIndex = index;\n    this.firstVisibleItemDelta = delta;\n    this.doRemove = itemsToRemove.length > 0;\n  }\n}\n","export class ClipModel {\n  doClip: boolean;\n  callCount: number;\n  forceForward: boolean;\n  forceBackward: boolean;\n\n  get force(): boolean {\n    return this.forceForward || this.forceBackward;\n  }\n\n  constructor() {\n    this.callCount = 0;\n    this.reset();\n  }\n\n  reset(force?: boolean): void {\n    this.doClip = false;\n    if (!force) {\n      this.forceForward = false;\n      this.forceBackward = false;\n    }\n  }\n\n}\n","export class RenderModel {\n  sizeBefore: number;\n  sizeAfter: number;\n  positionBefore: number;\n  renderTimer: ReturnType<typeof setTimeout> | null;\n\n  get noSize(): boolean {\n    return this.sizeBefore === this.sizeAfter;\n  }\n\n  constructor() {\n    this.reset();\n  }\n\n  reset(): void {\n    this.sizeBefore = 0;\n    this.sizeAfter = 0;\n    this.positionBefore = 0;\n    this.renderTimer = null;\n  }\n}\n","import {\n  ScrollEventData as IScrollEventData,\n  ScrollState as IScrollState\n} from '../../interfaces/index';\n\nexport class ScrollState implements IScrollState {\n  previous: IScrollEventData | null;\n  current: IScrollEventData | null;\n\n  scrollTimer: ReturnType<typeof setTimeout> | null;\n\n  syntheticPosition: number | null;\n  syntheticFulfill: boolean;\n  animationFrameId: number;\n  positionBeforeAsync: number | null;\n  positionBeforeAdjust: number | null;\n  positionAfterAdjust: number | null;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset(): void {\n    this.previous = null;\n    this.current = null;\n    this.syntheticPosition = null;\n    this.syntheticFulfill = false;\n    this.positionBeforeAsync = null;\n    this.positionBeforeAdjust = null;\n    this.positionAfterAdjust = null;\n    this.cleanupTimers();\n  }\n\n  cleanupTimers(): void {\n    if (this.scrollTimer) {\n      clearTimeout(this.scrollTimer);\n      this.scrollTimer = null;\n    }\n    if (this.animationFrameId) {\n      cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = 0;\n    }\n  }\n\n  hasPositionChanged(position: number): boolean {\n    const before = this.positionBeforeAdjust;\n    const after = this.positionAfterAdjust;\n    return before === null || before !== position || after === null || after !== position;\n  }\n}\n","import { Settings } from './settings';\r\nimport { WorkflowCycleModel } from './state/cycle';\r\nimport { FetchModel } from './state/fetch';\r\nimport { ClipModel } from './state/clip';\r\nimport { RenderModel } from './state/render';\r\nimport { ScrollState } from './state/scroll';\r\nimport { State as IState, IPackages, ScrollState as IScrollState, ProcessName } from '../interfaces/index';\r\n\r\nexport class State implements IState {\r\n\r\n  readonly packageInfo: IPackages;\r\n  private settings: Settings;\r\n\r\n  initTime: number;\r\n\r\n  cycle: WorkflowCycleModel;\r\n\r\n  fetch: FetchModel;\r\n  clip: ClipModel;\r\n  render: RenderModel;\r\n\r\n  scrollState: IScrollState;\r\n\r\n  get time(): number {\r\n    return Number(new Date()) - this.initTime;\r\n  }\r\n\r\n  constructor(packageInfo: IPackages, settings: Settings, state?: IState) {\r\n    this.packageInfo = packageInfo;\r\n    this.settings = settings;\r\n\r\n    this.initTime = Number(new Date());\r\n\r\n    this.cycle = new WorkflowCycleModel(this.settings.instanceIndex, state ? state.cycle : void 0);\r\n\r\n    this.fetch = new FetchModel();\r\n    this.clip = new ClipModel();\r\n    this.render = new RenderModel();\r\n\r\n    this.scrollState = new ScrollState();\r\n  }\r\n\r\n  endInnerLoop(): void {\r\n    const { fetch, render, cycle } = this;\r\n    if (fetch.cancel) {\r\n      fetch.cancel();\r\n      fetch.cancel = null;\r\n    }\r\n    if (render.renderTimer) {\r\n      clearTimeout(render.renderTimer);\r\n      render.renderTimer = null;\r\n    }\r\n    cycle.innerLoop.done();\r\n  }\r\n\r\n  startInnerLoop(): { process?: ProcessName, doRender?: boolean } {\r\n    const { cycle, scrollState: scroll, fetch, render, clip } = this;\r\n\r\n    cycle.innerLoop.start();\r\n    scroll.positionBeforeAsync = null;\r\n\r\n    if (!fetch.simulate) {\r\n      fetch.reset();\r\n    }\r\n    clip.reset(clip.force);\r\n    render.reset();\r\n\r\n    return {\r\n      ...(cycle.innerLoop.first ? {\r\n        process: cycle.initiator,\r\n        doRender: fetch.simulate && fetch.items.length > 0\r\n      } : {})\r\n    };\r\n  }\r\n\r\n  dispose(): void {\r\n    this.cycle.dispose();\r\n    this.endInnerLoop();\r\n    this.scrollState.cleanupTimers();\r\n  }\r\n\r\n}\r\n","import { Logger } from './logger';\r\nimport { Buffer } from './buffer';\r\nimport { Reactive } from './reactive';\r\nimport {\r\n  AdapterPropName, AdapterPropType, getDefaultAdapterProps, methodPreResult, reactiveConfigStorage\r\n} from './adapter/props';\r\nimport { AdapterProcess, ProcessStatus } from '../processes/index';\r\nimport {\r\n  WorkflowGetter,\r\n  IAdapterProp,\r\n  AdapterMethodResult,\r\n  IAdapter,\r\n  ItemAdapter,\r\n  ItemsPredicate,\r\n  AdapterPrependOptions,\r\n  AdapterAppendOptions,\r\n  AdapterRemoveOptions,\r\n  AdapterClipOptions,\r\n  AdapterInsertOptions,\r\n  AdapterReplaceOptions,\r\n  AdapterUpdateOptions,\r\n  AdapterFixOptions,\r\n  ScrollerWorkflow,\r\n  IDatasourceOptional,\r\n  IPackages,\r\n  IBufferInfo,\r\n  State,\r\n  ProcessSubject,\r\n} from '../interfaces/index';\r\n\r\ntype MethodResolver = (...args: any[]) => Promise<AdapterMethodResult>;\r\n\r\nconst ADAPTER_PROPS_STUB = getDefaultAdapterProps();\r\n\r\nconst _has = (obj: unknown, prop: string): boolean =>\r\n  typeof obj === 'object' && obj !== null && Object.prototype.hasOwnProperty.call(obj, prop);\r\n\r\nconst convertAppendArgs = <Item>(prepend: boolean, options: unknown, eof?: boolean) => {\r\n  let result = options as AdapterAppendOptions<Item> & AdapterPrependOptions<Item>;\r\n  if (!_has(options, 'items')) {\r\n    const items = !Array.isArray(options) ? [options] : options;\r\n    result = prepend ? { items, bof: eof } : { items, eof: eof };\r\n  }\r\n  return result;\r\n};\r\n\r\nconst convertRemoveArgs = <Item>(options: AdapterRemoveOptions<Item> | ItemsPredicate<Item>) => {\r\n  if (!(_has(options, 'predicate') || _has(options, 'indexes'))) {\r\n    const predicate = options as ItemsPredicate<Item>;\r\n    options = { predicate };\r\n  }\r\n  return options;\r\n};\r\n\r\nexport class Adapter<Item = unknown> implements IAdapter<Item> {\r\n  private externalContext: IAdapter<Item>;\r\n  private logger: Logger;\r\n  private getWorkflow: WorkflowGetter<Item>;\r\n  private reloadCounter: number;\r\n  private source: { [key: string]: Reactive<unknown> } = {}; // for Reactive props\r\n  private box: { [key: string]: unknown } = {}; // for Scalars over Reactive props\r\n  private demand: { [key: string]: unknown } = {}; // for Scalars on demand\r\n  public wanted: { [key: string]: boolean } = {};\r\n\r\n  get workflow(): ScrollerWorkflow<Item> {\r\n    return this.getWorkflow();\r\n  }\r\n  get reloadCount(): number {\r\n    return this.reloadCounter;\r\n  }\r\n  get reloadId(): string {\r\n    return this.id + '.' + this.reloadCounter;\r\n  }\r\n\r\n  id: number;\r\n  mock: boolean;\r\n  augmented: boolean;\r\n  version: string;\r\n  init: boolean;\r\n  init$: Reactive<boolean>;\r\n  packageInfo: IPackages;\r\n  itemsCount: number;\r\n  bufferInfo: IBufferInfo;\r\n  isLoading: boolean;\r\n  isLoading$: Reactive<boolean>;\r\n  loopPending: boolean;\r\n  loopPending$: Reactive<boolean>;\r\n  firstVisible: ItemAdapter<Item>;\r\n  firstVisible$: Reactive<ItemAdapter<Item>>;\r\n  lastVisible: ItemAdapter<Item>;\r\n  lastVisible$: Reactive<ItemAdapter<Item>>;\r\n  bof: boolean;\r\n  bof$: Reactive<boolean>;\r\n  eof: boolean;\r\n  eof$: Reactive<boolean>;\r\n\r\n  private relax$: Reactive<AdapterMethodResult> | null;\r\n  private relaxRun: Promise<AdapterMethodResult> | null;\r\n\r\n  private getPromisifiedMethod(method: MethodResolver, defaultMethod: MethodResolver) {\r\n    return (...args: any[]): Promise<AdapterMethodResult> =>\r\n      this.relax$\r\n        ? new Promise(resolve => {\r\n          if (this.relax$) {\r\n            this.relax$.once(value => resolve(value));\r\n          }\r\n          method.apply(this, args);\r\n        })\r\n        : defaultMethod.apply(this, args);\r\n  }\r\n\r\n  constructor(context: IAdapter<Item> | null, getWorkflow: WorkflowGetter<Item>, logger: Logger) {\r\n    this.getWorkflow = getWorkflow;\r\n    this.logger = logger;\r\n    this.relax$ = null;\r\n    this.relaxRun = null;\r\n    this.reloadCounter = 0;\r\n\r\n    // public context (if exists) should provide access Reactive props configuration by id\r\n    const reactivePropsStore = context && reactiveConfigStorage.get(context.id) || {};\r\n\r\n    // make array of the original values from public context if present\r\n    const adapterProps = context\r\n      ? ADAPTER_PROPS_STUB.map(prop => {\r\n        let value = context[prop.name];\r\n        // if context is augmented, we need to replace external reactive props with inner ones\r\n        if (context.augmented) {\r\n          const reactiveProp = reactivePropsStore[prop.name];\r\n          if (reactiveProp) {\r\n            value = reactiveProp.default as Reactive<boolean>; // boolean doesn't matter here\r\n          }\r\n        }\r\n        return ({ ...prop, value });\r\n      })\r\n      : getDefaultAdapterProps();\r\n\r\n    // restore default reactive props if they were configured\r\n    Object.entries(reactivePropsStore).forEach(([key, value]) => {\r\n      const prop = adapterProps.find(({ name }) => name === key);\r\n      if (prop && value) {\r\n        prop.value = value.default;\r\n      }\r\n    });\r\n\r\n    // Scalar permanent props\r\n    adapterProps\r\n      .filter(({ type, permanent }) => type === AdapterPropType.Scalar && permanent)\r\n      .forEach(({ name, value }: IAdapterProp) =>\r\n        Object.defineProperty(this, name, {\r\n          configurable: true,\r\n          get: () => value\r\n        })\r\n      );\r\n\r\n    // Reactive props\r\n    // 1) store original values in \"source\" container, to avoid extra .get() calls on scalar twins set\r\n    // 2) \"wanted\" container is bound with scalars; get() updates it\r\n    adapterProps\r\n      .filter(prop => prop.type === AdapterPropType.Reactive)\r\n      .forEach(({ name, value }: IAdapterProp) => {\r\n        this.source[name] = value as Reactive<unknown>;\r\n        Object.defineProperty(this, name, {\r\n          configurable: true,\r\n          get: () => {\r\n            const scalarWanted = ADAPTER_PROPS_STUB.find(\r\n              ({ wanted, reactive }) => wanted && reactive === name\r\n            );\r\n            if (scalarWanted) {\r\n              this.wanted[scalarWanted.name] = true;\r\n            }\r\n            return this.source[name];\r\n          }\r\n        });\r\n      });\r\n\r\n    // Scalar props that have Reactive twins\r\n    // 1) scalars should use \"box\" container\r\n    // 2) \"wanted\" should be updated on get\r\n    // 3) reactive props (from \"source\") are triggered on set\r\n    adapterProps\r\n      .filter(prop => prop.type === AdapterPropType.Scalar && !!prop.reactive)\r\n      .forEach(({ name, value, reactive, wanted }: IAdapterProp) => {\r\n        if (wanted) {\r\n          this.wanted[name] = false;\r\n        }\r\n        this.box[name] = value;\r\n        Object.defineProperty(this, name, {\r\n          configurable: true,\r\n          set: (newValue: unknown) => {\r\n            if (newValue !== this.box[name]) {\r\n              this.box[name] = newValue;\r\n              this.source[reactive as AdapterPropName].set(newValue);\r\n              // need to emit new value through the configured reactive prop if present\r\n              const reactiveProp = reactivePropsStore[reactive as AdapterPropName];\r\n              if (reactiveProp) {\r\n                reactiveProp.emit(reactiveProp.source, newValue);\r\n              }\r\n            }\r\n          },\r\n          get: () => {\r\n            if (wanted) {\r\n              this.wanted[name] = true;\r\n            }\r\n            return this.box[name];\r\n          }\r\n        });\r\n      });\r\n\r\n    // Scalar props on-demand\r\n    // these scalars should use \"demand\" container\r\n    // setting defaults should be overridden on init()\r\n    adapterProps\r\n      .filter(prop => prop.type === AdapterPropType.Scalar && prop.onDemand)\r\n      .forEach(({ name, value }: IAdapterProp) => {\r\n        this.demand[name] = value;\r\n        Object.defineProperty(this, name, {\r\n          configurable: true,\r\n          get: () => this.demand[name]\r\n        });\r\n      });\r\n\r\n    if (!context) {\r\n      return;\r\n    }\r\n\r\n    // Adapter public context augmentation\r\n    adapterProps\r\n      .forEach(({ name, type, value: defaultValue, permanent }: IAdapterProp) => {\r\n        let value = (this as IAdapter)[name];\r\n        if (type === AdapterPropType.Function) {\r\n          value = (value as () => void).bind(this);\r\n        } else if (type === AdapterPropType.WorkflowRunner) {\r\n          value = this.getPromisifiedMethod(value as MethodResolver, defaultValue as MethodResolver);\r\n        } else if (type === AdapterPropType.Reactive && reactivePropsStore[name]) {\r\n          value = (context as IAdapter)[name];\r\n        } else if (name === AdapterPropName.augmented) {\r\n          value = true;\r\n        }\r\n        Object.defineProperty(context, name, {\r\n          configurable: true,\r\n          get: () => !permanent && type === AdapterPropType.Scalar\r\n            ? (this as IAdapter)[name] // non-permanent Scalars should be taken in runtime\r\n            : value // Reactive props and methods (Functions/WorkflowRunners) can be defined once\r\n        });\r\n      });\r\n\r\n    this.externalContext = context;\r\n  }\r\n\r\n  initialize(buffer: Buffer<Item>, state: State, logger: Logger, adapterRun$?: Reactive<ProcessSubject>): void {\r\n    // buffer\r\n    Object.defineProperty(this.demand, AdapterPropName.itemsCount, {\r\n      get: () => buffer.getVisibleItemsCount()\r\n    });\r\n    Object.defineProperty(this.demand, AdapterPropName.bufferInfo, {\r\n      get: (): IBufferInfo => ({\r\n        firstIndex: buffer.firstIndex,\r\n        lastIndex: buffer.lastIndex,\r\n        minIndex: buffer.minIndex,\r\n        maxIndex: buffer.maxIndex,\r\n        absMinIndex: buffer.absMinIndex,\r\n        absMaxIndex: buffer.absMaxIndex,\r\n        defaultSize: buffer.defaultSize,\r\n      })\r\n    });\r\n    this.bof = buffer.bof.get();\r\n    buffer.bof.on(bof => this.bof = bof);\r\n    this.eof = buffer.eof.get();\r\n    buffer.eof.on(eof => this.eof = eof);\r\n\r\n    // state\r\n    Object.defineProperty(this.demand, AdapterPropName.packageInfo, {\r\n      get: () => state.packageInfo\r\n    });\r\n    this.loopPending = state.cycle.innerLoop.busy.get();\r\n    state.cycle.innerLoop.busy.on(busy => this.loopPending = busy);\r\n    this.isLoading = state.cycle.busy.get();\r\n    state.cycle.busy.on(busy => this.isLoading = busy);\r\n\r\n    // logger\r\n    this.logger = logger;\r\n\r\n    // self-pending subscription; set up only on the very first init\r\n    if (adapterRun$) {\r\n      if (!this.relax$) {\r\n        this.relax$ = new Reactive();\r\n      }\r\n      const relax$ = this.relax$;\r\n      adapterRun$.on(({ status, payload }) => {\r\n        let unSubRelax = () => { };\r\n        if (status === ProcessStatus.start) {\r\n          unSubRelax = this.isLoading$.on(value => {\r\n            if (!value) {\r\n              unSubRelax();\r\n              relax$.set({ success: true, immediate: false, details: null });\r\n            }\r\n          });\r\n        } else if (status === ProcessStatus.done || status === ProcessStatus.error) {\r\n          unSubRelax();\r\n          relax$.set({\r\n            success: status !== ProcessStatus.error,\r\n            immediate: true,\r\n            details: status === ProcessStatus.error && payload ? String(payload.error) : null\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    // init\r\n    this.init = true;\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.relax$) {\r\n      this.relax$.dispose();\r\n    }\r\n    if (this.externalContext) {\r\n      this.resetContext();\r\n    }\r\n    Object.getOwnPropertyNames(this).forEach(prop => {\r\n      delete (this as Record<string, unknown>)[prop];\r\n    });\r\n  }\r\n\r\n  resetContext(): void {\r\n    const reactiveStore = reactiveConfigStorage.get(this.externalContext.id);\r\n    ADAPTER_PROPS_STUB\r\n      .forEach(({ type, permanent, name, value }) => {\r\n        // assign initial values to non-reactive non-permanent props\r\n        if (type !== AdapterPropType.Reactive && !permanent) {\r\n          Object.defineProperty(this.externalContext, name, {\r\n            configurable: true,\r\n            get: () => value\r\n          });\r\n        }\r\n        // reset reactive props\r\n        if (type === AdapterPropType.Reactive && reactiveStore) {\r\n          const property = reactiveStore[name];\r\n          if (property) {\r\n            property.default.reset();\r\n            property.emit(property.source, property.default.get());\r\n          }\r\n        }\r\n      });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  reset(options?: IDatasourceOptional): any {\r\n    this.reloadCounter++;\r\n    this.logger.logAdapterMethod('reset', options, ` of ${this.reloadId}`);\r\n    this.workflow.call({\r\n      process: AdapterProcess.reset,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  reload(options?: number | string): any {\r\n    this.reloadCounter++;\r\n    this.logger.logAdapterMethod('reload', options, ` of ${this.reloadId}`);\r\n    this.workflow.call({\r\n      process: AdapterProcess.reload,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  append(_options: AdapterAppendOptions<Item> | unknown, eof?: boolean): any {\r\n    const options = convertAppendArgs(false, _options, eof); // support old signature\r\n    this.logger.logAdapterMethod('append', [options.items, options.eof]);\r\n    this.workflow.call({\r\n      process: AdapterProcess.append,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  prepend(_options: AdapterPrependOptions<Item> | unknown, bof?: boolean): any {\r\n    const options = convertAppendArgs(true, _options, bof); // support old signature\r\n    this.logger.logAdapterMethod('prepend', [options.items, options.bof]);\r\n    this.workflow.call({\r\n      process: AdapterProcess.prepend,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  check(): any {\r\n    this.logger.logAdapterMethod('check');\r\n    this.workflow.call({\r\n      process: AdapterProcess.check,\r\n      status: ProcessStatus.start\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  remove(options: AdapterRemoveOptions<Item> | ItemsPredicate<Item>): any {\r\n    options = convertRemoveArgs(options); // support old signature\r\n    this.logger.logAdapterMethod('remove', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.remove,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  clip(options?: AdapterClipOptions): any {\r\n    this.logger.logAdapterMethod('clip', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.clip,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  insert(options: AdapterInsertOptions<Item>): any {\r\n    this.logger.logAdapterMethod('insert', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.insert,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  replace(options: AdapterReplaceOptions<Item>): any {\r\n    this.logger.logAdapterMethod('replace', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.replace,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  update(options: AdapterUpdateOptions<Item>): any {\r\n    this.logger.logAdapterMethod('update', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.update,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  fix(options: AdapterFixOptions<Item>): any {\r\n    this.logger.logAdapterMethod('fix', options);\r\n    this.workflow.call({\r\n      process: AdapterProcess.fix,\r\n      status: ProcessStatus.start,\r\n      payload: { options }\r\n    });\r\n  }\r\n\r\n  relaxUnchained(callback: (() => void) | undefined, reloadId: string): Promise<AdapterMethodResult> {\r\n    const runCallback = () => typeof callback === 'function' && reloadId === this.reloadId && callback();\r\n    if (!this.isLoading) {\r\n      runCallback();\r\n    }\r\n    return new Promise<boolean>(resolve => {\r\n      if (!this.isLoading) {\r\n        resolve(true);\r\n        return;\r\n      }\r\n      this.isLoading$.once(() => {\r\n        runCallback();\r\n        resolve(false);\r\n      });\r\n    }).then(immediate => {\r\n      const success = reloadId === this.reloadId;\r\n      this.logger.log(() => !success ? `relax promise cancelled due to ${reloadId} != ${this.reloadId}` : void 0);\r\n      return {\r\n        immediate,\r\n        success,\r\n        details: !success ? 'Interrupted by reload or reset' : null\r\n      };\r\n    });\r\n  }\r\n\r\n  relax(callback?: () => void): Promise<AdapterMethodResult> {\r\n    const reloadId = this.reloadId;\r\n    this.logger.logAdapterMethod('relax', callback, ` of ${reloadId}`);\r\n    if (!this.init) {\r\n      return Promise.resolve(methodPreResult);\r\n    }\r\n    return this.relaxRun = this.relaxRun\r\n      ? this.relaxRun.then(() => this.relaxUnchained(callback, reloadId))\r\n      : this.relaxUnchained(callback, reloadId).then((result) => {\r\n        this.relaxRun = null;\r\n        return result;\r\n      });\r\n  }\r\n\r\n  showLog(): void {\r\n    this.logger.logAdapterMethod('showLog');\r\n    this.logger.logForce();\r\n  }\r\n}\r\n","import { DatasourceGeneric, makeDatasource } from './classes/datasource';\nimport { Settings } from './classes/settings';\nimport { Logger } from './classes/logger';\nimport { Routines } from './classes/domRoutines';\nimport { Viewport } from './classes/viewport';\nimport { Buffer } from './classes/buffer';\nimport { State } from './classes/state';\nimport { Adapter } from './classes/adapter';\nimport { Reactive } from './classes/reactive';\nimport { validate, DATASOURCE } from './inputs/index';\nimport core from './version';\nimport {\n  ScrollerWorkflow, IDatasource, IDatasourceConstructed, ScrollerParams, IPackages, ProcessSubject\n} from './interfaces/index';\n\nexport const INVALID_DATASOURCE_PREFIX = 'Invalid datasource:';\n\nlet instanceCount = 0;\n\nexport class Scroller<Data = unknown> {\n  public datasource: IDatasourceConstructed<Data>;\n  public workflow: ScrollerWorkflow<Data>;\n\n  public settings: Settings<Data>;\n  public logger: Logger;\n  public routines: Routines;\n  public viewport: Viewport;\n  public buffer: Buffer<Data>;\n  public state: State;\n  public adapter: Adapter<Data>;\n\n  constructor({ datasource, consumer, element, workflow, scroller }: ScrollerParams<Data>) {\n    const { params: { get } } = validate(datasource, DATASOURCE);\n    if (!get.isValid) {\n      throw new Error(`${INVALID_DATASOURCE_PREFIX} ${get.errors[0]}`);\n    }\n\n    const packageInfo = scroller ? scroller.state.packageInfo : ({ consumer, core } as IPackages);\n    element = scroller ? scroller.viewport.element : (element as HTMLElement);\n    workflow = scroller ? scroller.workflow : (workflow as ScrollerWorkflow<Data>);\n\n    this.workflow = workflow;\n    this.settings = new Settings<Data>(datasource.settings, datasource.devSettings, ++instanceCount);\n    this.logger = new Logger(this as Scroller, packageInfo, datasource.adapter);\n    this.routines = new Routines(this.settings);\n    this.state = new State(packageInfo, this.settings, scroller ? scroller.state : void 0);\n    this.buffer = new Buffer<Data>(this.settings, workflow.onDataChanged, this.logger);\n    this.viewport = new Viewport(element, this.settings, this.routines, this.state, this.logger);\n    this.logger.object('vscroll settings object', this.settings, true);\n\n    this.initDatasource(datasource, scroller);\n  }\n\n  initDatasource(datasource: IDatasource<Data>, scroller?: Scroller<Data>): void {\n    if (scroller) { // scroller re-instantiating case\n      this.datasource = datasource as IDatasourceConstructed<Data>;\n      this.adapter = scroller.adapter;\n      // todo: what about (this.settings.adapter !== scroller.setting.adapter) case?\n      return;\n    }\n    // scroller is being instantiated for the first time\n    const constructed = datasource instanceof DatasourceGeneric;\n    const mockAdapter = !constructed && !this.settings.adapter;\n    if (constructed) { // datasource is already instantiated\n      this.datasource = datasource as IDatasourceConstructed<Data>;\n    } else { // datasource as POJO\n      const DS = makeDatasource(() => ({ mock: mockAdapter }));\n      this.datasource = new DS<Data>(datasource);\n      if (this.settings.adapter) {\n        datasource.adapter = this.datasource.adapter;\n      }\n    }\n    const publicContext = !mockAdapter ? this.datasource.adapter : null;\n    this.adapter = new Adapter<Data>(publicContext, () => this.workflow, this.logger);\n  }\n\n  init(adapterRun$?: Reactive<ProcessSubject>): void {\n    this.viewport.reset(this.buffer.startIndex);\n    this.logger.stat('initialization');\n    this.adapter.initialize(this.buffer, this.state, this.logger, adapterRun$);\n  }\n\n  dispose(forever?: boolean): void {\n    if (forever) { // Adapter is not re-instantiated on reset\n      this.adapter.dispose();\n    }\n    this.buffer.dispose();\n    this.state.dispose();\n  }\n\n  finalize(): void {\n  }\n\n}\n","import {\n  CommonProcess,\n  AdapterProcess,\n  ProcessStatus as Status,\n  Init,\n  Scroll,\n  Reset,\n  Reload,\n  Append,\n  Check,\n  Remove,\n  UserClip,\n  Insert,\n  Replace,\n  Update,\n  Fix,\n  Start,\n  PreFetch,\n  Fetch,\n  PostFetch,\n  Render,\n  PreClip,\n  Clip,\n  Adjust,\n  End,\n} from './processes/index';\n\nimport { StateMachineParams } from './interfaces/index';\n\nexport const runStateMachine = ({\n  input: { process, status, payload = {} },\n  methods: { run, interrupt, done, onError }\n}: StateMachineParams): void => {\n  if (status === Status.error) {\n    onError(process, payload);\n    if (!process.startsWith('adapter')) {\n      run(End)(payload);\n    }\n    return;\n  }\n  const { options } = payload;\n  switch (process) {\n    case CommonProcess.init:\n      if (status === Status.start) { // App start\n        run(Init)(process);\n      }\n      if (status === Status.next) {\n        run(Start)();\n      }\n      break;\n    case CommonProcess.scroll:\n      if (status === Status.start) {\n        run(Scroll)(payload);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.reset:\n    case AdapterProcess.reload:\n      if (status === Status.start) {\n        if (process === AdapterProcess.reset) {\n          run(Reset)(options);\n        } else {\n          run(Reload)(options);\n        }\n      }\n      if (status === Status.next) {\n        interrupt({ process, ...payload });\n        if (payload.finalize) {\n          run(End)();\n        } else {\n          run(Init)(process);\n        }\n      }\n      break;\n    case AdapterProcess.append:\n    case AdapterProcess.prepend:\n      if (status === Status.start) {\n        run(Append)({ process, options });\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.check:\n      if (status === Status.start) {\n        run(Check)();\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.remove:\n      if (status === Status.start) {\n        run(Remove)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.clip:\n      if (status === Status.start) {\n        run(UserClip)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.insert:\n      if (status === Status.start) {\n        run(Insert)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.replace:\n      if (status === Status.start) {\n        run(Replace)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.update:\n      if (status === Status.start) {\n        run(Update)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case AdapterProcess.fix:\n      if (status === Status.start) {\n        run(Fix)(options);\n      }\n      if (status === Status.next) {\n        run(Init)(process);\n      }\n      break;\n    case CommonProcess.start:\n      switch (payload.process) {\n        case AdapterProcess.append:\n        case AdapterProcess.check:\n        case AdapterProcess.insert:\n          run(Render)();\n          break;\n        case AdapterProcess.remove:\n          run(Adjust)();\n          break;\n        case AdapterProcess.replace:\n        case AdapterProcess.update:\n          if (payload.doRender) {\n            run(Render)();\n          } else {\n            run(Adjust)();\n          }\n          break;\n        default:\n          run(PreFetch)();\n      }\n      break;\n    case CommonProcess.preFetch:\n      if (status === Status.next) {\n        switch (payload.process) {\n          case AdapterProcess.clip:\n            run(PreClip)();\n            break;\n          default:\n            run(Fetch)();\n        }\n      }\n      if (status === Status.done) {\n        run(End)();\n      }\n      break;\n    case CommonProcess.fetch:\n      run(PostFetch)();\n      break;\n    case CommonProcess.postFetch:\n      if (status === Status.next) {\n        run(Render)();\n      }\n      if (status === Status.done) {\n        run(End)();\n      }\n      break;\n    case CommonProcess.render:\n      if (status === Status.next) {\n        switch (payload.process) {\n          case AdapterProcess.append:\n          case AdapterProcess.check:\n          case AdapterProcess.insert:\n          case AdapterProcess.replace:\n          case AdapterProcess.update:\n            run(Adjust)();\n            break;\n          default:\n            run(PreClip)();\n        }\n      }\n      if (status === Status.done) {\n        run(End)();\n      }\n      break;\n    case CommonProcess.preClip:\n      if (payload.doClip) {\n        run(Clip)();\n      } else {\n        run(Adjust)();\n      }\n      break;\n    case CommonProcess.clip:\n      run(Adjust)();\n      break;\n    case CommonProcess.adjust:\n      run(End)();\n      break;\n    case CommonProcess.end:\n      if (status === Status.next) {\n        switch (payload.process) {\n          case AdapterProcess.reset:\n          case AdapterProcess.reload:\n            done();\n            run(Init)(payload.process);\n            break;\n          default:\n            run(Start)();\n        }\n      }\n      if (status === Status.done) {\n        done();\n      }\n      break;\n  }\n};\n","import { Scroller } from './scroller';\nimport { runStateMachine } from './workflow-transducer';\nimport { Reactive } from './classes/reactive';\nimport { Item } from './classes/item';\nimport { CommonProcess, ProcessStatus as Status, } from './processes/index';\nimport {\n  WorkflowParams,\n  ProcessName,\n  ProcessPayload,\n  ProcessClass,\n  ProcessSubject,\n  WorkflowError,\n  InterruptParams,\n  StateMachineMethods,\n  ScrollerWorkflow,\n} from './interfaces/index';\n\nexport class Workflow<ItemData = unknown> {\n\n  isInitialized: boolean;\n  initTimer: ReturnType<typeof setTimeout> | null;\n  adapterRun$: Reactive<ProcessSubject>;\n  cyclesDone: number;\n  interruptionCount: number;\n  errors: WorkflowError[];\n\n  private disposeScrollEventHandler: () => void;\n  readonly propagateChanges: WorkflowParams<ItemData>['run'];\n  readonly stateMachineMethods: StateMachineMethods<ItemData>;\n\n  scroller: Scroller<ItemData>;\n\n  constructor({ element, datasource, consumer, run }: WorkflowParams<ItemData>) {\n    this.isInitialized = false;\n    this.initTimer = null;\n    this.adapterRun$ = new Reactive();\n    this.cyclesDone = 0;\n    this.interruptionCount = 0;\n    this.errors = [];\n    this.disposeScrollEventHandler = () => null;\n    this.propagateChanges = run;\n    this.stateMachineMethods = {\n      run: this.runProcess(),\n      interrupt: this.interrupt.bind(this),\n      done: this.done.bind(this),\n      onError: this.onError.bind(this)\n    };\n\n    this.scroller = new Scroller<ItemData>({ element, datasource, consumer, workflow: this.getUpdater() });\n\n    if (this.scroller.settings.initializeDelay) {\n      this.initTimer = setTimeout(() => {\n        this.initTimer = null;\n        this.init();\n      }, this.scroller.settings.initializeDelay);\n    } else {\n      this.init();\n    }\n  }\n\n  init(): void {\n    this.scroller.init(this.adapterRun$);\n    this.isInitialized = true;\n\n    // run the Workflow\n    this.callWorkflow({\n      process: CommonProcess.init,\n      status: Status.start\n    });\n\n    // set up scroll event listener\n    const { scrollEventReceiver } = this.scroller.viewport;\n    const onScrollHandler: EventListener =\n      event => this.callWorkflow({\n        process: CommonProcess.scroll,\n        status: Status.start,\n        payload: { event }\n      });\n    scrollEventReceiver.addEventListener('scroll', onScrollHandler);\n    this.disposeScrollEventHandler = () =>\n      scrollEventReceiver.removeEventListener('scroll', onScrollHandler);\n  }\n\n  changeItems(items: Item<ItemData>[]): void {\n    this.propagateChanges(items);\n  }\n\n  callWorkflow(processSubject: ProcessSubject): void {\n    if (!this.isInitialized) {\n      return;\n    }\n    const { process, status } = processSubject;\n    if (process && process.startsWith('adapter') && status !== Status.next) {\n      this.adapterRun$.set(processSubject);\n    }\n    this.process(processSubject);\n  }\n\n  getUpdater(): ScrollerWorkflow<ItemData> {\n    return {\n      call: this.callWorkflow.bind(this),\n      onDataChanged: this.changeItems.bind(this),\n    };\n  }\n\n  process(data: ProcessSubject): void {\n    const { status, process, payload } = data;\n    if (this.scroller.settings.logProcessRun) {\n      this.scroller.logger.log(() => [\n        '%cfire%c', ...['color: #cc7777;', 'color: #000000;'],\n        process, `\"${status}\"`, ...(payload !== void 0 ? [payload] : [])\n      ]);\n    }\n    this.scroller.logger.logProcess(data);\n\n    if (process === CommonProcess.end) {\n      this.scroller.finalize();\n    }\n    runStateMachine({\n      input: data,\n      methods: this.stateMachineMethods as StateMachineMethods<unknown>\n    });\n  }\n\n  runProcess() {\n    return ({ run, process, name }: ProcessClass) =>\n      (...args: any[]): void => {\n        if (this.scroller.settings.logProcessRun) {\n          this.scroller.logger.log(() => [\n            '%crun%c', ...['color: #333399;', 'color: #000000;'],\n            process || name, ...args\n          ]);\n        }\n        run(this.scroller as Scroller, ...args);\n      };\n  }\n\n  onError(process: ProcessName, payload?: ProcessPayload): void {\n    const message: string = payload && String(payload.error) || '';\n    const { time, cycle } = this.scroller.state;\n    this.errors.push({\n      process,\n      message,\n      time,\n      loop: cycle.loopIdNext\n    });\n    this.scroller.logger.logError(message);\n  }\n\n  interrupt({ process, finalize, datasource }: InterruptParams<ItemData>): void {\n    if (finalize) {\n      const { workflow, logger } = this.scroller;\n      // we are going to create a new reference for the scroller.workflow object\n      // calling the old version of the scroller.workflow by any outstanding async processes will be skipped\n      workflow.call = (p: ProcessSubject) => // eslint-disable-line @typescript-eslint/no-unused-vars\n        logger.log('[skip wf call]');\n      workflow.call.interrupted = true;\n      this.scroller.workflow = this.getUpdater();\n      this.interruptionCount++;\n      logger.log(() => `workflow had been interrupted by the ${process} process (${this.interruptionCount})`);\n    }\n    if (datasource) { // Scroller re-initialization case\n      this.scroller.adapter.relax(() => {\n        this.scroller.logger.log('new Scroller instantiation');\n        const scroller = new Scroller<ItemData>({ datasource, scroller: this.scroller });\n        this.scroller.dispose();\n        this.scroller = scroller;\n        this.scroller.init();\n      });\n    }\n  }\n\n  done(): void {\n    const { state, logger } = this.scroller;\n    this.cyclesDone++;\n    logger.logCycle(false);\n    state.cycle.done(this.cyclesDone + 1);\n    this.finalize();\n  }\n\n  dispose(): void {\n    if (this.initTimer) {\n      clearTimeout(this.initTimer);\n    }\n    this.disposeScrollEventHandler();\n    this.adapterRun$.dispose();\n    this.scroller.dispose(true);\n    Object.getOwnPropertyNames(this).forEach(prop => {\n      delete (this as Record<string, unknown>)[prop];\n    });\n  }\n\n  finalize(): void {\n  }\n\n}\n"],"names":["instanceCount","OBJECT","FUNC_WITH_X_AND_MORE_ARGUMENTS","INTEGER","INTEGER_UNLIMITED","BOOLEAN","OR","Settings","AdapterResetParams"],"mappings":";;;;;;;MAaa,QAAQ;qBAQE,SAAmB;QACtC,OAAO;QACP;gBACM,SAAS;gCACO;;QAEtB,sBAAsB;QACtB,qBAAqB;;aAGX;QACV,IAAI,oBAAoB,KAAK;;;QAG7B;sBACc,IAAI,IAAI;eACjB,KAAK,CAAC;oBACD;;;;;;eAOH;;IAGT,OAAc;mBACD,KAAK;;YAEd,IAAI;iBACC;4BACS,WAAW;kCACL;;;QAGtB,kBAAkB,CAAC,IAAI;QACvB,IAAI;wBACU,KAAK,KAAK,CAAC;;iCAEA;;aAGX;oBACF,IAAI,CAAC,IAAI;YACnB;YACA;;eAEK;;;QAIP,IAAI,CAAC,IAAI;;;QAIT,0BAA0B,IAAI,GAAG,CAAC,GAAG,IAAI;;;;ICxEjC;AAAZ,WAAY,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmC3B,CAAC,EAnCW,eAAe,KAAf,eAAe,QAmC1B;AAED,IAAY,eAKX;AALD,WAAY,eAAe;;;;;AAK3B,CAAC,EALW,eAAe,KAAf,eAAe,QAK1B;AAED,MAAM,IAAI,GAAG,eAAe,CAAC;AAC7B,MAAM,IAAI,GAAG,eAAe,CAAC;AAE7B,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC;AAEjB,MAAM,eAAe,GAAwB;aACzC;WACF;WACA;CACR,CAAC;AAEF,MAAM,MAAM,GAAG,MAAM,OAAO,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;AAEtD,MAAM,gBAAgB,GAAc;QAC9B;QACF,IAAI;eACG;;YAED;QACN,IAAI;eACG;;CAEV,CAAC;AAEF,MAAM,iBAAiB,GAAgB;cAC3B;aACD;YACD;YACA;eACG;eACA;eACA;CACZ,CAAC;MAEW,UAAU,GAAG;QACpB,EAAE;WACC,EAAE;EACM;MAEJ,sBAAsB,GAAG,MAAsB;;QAExD,MAAM;QACN,MAAM;;mBAEK;;;QAGX,MAAM;QACN,MAAM,KAAK;eACJ;mBACI;;;QAGX,MAAM;QACN,MAAM;;mBAEK;;;QAGX,MAAM;QACN,MAAM;aACD;mBACM;;;QAGX,MAAM;QACN,MAAM,KAAK;;kBAED;;;QAGV,MAAM;QACN,MAAM;;kBAEI;;;QAGV,MAAM;QACN,MAAM;;kBAEI;;;QAGV,MAAM;QACN,MAAM;;kBAEI;;;QAGV,MAAM;QACN,MAAM;;kBAEI;;;QAGV,MAAM;QACN,MAAM;;kBAEI;;;QAGV,MAAM;QACN,MAAM;;kBAEI;gBACF;;;QAGR,MAAM;QACN,MAAM;;kBAEI;gBACF;;;QAGR,MAAM;QACN,MAAM,IAAI;;kBAEA,KAAK;;;QAGf,MAAM;QACN,MAAM,IAAI;;kBAEA,KAAK;;;QAGf,MAAM;QACN,MAAM;;;;QAIN,MAAM;QACN,MAAM;;;;QAIN,MAAM;QACN,MAAM;;;;QAIN,MAAM;QACN,MAAM;;;;QAIN,MAAM;QACN,MAAM;;;;QAIN,MAAM;QACN,MAAM;;;;QAIN,MAAM;QACN,MAAM,KAAK;;;;QAIX,MAAM;QACN,MAAM;;;;QAIN,MAAM;QACN,MAAM;;;;QAIN,MAAM;QACN,MAAM;;;;QAIN,MAAM;QACN,MAAM,IAAI;;;;QAIV,MAAM;QACN,MAAM;eACC;;;QAGP,MAAM;QACN,MAAM;eACC;;;QAGP,MAAM;QACN,MAAM;eACC;;;QAGP,MAAM;QACN,MAAM;eACC;;;QAGP,MAAM;QACN,MAAM;eACC;;;QAGP,MAAM;QACN,MAAM;eACC,uBAAoC,qBAAqB;;;QAGhE,MAAM;QACN,MAAM;eACC,uBAAoC,qBAAqB;;;QAGhE,MAAM;QACN,MAAM,KAAK;eACJ;;;QAGP,MAAM;QACN,MAAM,KAAK;eACJ;;EAET;AAEK,MAAM,qBAAqB,GAAG,IAAI,GAAG,EAA+B;;ACrR3E,WAAe;QACT;WACG;CACR;;ACED,IAAIA,eAAa,GAAG,CAAC,CAAC;MAET,cAAc;sBAES;gBACxB;;cAEF,uBAAuB;;;8BAIP,sBAAsB,+BAAiB,EAAE,IAAK;8BAC9C,sBAAsB,iCAAmB,IAAI,IAAK;8BAClD,iEAAmD,IAAK;8BACxD,0DAA4C,YAAY,IAAK;;;aAIhF,qBAAqB;sBACZ,EAAE,WAAW,EAAE;;;sBAIf,QAAQ;;;;;2CAKW,CAAC,mCACnB;;;;;YAOT,sBAAsB,IAAI,EAAE,2BACrB,KAAK,UACP;;QAIT;kCACwB;;;;;MCpCf,iBAAiB;0BAMa,QAAyB;QAChE,IAAI,iBAAiB,CAAC;QACtB;;;QAGA;;;+BAGuB,yBAAyB,MAAM,WAAW;QACjE;;;qCAI6B,YAAY,CAAC;;CAE7C;AAED;MACa,cAAc,GAAG,CAAC,SAAgC,KAC7D,cAA+B,iBAAuB;0BACX;;;;EAIzC;AAEG,MAAM,UAAU,GAAG,cAAc,EAAE;;IC5C9B;AAAZ,WAAY,SAAS;;;AAGrB,CAAC,EAHW,SAAS,KAAT,SAAS,QAGpB;IAEW;AAAZ,WAAY,YAAY;;;;AAIxB,CAAC,EAJW,YAAY,KAAZ,YAAY;;ACKxB,IAAY,aAiBX;AAjBD,WAAY,aAAa;;;;;;;;;;;;;;;;;AAiBzB,CAAC,EAjBW,aAAa,KAAb,aAAa,QAiBxB;AAED,MAAM,QAAQ,GAAG,CAAC,GAAkB,EAAE,IAAe,KACnD,CAAC,IAAI,IAAI,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,KAAK,KAAK,GAAG,CAAC,OAAO,CAAC,OAAO,KAAK,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;AAEzF,MAAM,SAAS,GAAG,CAAC,KAAc,KAC/B,OAAO,KAAK,KAAK,QAAQ,KAAK,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,EAAE,CAAC;IACtE;IACA;AAEJ,MAAM,QAAQ,GAAG,CAAC,KAAc;uCACK;mBACpB;iCACc;eACpB;;WAEF,OAAO,aAAa,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC3E,CAAC,CAAC;AAEF,MAAM,SAAS,GAAG,CAAC,KAAc;mBAChB;2BACQ;8CACmB,EAAE,EAAE;6BACrB;eAChB;;WAEF,OAAO,aAAa,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC3E,CAAC,CAAC;AAEF,MAAM,kBAAkB,GAAG,CAAC,KAAc;;mBAEzB;2BACQ;+BACI;;;;4CAGW,EAAE;;6BAEf;eAChB;;WAEF,OAAO,aAAa,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC3E,CAAC,CAAC;AAEF,MAAM,aAAa,GAAG,CAAC,KAAa,EAAE,QAAkB,KAAK,CAAC,KAAc;iCAC7C;uBACV;;;;mBAIJ;2BACQ;QACrB;YACE,MAAM,2CAA2C,MAAM,CAAC;;;0BAE1C;;;WAGX,OAAO,aAAa,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC3E,CAAC,CAAC;AAEF,MAAM,SAAS,GAAG,CAAC,KAAc;mBAChB;;wBAEK;sBACJ;;8BACY;;;wCAGQ;eAC3B;;WAEF,OAAO,aAAa,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC3E,CAAC,CAAC;AAEF,MAAM,QAAQ,GAAG,CAAC,KAAc;mBACf;mEACgD;eACtD;;WAEF,OAAO,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC9D,CAAC,CAAC;AAEF,MAAM,aAAa,GAAG,CAAC,KAAc;mBACpB;QACX,+BAA+B,gCAAgC;eAC1D;;WAEF,OAAO,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC9D,CAAC,CAAC;AAEF,MAAM,UAAU,GAAG,CAAC,KAAc;;mBAEjB;6BACU;eAChB;;;0BAEe;eACf,6DAA6D;;6BAC3C;cACnB,mBAAmB;QACzB,UAAU,yBAAkC;YAC1C,MAAM;;;WAGH,OAAO,aAA0B,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AACxF,CAAC,CAAC;AAIF,MAAM,UAAU,GAAG,CAAC,KAAc;mBACjB;mCACgB;eACtB;;WAEF,OAAO,OAAe,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC7E,CAAC,CAAC;AAEF,MAAM,wBAAwB,GAAG,CAAC,SAAiB,KAAK,CAAC,KAAc;mCACtC;uBACZ;;;;mBAIJ;kCACyB;eAC/B,+DAA+D,CAAC;;WAElE,OAAO,OAAe,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC7E,CAAC,CAAC;AAEF,MAAM,+BAA+B,GAAG,CAAC,SAAiB,KAAK,CAAC,KAAc;mCAC7C;uBACZ;;;;mBAIJ;gCACuB;eAC7B,+DAA+D,CAAC;;WAElE,OAAO,OAAe,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC7E,CAAC,CAAC;AAEF,MAAM,2BAA2B,GAAG,CAAC,IAAY,EAAE,EAAU,KAAK,CAAC,KAAc;mCAChD;uBACZ;;;;mBAIJ;8CAC+C,EAAE;eACvD,yDAAyD,aAAa,CAAC,EAAE,CAAC;;WAE5E,OAAO,OAAe,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC7E,CAAC,CAAC;AAEF,MAAM,OAAO,GAAG,CAAC,MAAgB,EAAE,IAAa,KAAK,CAAC,KAAc,EAAE,OAA4B;mBACjF;iCACc;;qBAEZ,0BAA0B;gDACC;eACnC,aAAa,kBAAkB;;;aAEjC,IAAI,iBAAiB,GAAG,IAAI,IAAI,IAAI;YACvC,cAAc;;4BAEA,cAAc,YAAY,CAAC;;;YAGzC,oCAAoC,+BAA+B,eAAe;;4BAEpE,cAAc,YAAY,CAAC,OAAO,EAAE;;;;8BAIlC;;;QAGlB,IAAI,IAAI;YACN,MAAM,cAAc,CAAC,MAAM,MAAM,MAAM;;;WAGpC,OAAO,OAAO,SAAS,gBAAgB,QAAQ;AACxD,CAAC,CAAC;AAEF,MAAM,IAAI,GAAG,CAAC,UAAwB,KAAK,CAAC,KAAc;mBACzC;qCACkB,wBAAwB,UAAU;eAC1D,eAAe,CAAC,KAAK,CAAC,KAAK,MAAM;;WAEnC,OAAO,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC9D,CAAC,CAAC;AAKF,MAAM,MAAM,GAAG,CAAC,IAAW,KAAK,CAAC,KAAc;mBAC9B;mCACgB,QAAQ,kBAAkB,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,CAAC,CAAsB,CAAC;4CAC5D;eAC/B,4BAA4B,MAAM,cAAc,IAAI,CAAC,GAAG,IAAI,GAAG;;WAEjE,OAAO,OAAO,MAAM,SAAS,gBAAgB,QAAQ;AAC9D,CAAC,CAAC;AAEK,MAAM,UAAU,GAAG;UAClB;QACJ;;;WAGK;QACL;;;qBAGe;QACf;;;iBAGW,QAAgB,cAAoC;QAC/D;;;WAGK;QACL;;;UAGI;QACJ;;;aAGO;QACP;;;WAGK;QACL;;;QAGE;QACF;;;yBAGmB,YAAgC;QACnD;;;kCAG4B,YAAgC;QAC5D;;;8BAGwB,OAAe,EAAE,MAA0B;QACnE;4CACoC,IAAI;;cAEhC,WAAiC;QACzC;wBACgB;;eAEP,WAAiC;QAC1C;wBACgB,MAAM;;IAExB,EAAE,WAAqC;QACrC;gBACQ,KAAK;;QAEX,WAA8B;QAChC,oBAAoB;uBACL;;CAElB,CAAC;MAEW,aAAa;uBAUI;QAC1B;QACA;QACA;QACA,eAAe;QACf;;sBAGiC;QACjC,YAAY,8BAA8B;;kCAElB;;;;;QAIxB;;;QAIA,qBAAqB,KAAK,oBAAoB;YAC5C,gBAAgB,MAAM,MAAM;SAC7B,EAAE;QACH,YAAY,IAAI;;wBAGU;QAC1B,mBAAmB;QACnB,YAAY;QACZ;;kBAGoB,OAAuB;QAC3C;YACE,MAAM,SAAS,CAAC,KAAK;;gBAEnB,OAAO,QAAQ,KAAK,YACd,KAAK;;QAGf,iBAAiB;QACjB;;;eAIO;2CAC0B,MAAM,KAAK;;;CAG/C;AAEM,MAAM,YAAY,GAAG,CAC1B,OAAuB,EACvB,SAAqB,EACrB,OAA2B;UAErB,OAAO,QAAQ;yCACgB,SAAS;8BACpB,kBAAkB;;;;;;;AAO9C,CAAC,CAAC;AAEF,MAAM,UAAU,GAAG,CAAC,KAAc,EAAE,IAAiB;iCACtB;+DAC8B;;6BAEpC,IAAI,OAAO;qBACnB,IAAI;uBACF,KAAK;cACd;;AAEV,CAAC,CAAC;AAEK,MAAM,WAAW,GAAG,CACzB,OAA2B,EAAE,IAAY,EAAE,IAAiB;2CAErB,MAAM;qBAC5B;0BACG,gBAAgB,MAAM,CAAC,KAAK;QAC9C;gCACsB;;;;4BAGF,kBAAkB;YACpC,6BAA6B;0DACiB;;;;;oBAK1C;;;YAGJ,OAAO,OAAO;;;;AAIpB,CAAC,CAAC;AAEK,MAAM,QAAQ,GAAG,CACtB,OAAgB,EAAE,MAAiC;0CAEb;yBACjB,SAAS,CAAC,KAAK,6BACjB;sBACD,mBAAmB;6BACZ,IAAI;;AAI/B,CAAC;;ACtaD,MAAM,UAAEC,QAAM,kCAAEC,gCAA8B,EAAE,GAAG,UAAU,CAAC;AAE9D,IAAY,eAIX;AAJD,WAAY,eAAe;;;;AAI3B,CAAC,EAJW,eAAe,KAAf,eAAe,QAI1B;AAEM,MAAM,UAAU,GAAkC;yBAClC;qDACwB;mBAChC;;8BAEa;;;iCAGG;;;CAG9B;;AClBD,MAAM,EAAE,MAAM,WAAEC,SAAO,qBAAEC,mBAAiB,EAAE,aAAa,WAAEC,SAAO,EAAE,OAAO,EAAE,IAAI,MAAEC,IAAE,EAAE,IAAI,EAAE,GAAG,UAAU,CAAC;AAE3G,IAAKC,UAeJ;AAfD,WAAK,QAAQ;;;;;;;;;;;;;;;AAeb,CAAC,EAfIA,UAAQ,KAARA,UAAQ,QAeZ;AAED,IAAK,WAYJ;AAZD,WAAK,WAAW;;;;;;;;;;;;AAYhB,CAAC,EAZI,WAAW,KAAX,WAAW,QAYf;AAEM,MAAM,GAAG,GAAG;yBACE;2BACE;wBACH;0BACI;2BACC;iCACM;CAC9B,CAAC;AAEK,MAAM,QAAQ,GAA2B;wBAC5B;;;;2BAIG;;;;yBAIF;;;;yBAIA;;;;yBAIA;6CACkB,CAACA,0BAAwB;;;2BAGzC;6CACgB,CAACA,4BAA0B;;;wBAG9C;0CACkB,CAACA,yBAAuB;;;yBAGzC;;;;2BAIE;;;;+BAII;;;;gCAIC;sBACZ,CAAC,aAAa;sBACZ;;wBAEE;;;;6BAIK;qBACR;sBACC;;6BAEO;qBACR;;;CAGhB,CAAC;AAEK,MAAM,YAAY,GAA8B;uBAClC;;;;8BAIO;;sBAEV;;+BAEW;;;;yBAIN;;;;0BAIC;6CACe,CAAC,2BAA2B;oBACnD;;2BAES;6CACc,CAAC,4BAA4B;;;iCAGrC;6CACQ,CAAC,kCAAkC;oBAC1D;;2BAES;;;;+BAII;;;;gCAIC;;;;uCAIO;;sBAEnB;;CAEjB;;ACtJD,IAAY,aAYX;AAZD,WAAY,aAAa;;;;;;;;;;;;AAYzB,CAAC,EAZW,aAAa,KAAb,aAAa,QAYxB;AAED,IAAY,cAYX;AAZD,WAAY,cAAc;;;;;;;;;;;;AAY1B,CAAC,EAZW,cAAc,KAAd,cAAc,QAYzB;AAED,IAAY,aAKX;AALD,WAAY,aAAa;;;;;AAKzB,CAAC,EALW,aAAa,KAAb,aAAa;;ACvBzB,MAAM,EACJ,OAAO,EACP,iBAAiB,EACjB,OAAO,EACP,MAAM,EACN,SAAS,EACT,qBAAqB,EACrB,8BAA8B,EAC9B,0BAA0B,EAC1B,WAAW,EACX,UAAU,EACV,EAAE,GACH,GAAG,UAAU,CAAC;AAEf,IAAK,eAAmB;AAAxB,WAAK,eAAe;AAAG,CAAC,EAAnB,eAAe,KAAf,eAAe,QAAI;AACxB,MAAM,gBAAgB,GAAkC,EAAE,CAAC;AAE3D,MAAM,mBAAmB,GAAqC;yBACpC;mDACqB;;8BAEhB;;;iCAGG;;;CAGjC,CAAC;AAEF,IAAK,mBAEJ;AAFD,WAAK,mBAAmB;;AAExB,CAAC,EAFI,mBAAmB,KAAnB,mBAAmB,QAEvB;AAED,MAAM,oBAAoB,GAAsC;qCAC7B;;;CAGlC,CAAC;AAEF,IAAK,mBAIJ;AAJD,WAAK,mBAAmB;;;;AAIxB,CAAC,EAJI,mBAAmB,KAAnB,mBAAmB,QAIvB;AAED,MAAM,oBAAoB,GAAsC;+BACnC;;mBAEd;;6BAEY;6DAC8B,CAAC;;6BAE/B;6DAC8B,CAAC;;CAEzD,CAAC;AAEF,IAAK,mBAIJ;AAJD,WAAK,mBAAmB;;;;AAIxB,CAAC,EAJI,mBAAmB,KAAnB,mBAAmB,QAIvB;AAED,MAAM,oBAAoB,GAAsC;mCAC/B;2CACM;;iCAER;;;kCAGC;;;;CAI/B,CAAC;AAEF,IAAK,iBAGJ;AAHD,WAAK,iBAAiB;;;AAGtB,CAAC,EAHI,iBAAiB,KAAjB,iBAAiB,QAGrB;AAED,MAAM,kBAAkB,GAAoC;oCAC1B;;;;mCAID;;;;CAIhC,CAAC;AAEF,IAAK,mBAKJ;AALD,WAAK,mBAAmB;;;;;AAKxB,CAAC,EALI,mBAAmB,KAAnB,mBAAmB,QAKvB;AAED,MAAM,oBAAoB,GAAsC;+BACnC;;mBAEd;;gCAEe;2CACS;;+BAEV;2CACU;;kCAEP;;;;CAI/B,CAAC;AAEF,IAAK,oBAIJ;AAJD,WAAK,oBAAoB;;;;AAIzB,CAAC,EAJI,oBAAoB,KAApB,oBAAoB,QAIxB;AAED,MAAM,qBAAqB,GAAuC;+BACrC;;mBAEd;;oCAEmB;0CACI;mBACvB;;mCAEkB;;;;CAIhC,CAAC;AAEF,IAAK,mBAGJ;AAHD,WAAK,mBAAmB;;;AAGxB,CAAC,EAHI,mBAAmB,KAAnB,mBAAmB,QAGvB;AAED,MAAM,oBAAoB,GAAsC;mCAC/B;0CACK;mBACvB;;kCAEiB;;;;CAI/B,CAAC;AAEF,IAAK,gBAOJ;AAPD,WAAK,gBAAgB;;;;;;;AAOrB,CAAC,EAPI,gBAAgB,KAAhB,gBAAgB,QAOpB;AAED,MAAM,iBAAiB,GAAmC;qCACvB;;;+BAGN;;;+BAGA;;;8BAGD;+CACe,CAAC,CAAC;;mCAEZ;0CACK;;sCAEF;oBACpB,CAAC;;CAEhB,CAAC;AAEK,MAAM,cAAc,GAAiD;0BAC3DC;2BACC;2BACA;4BACC;0BACF;2BACC;yBACF;2BACE;4BACC;2BACD;wBACH;CACd,CAAC;AAEK,MAAM,eAAe,GAAiD;0BAC5D;2BACC;2BACA;4BACC;0BACF;2BACC;yBACF;2BACE;4BACC;2BACD;wBACH;CACd;;MCpNY,QAAQ;wBAqCoB,aAAuC,eAAuB;QAEnG;QACA;QACA;QACA,uBAAuB;QACvB,gBAAgB;;;oBAI0C,OAAkC;;QAE5F;YACE,UAAU;;+CAE2B,MAAM,uBAC7B,IAAI,IAAI,OAAO,SAAS;;;QAKxC,UAAU;QACV,IAAI,mBAAmB,IAAI,oBAAoB,yBAAyB;YACtE;;QAEF,IAAI,cAAc;YAChB,kBAAkB,MAAM;;;;;QAM1B,WAAW;;;sBAGG;0CACoB,WAAW,mCAAmC,CAAC;QACjF;;;;;;;ACxEG,MAAM,kBAAkB,GAAG,CAAC,OAAoB,2BAErD,MAAM,WAAW;;IAER;;AAIJ,MAAM,yBAAyB,GAAG,CAAC,OAAuB,2BAE/D,MAAM,kBAAmB,SAAS,kBAAkB,CAAC,OAAO,CAAkB;;YAK1E,MAAM;sBACE,QAAQ,yBAAyB,CAAC;;gBAGtC,MAAM;sCACc,CAAC,OAAO,YAAY;4BAChC,IAAI,QAAQ,YAAY,gDAE1B,CAAC,OAAO;;;gBAGhB,QAAQ,iBAAiB;;4BAEf;;;+BAGC;;;;mBAKN;;;IAxBF;;;ACbX,MAAM,aAAa,GAAG,CAAC,aAAa,CAAC,IAAI,EAAE,cAAc,CAAC,KAAK,EAAE,cAAc,CAAC,MAAM,CAAC,CAAC;MAEnE,IAAK,SAAQ,kBAAkB,CAAC,aAAa,CAAC,IAAI,CAAC;uBAEzC,SAAsB;qBACpC,SAAS;;iCAEG;;iBAEhB;mBACA;YACP;;;;;MCVe,MAAO,SAAQ,kBAAkB,CAAC,aAAa,CAAC,MAAM,CAAC;;uBAG7C,SAA6B;;;QAIxD;;;;;+BASmC,UAAkB;;;QAGrD,iBAAiB;;6CAEgB;;;gBAG7B,QAAQ;qCACW,EAAE,+CAA+C;;;;qBAI7D,WAAW;wDACsB,UAAU,WAAW,SAAS,KAAK,QAAQ;;;;;8BAMrD,UAAkB,MAAkB;qBACzD,eAAe,YAAY,YAAY;;2BAEjC;gDACqB,4BAA4B;;2CAEjC,SAAS;4BACxB;cACd,CAAC;;;6CAG4B;qDACQ,EAAE,MAAM,eAAe;;QAElE;;;uCAG2B;;YAEzB;;;QAGF;iDACuC;;oBAEjC,UAAU,wBAAwB,SAAS,qCAAqC;;oDAElD,WAAW;;yBAEtC,IAAI,QAAQ;;;;;uCAKM;;eAEtB;;;kCAI+B,UAAkC;cAChE,cAAc,IAAI,IAAI;QAC5B;QACA;;4BAEgB;;;sCAEU;;;sCAGI;;4BAGE,UAA4B;qBAC/C,sBAAsB;;8BAEb;QAEtB,UAAU,IAAI,IAAI;qBACP,WAAW;;;iBAIb;qBACE;YACT;;;;;MCpGe,KAAM,SAAQ,yBAAyB,CAAC,cAAc,CAAC,KAAK,CAAC;uBAEnD,SAA+B;4CACtB,YAAY,SAAS,SAAS;QAElE;YACE,MAAM,EAAE,SAAS;gBACb;;;YAGJ;YACA,MAAM;sBACE,KAAK,OAAO;gBAClB;mDACmC,EAAE;oBACnC,MAAM;;;;qBAKC;;;;QAKb,UAAU,IAAI,IAAI;;YAEhB,oBAAoB;;0BAGJ;qBACP;YACT;;;;;;MClCe,MAAO,SAAQ,yBAAyB,CAAC,cAAc,CAAC,MAAM,CAAC;uBAErD,aAAqB;;qDAGH,eAAe,IAAI;;;;QAMhE,gBAAgB,IAAI,IAAI;YACtB;;YAEA,KAAK,CAAC,oBAAoB;;0BAGV;qBACP;YACT;;;;;;MCnBO,IAAI;sBAgCW,MAAY,UAAoB;QACxD;YACE;;;QAGF;QACA;QACA,iBAAiB;QACjB;QACA;;;eA7BO;;oBAEe;QACtB;;;eAIO,eAAe;;kBAEJ;QAClB,eAAe;;;eAIR;;qBAEqB;QAC5B;;;eAgBO;;;QAIP,KAAK,OAAO,sBAAsB;;;QAIlC,IAAI;qCACuB;;;qBAIsB;QACjD,IAAI;kCACoB;;;qBAID;QACvB;QACA;;;eAIO;;;;MC9DU,MAAO,SAAQ,yBAAyB,CAAC,cAAc,CAAC,MAAM,CAAC;uBAErD,EAAE,SAAS,SAAS,EAAoB;;QAGnE;;;;;cAKM,IAAI,eAAe,MAAM,CAAC;;QAGhC,YACU,IAAI,IAAI,oBAAoB,CAAC,GAAG;2CACT,UAAU,CAAC;YAE1C;6BACiB;uBACR,QAAQ;gBACf;;;;8CAKkC;0BAEpB;qBACP;YACT;;;gCAIkC,OAAkB,SAAkB;gCAChD,YAAY;;QAEpC,+BAA+B;YAC7B,aAAa,MAAM,SAAS;YAC5B;YACA,kBAAkB,eAAe,CAAC,IAAI,MAAM,MAAM;;;gBAGhD,SAAS,uBAAuB;;qBAEzB,WAAW,iDAAiD;qBAC5D,MAAM,CAAC;;;iCAImB,OAAkB,KAAc,SAAkB;6BAClE,SAAS;;QAE9B,qCAAqC;QACrC;;aAGK,IAAI,CAAC,GAAG,GAAG,mBAAmB;YACjC,uCAAuC;oCACf,CAAC;iBAEtB;+BAEc,QAAQ,CAAC,CAAC,CAAC;;sBAElB,CAAC,yBAAyB,CAAC,gBAAgB,KAAK,CAAC;;oCAEnC,CAAC,CAAC,CAAC;;QAG7B;YACE;qBACS,WAAW,+CAA+C;;iDAG5B;mDACE;+BACpB,2BAA2B;cAC5C,gBAAgB,0BAA0B;eAEzC;;;;MCvFU,KAAM,SAAQ,yBAAyB,CAAC,cAAc,CAAC,KAAK,CAAC;uBAEnD;uCACI,SAAS;QACxC,uBAAuB;6BAEF,IAAI;YACvB,iBAAiB;;8BAEC;;mBAEb,GAAG,IAAI,cAAc,CAAC;mBACtB,GAAG,IAAI,cAAc,CAAC;;;QAI7B,mBAAmB,CAAC;YAClB,KAAK,CAAC,oBAAoB;YAC1B,KAAK,oBAAoB;YACzB,yBAAyB,EAAE,qCAAqC,MAAM;YACtE;gBACI,CAAC;8CAC2B,iCAAkC,CAAC;;YAEnE,KAAK,CAAC,MACJ,MAAM,CAAC,MAAM,cAAc,MAAM,sBAAsB,UAAU;;wBAIrD;iBAEP;qBACE;YACT,QAAQ;;;;;MChCO,MAAO,SAAQ,yBAAyB,CAAC,cAAc,CAAC,MAAM,CAAC;uBAErD,SAA+B;;QAE1D;;;;0BAKkB;qBACP;YACT;;;4BAI8B,QAA8B,sBAAsB;;kCAE1D;;QAE1B,kBAAkB;YAChB,iBAAiB,eAAe,MAAM,CAAC;;4DAEW;;QAEpD,yBAAyB;mBAChB;;QAET;YACE,MAAM;;wBAEQ;eACT;;uCAGoC,SAA+B;;QAE1E;QACA;YACE,SAAS;;QAEX;YACE,oBAAoB,MAAsB,6BAA6B,MAAM,CAAC;YAC9E,SAAS;;;;0CAKmC,WAA2B,UAAmB;wCAC5D,SAAS,SAAS,SAAS;;;aAItD,IAAI,CAAC,GAAG,GAAG,mBAAmB;YACjC,aAAa;yBACA,KAAK,CAAC;gBACjB;qBACK,QAAQ;;8BACK;;;;QAItB;;;;uCAK+B,oDAAoD;;mCAExD;QAC3B,+BAA+B;YAC7B;YACA,+BAAgC;;;QAGlC,kCAAkC;YAChC;;;QAGF,kCAAkC;YAChC;;;QAGF;YACE,0BAA0B;;;0CAIM,CAAC,IAAI,IAAI,IAAI;uBAChC,CAAC,OAAO,iFACyD,IAAI,CAAC,GAAG,CAAC;;;;;yBAOxE,IAAI,IAAI,KAAK,IAAI;;;sCAKQ,QAA8B,cAAuB;;QAE/F,YAAY;mBACH;;uCAEsB,SAAS;;;;QAKxC,IAAI,OAAO;aACN,IAAI,CAAC,4BAA4B,UAAU;YAC9C;8CACkC,CAAC;gBACjC,aAAa;;mDAC0B,CAAC;gBACxC,aAAa;;;;;gCAIK,CAAC,KAAK,0BAA0B,MAAM;;;;mBAInD;;QAGT;mBACS;;;QAIT;YACE,aAAa,EAAE,qCAAqC,MAAM;gBACtD,CAAC,KAAK,CAAC;uCACc;8CACO,4BAA6B,CAAC;;;;uBAKjD,CAAC,OAAO;mCACI,cAAc;;wDAEO;eAEzC;;kCAGqB,OAAO,EAAE,OAAO,EAAE,EAAY,cAAwB,UAAmB;QACrG;;;0CAGkC,eAAe,IAAI,cACzC,kDAAkD,oCAAoC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAC1G;yDACgD,oBAAoB;;;;MC9JpD,QAAS,SAAQ,yBAAyB,CAAC,cAAc,CAAC,IAAI,CAAC;uBAErD,SAA8B;;uBAG1C,4BAA4B;uBAC5B,6BAA6B;0BAE1B;;YAEhB;;;;;MCRe,MAAO,SAAQ,yBAAyB,CAAC,cAAc,CAAC,MAAM,CAAC;uBAErD,SAA+B;;QAE1D;;;;0BAMkB;qBACP;YACT;;;4BAI8B,QAA8B;uCAC/B,SAAS;QACxC;YACE,WAAW;mBACJ;;oBAEG,GAAG;gBACP,oCAAoC;0EAKlC,SAAS,IAAI,YAAY,2BACvB;QAIZ,SAAS;kCACiB,CAAC;QAC3B,aAAa;qBACD;;2CAGuB;8BACb,IAAI,IAAI,KAAK,IAAI;cACjC,CAAC;kDACiC,QAAQ,aAAa,MAAM,CAAC,UAAU;;iDAIrC;cACnC,CAAC;kDACiC,QAAQ,aAAa,MAAM,CAAC,UAAU;;;qCAKjD;;;;MCtDZ,MAAO,SAAQ,yBAAyB,CAAC,cAAc,CAAC,MAAM,CAAC;uBAErD,SAA+B;;QAE1D;;;;0BAKkB;qBACP;YACT;;;4BAI8B,QAA8B;;oBAElD,UAAU;4CACc,KAAK,IAAI,WAAW,IAAI,IAAI;QAChE;qBACW;mBACF;;;;0BAKO,MAAM,EAAE;sCACE;2BACb,QAAQ,EAAE,QAAQ,OAAO,GAAG,KAAK,EAAE;;;;;;;;;;MC5B/B,OAAQ,SAAQ,yBAAyB,CAAC,cAAc,CAAC,OAAO,CAAC;uBAEvD,SAAgC;;QAE3D;;;;0BAKkB;;YAEhB;;;6BAI+B,QAA+B;;aAE7D,eAAe,gBAAgB,CAAC;wBACrB,MAAM;QAEpB;qBACW;mBACF;;QAGT;;0BAEgB;qBACP,SAAS,QAAQ;;;qBAGjB;;;;;;sBAMG;;;;;;AChChB,MAAM,EAAE,CAAC,cAAc,CAAC,GAAG,GAAG,SAAS,EAAE,GAAG,cAAc,CAAC;MAEtC,GAAI,SAAQ,yBAAyB,CAAC,cAAc,CAAC,GAAG,CAAC;uBAE/C,SAA4B;;gBAG/C,iBAAiB;QACzB;;;uBAIe,sBAAsB;gBAC/B,KAAK,UAAU;8BACH,aAAa,OAAO,MAAM;;;iBAInC;mBACA;YACP;;;6BAI+B,OAAe,OAAgB,YAA4B;;;6CAG3D,QAAQ;;uCAEd,QAAQ;;uCAER,QAAQ;;uCAER,QAAQ;;+BAEhB;4CACW,iBAAiB,CAAC;0BACpC,iDAAyF;oBAC/F,wBAAwB,eAAiC;;;;;;;6BAQxC,UAAU,EAAY,OAAe;QAC5D;QACA;YACE;;aACK;YACL;;;;uBAKe,QAAQ,UAAU,EAAY,OAAe;;;;uBAK7C,QAAQ,UAAU,EAAY,OAAe;;;;uBAK7C,QAAQ,QAAQ,EAAY,OAAqB;QAClE;gDACwC;6BACnB,IAAI,UAAU,IAAI,IAAI;QAC3C;YACE,WAAW;YACX,MAAM,aAAa,MAAM,CAAC;;;gCAIQ,OAAuB,SAA2C;4CAClE,KAAK,IAAI,UAAU,IAAI,IAAI;QAC/D;qBACW,WAAW;;;;;;;MCtFL,KAAM,SAAQ,kBAAkB,CAAC,aAAa,CAAC,KAAK,CAAC;uBAE3C;;0BAGT;qBACP;YACT;;;;;;MCNe,QAAS,SAAQ,kBAAkB,CAAC,aAAa,CAAC,QAAQ,CAAC;uBAEjD;uCACI,gBAAgB;;;;;;QAS/C;;;;;;;;iBAWS;;YAEP;gCACoB;;;0CAIwB;;;;;;gCAOV;qBACvB,SAAS,aAAa,EAAE;;;;;;iBAM5B;;iCAG4B;gCACb,UAAU;QAClC,cAAc;QACd;0BACgB;;QAEhB;;;aAGK,sEAAsE;0BAC3D,qBAAqB,CAAC;;uBAEvB,CAAC;0CACgB,MAAM,QAAQ,EAAE,MAAM,gBAAgB,CAAC;;;;iCAKlC;;yBAEpB,SAAS;QAC1B;QACA,sBAAsB;QACtB;qBACW;;aACJ;qBACI;;;;;;;oBAML,UAAU;oBACV,6BAA6B;wBACzB;;0CAEgB;;;;;6BAKX;;;;oBAIP;;6BAEO;;;4BAGD;oBACR;oBACA;;;;;;;;0CAQ4B,IAAI,CAAC;;;gCAIH;qBACvB,gBAAgB;yBACZ,iBAAiB,WAAW;QAC7C;QACA;;wBAEc;qBACH;;;wBAEG;2BACG;wBACH;;yBAED;kDACyB;gBAClC,QAAQ;sDAC8B,WAAW;;oBAE/C,UAAU,CAAC,SAAS;qEAC2B;;;oBAG7C;;;;;;;;QAQR,aAAa,mBAAmB,IAAI,CAAC;;qCAGI;;QAEzC,YAAY;;;;;gCAKY;mBACb,GAAe,CAAC;QAC3B,IAAI,CAAC;aACA,IAAI,iBAAiB,gBAAgB;iBACnC,MAAM,CAAC;gBACV,KAAK,CAAC,CAAC,CAAC,CAAC;;qBACA,SAAS;gBAClB,KAAK,GAAG;;;QAGZ,IAAI,YAAY;QAChB,SAAS,UAAU,YAAY,SAAS;YACtC;;;gBAGI,SAAS,UAAU,SAAS;oBAC1B,GAAG;;;4BAGS,IAAI,CAAC,IAAI,KAAK;cAC5B,aAAa,IAAI,CAAC,IAAI,KAAK,WAAW,GAAG;QAC/C,oCAAoC,UAAU;qBACnC,MAAM,CAAC;;;mCAIqB;6BAClB,SAAS;QAC9B,YAAY;;;;;QAKZ;YACE,KAAK,CAAC,KAAK,SAAS,KAAK,CAAC;;;gCAGJ;QACxB;YACE,KAAK,KAAK,SAAS,KAAK;;QAE1B,oCAAoC,UAAU;qBACnC,MAAM,CAAC;;;sCAIwB;6BACrB,SAAS;QAC9B;;;;gCAIwB;cAClB,mCAAmC,0BAA0B;QACnE,IAAI,IAAI;;;QAGR,YAAY,IAAI,4BAA4B;YAC1C,0CAA0C,MAAM;;2BAEnC,KAAK;;;;YAGlB,4CAA4C,MAAM;;4BAEpC,KAAK;;;QAGrB,oCAAoC,UAAU;qBACnC,MAAM,CAAC;;;;qCAKuB;6BACpB,SAAS;QAC9B,UAAU;;gBAEJ,OAAO;yBACA,cAAc,cAAc,CAAC,OAAO,qBAAqB,oBAAoB,CAAC;;YAEzF;qBACS,WAAW;;;6BAIW;;QAEjC,uCAAuC;qBAC5B,WAAW,mDAAmD;gCACnD;;QAEtB;qBACW,WAAW,wBAAwB,KAAK,CAAC,kCAAkC,KAAK,CAAC;gCACtE;;6BAED;;;;MC1OJ,KAAM,SAAQ,kBAAkB,CAAC,aAAa,CAAC,KAAK,CAAC;uBAE3C;;;;gBAKvB,QAAQ,WAAW,uBACD,OAAO;oBACvB,uEAAuE,CAAC;gBAE1E,iCAAiC;gBACjC;;;;;YAKF,MAAM,mBACI;uBACC,OAAO;gBACd;;;;4BAKc,CAAC;;;4BAIW,KAAe,QAAwB;QACvE,oCAAoC;YAClC,MAAM,EAAE,yBAAyB;;mBAE5B,CAAC,QAAQ,IAAI;;;gBAEhB,QAAQ;;;;YAGV;oDACwC;kDACJ;;YAEpC,MAAM,SAAS;mBACV,cAAc;gBACjB,GAAG,WAAW;;YAEf,MAA6B,CAAC,IAAI,QAC1B,cAAc,QACrB,QAAQ,MAAM,KAAK,CAAC;;;uBAKG;cACrB,0BAA0B,CAAC;;QAGjC;QACA;cAEM,IAAI,IAAI;;gCAEM,IAAI;;;mBAGf,CAAC;;cAEJ,IAAI;iBACH;8BACW,QAAQ;;;YAGxB,MAAM,CAAC;;0BAGS,mBAAmB,MAAM;QAE3C,aAAa,iCAAiC,kBAAkB;;;;;oDAIJ,MAAM;+BACjD,2BAA2B,2BAA2B;2BAC5D;;;;;QAMX,iBAAiB;;uCAEU;;;;;eAMpB;;YAEL;;;;;MChHe,SAAU,SAAQ,kBAAkB,CAAC,aAAa,CAAC,SAAS,CAAC;uBAEnD;;QAE3B;;oBAEU;kCACY;gBAClB,QAAQ;;;;;;oBAKF;kCACY;gBAClB;;;;;mCAMmC;6BAClB,gBAAgB,SAAS,SAAS,aAAa,EAAE;;cAEhE,aAAa;QACnB;uBACa;4CACmB;;wBAElB;4CACkB;;;;YAG9B,kBAAkB,MAAM;wBACZ,SAAS;kCACD,GAAG,OAAO,CAAC;;uBAEpB,iBAAiB;kCACR,kBAAkB,CAAC;;;;4BAKT;6BACX,gBAAgB;;QAErC,UAAU;;;;QAIV;QACA;gBACM;;;;qBAGO,KAAK,CAAC,KAAK,SAAS;oCACT,QAAQ,QAAQ;;;2BAGrB,CAAC,KAAK,gBACvB,IAAI,yBAAyB;uBAEhB,wBAAwB,gBAAgB,2CAA2C;;;;;MC9DjF,MAAO,SAAQ,kBAAkB,CAAC,aAAa,CAAC,MAAM,CAAC;uBAE7C;+BACJ,8BAA8B;wBACrC;QAChB,wCAAwC;;;;YAItC;gBACI;gBACF;;kCAEgB;6CACW;;;;gBAG3B;;;;;;QAMJ,CAAC;;4BAG+B;qBACnB,iBAAiB;;QAE9B;YACE;gBAEE,KAAK,CAAC,kBAAkB,8BAA8B,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;;;;;;eAOrE;cACD,CAAC;eACA;;kCAG+B,MAAY;qBACrC,SAAS;qEACuC,WAAW;QACxE;mBACS;;QAET;QACA,mBAAmB;QACnB,kBAAkB;QAClB;QACA;QACA;yBACiB;QACjB,IAAI;YACF,0BAA0B;;eAErB;;;;MC7DU,MAAO,SAAQ,kBAAkB,CAAC,aAAa,CAAC,MAAM,CAAC;uBAE7C;yCACM,eAAe;;;;;;;8DAWrC;qBACE;YACT;;;+BAK+B;0CACD,WAAW,SAAS,SAAS;;;QAG/D,WAAW;QACX,aAAa;8BACO;4BACF;;;oBAER,CAAC,KAAK,CAAC,0BAA0B,CAAC,0BAA0B;;;;QAItE,kBAAkB,aAAa;;mEAG4B;uBAC9C,qBAAqB,CAAC;;qBAEtB,IAAI,WAAW,mCAAmC;uBAClD,qBAAqB,CAAC;;;kEAIuB,gBAAgB;mDAC/B;QAC3C,oBAAoB;;;;;;;qBAMT,WAAW;;iBAKb;gBACD;wBAEQ;;qCAGyB;;;QAGzC,0CAA0C;;QAG1C,mCAAmC;yBACpB,iBAAiB,MAAM;gBAClC;;gBAEE;gBACF;;;;gBAGE,mBAAmB;gBACrB;;;;QAKJ,wCAAwC;YACtC,aAAa;oBACL;gBACN,QAAQ,8DAA8D;gBACtE,QAAQ;;;;QAKZ,mBAAmB,iBAAiB;iCACb;;eAGhB;;+BAG4B,UAAkB,MAAkB;qBAC1D,eAAe;QAC5B;mBACS;;;;;YAMP;uBACW;2BACI;gBACb;gDACgC;;;;;qBAKzB,MAAM;YACf;;;;;MCtHe,OAAQ,SAAQ,kBAAkB,CAAC,aAAa,CAAC,OAAO,CAAC;uBAE/C;;0BAGT;;YAEhB;;gBAEE,QAAQ;;;;+BAKuB;qBACtB,WAAW,IAAI;QAC5B;;;;gCAIwB;uBACT,CAAC,OAAO,oEAC4C,CAAC;;QAEpE;;;QAGA;;;QAGA,KAAK;qBACM;;;;iCAK0B;;QAErC,qBAAqB,WAAW;qBACrB;;;QAGX,YAAY;qBACD;;;QAGX;qBACW;;;;;8BAMuB,YAAoB;6BACjC,IAAI,WAAW;QACpC,IAAI;;;QAGJ;kCACwB;;;;;;6BAOS,WAAmB;6BAC/B,IAAI,WAAW;QACpC,IAAI;;;QAGJ;iCACuB;;;;;;0CAOuB,WAAsB,WAAmB;;sCAEzD,IAAI;YAChC,sBACoB;gBAClB,QAAQ;qBAEH,QAAQ;;gBAEb,0BAA0B;;;;;;MCxFb,IAAK,SAAQ,kBAAkB,CAAC,aAAa,CAAC,IAAI,CAAC;uBAEzC;;QAG3B;iBAES;mBACA;YACP;;;0BAI4B;gCACN,YAAY,SAAS,IAAI,IAAI;cAC/C,4BAA4B,GAAG,qBAAqB,GAAG;eAEtD,uBAAuB,cAAc;kDAEF,IAAI;gBACxC;;;iBAGC;gBACD,8BAA8B;;;QAIpC;;gBAEI,+BAA+B,UAAU,IAAI,mBAAmB;;;gBAGhE,8BAA8B,CAAC,SAAS,IAAI,kBAAkB,CAAC;;;gBAG/D,SAAS,oCAAoC,IAAI,IAAI,CAAC,GAAG,IAAI,CAAC;;;eAI3D;cAED,CAAC;YACL,0BAA0B,QAAQ,aAAa;wBACnC;;;6BAGH,CAAC,SAAS,CAAC,oBAAoB;yBACnC,IAAI,SAAS,CAAC,OAAO,YAAY;qCACrB,IAAI,CAAC,WAAW,KAAK,CAAC;;;;eAKlC;;;;ACpDX,MAAM,aAAa,GAAG,CAAC,EAAE,IAAI,EAAoB,KAAc,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC;MAE7D,GAAI,SAAQ,kBAAkB,CAAC,aAAa,CAAC,GAAG,CAAC;uBAEvC,EAAE,OAAO,KAA0B,EAAE;+BACzC,SAAS,eAAe,EAAE;QAEjD,UAAU;;;;;QAMV;oBACU,eAAe,eAAe,sBAAsB;;;cAIxD,OAAO;iBAEJ;mBACA;YACP,MAAM;+EACgD;;;mCAIjB,UAA4B;yCAClC,SAAS;QAE1C;YACE,MAAM,EAAE,oCAAoC;;gBAE1C,2BAA2B,GAAG,KAAK;;;;QAKvC,8BAA8B;YAC5B,MAAM,EAAE,oCAAoC;;gBAE1C,0BAA0B,GAAG,KAAK;;;;qCAKG,OAAgB;4BACrC,WAAW,WAAW;cACpC,IAAI,0CAA0C,CAAC;;;QAGrD,WAAW;;eAEJ;;2BAGwB;qBAClB,iBAAiB;QAC9B,kBAAkB,iBAAiB;;;QAGnC,kBAAkB;;;;8CAIsB,mBAAmB;;;;;;;MCjElD,MAAM;wBAca,aAAwB,SAA0B;QAFxE;QAyIR,qBAAgB,gBAAwB;gBAClC,KAAK;;;YAGT,MAAM,mBACK,KAAK,IAAI,KAAK,CAAC,aAAa,OAAO,QAAQ,CAAC,CAAC;iBAErD,KAAK;2BACO;;;gCAEO,QAAQ,QAAQ;oBAChC;;8BACc,CAAC;2BACR,OAAO,GAAG,CAAC;;qCAEC,eAAe,IAAI,CAAC;;;gBAGzC,+BAA+B,MAAM,IAAI,SAAS,IAAI;;;QAvJ1D;QACA;QACA;QACA,mCACgB,gCAAgC;QAChD;YACE,QAAQ;YACR,cAAc;YACd,aAAa;;gBAEX,WAAW;4BACC,SAAS,SAAS,QAAQ;4BAC1B,SAAS,QAAQ,CAAC,OAAO;8BACvB,mBAAmB,IAAI,IAAI;;kCAEvB,IAAI,gBAAgB,gBAAgB,CAAC,SAAS,CAAC;;QAErE;YACE,+BAA+B,EAAE,aAAa,EAAE,mBAAmB,CAAC,KAAK,CAAC;oBAClE,MAAM,CAAC,KAAK,CAAC,KAAK,MAAM,MAAM,CAAC,KAAK;sBACpC;;;QAGV;QACA;QACA,+BAAuC,EAAE,0BACd;QAC3B,sBAAsB;QACtB,IAAI,CAAC;gCAEiB,KAAK,qBAAqB;6CACb;;oEAEuB,CAAC;;cAI3C,KAAc,WAAqB;QACnD,IAAI,CAAC;;;gCAGe,QAAQ;oBACtB,WAAW;wBACT;;oBAEF,UAAU;;;oBAGV,WAAW;+BACF;;;;;;;;qCAQQ;;;;;4BAKT;;4BAEA;;;;YAKC;QACf,IAAI;YACF;;;;qBAIS,mBAAmB,IAAI,WAAW,GAAG,MAAM;;;aAItC;QAChB,IAAI;YACF,kCAAkC,IAAI,WAAW,CAAC;YAClD;qBACS,MAAM,MAAM,8BAA8B;;;sBAI5B;eAClB,qBAAqB,IAAI;YAC9B,CAAC,uBAAuB,MAAM;YAC9B,CAAC;;mBAG0B;QAC7B,KAAK;;;6CAGgC;;;QAIrC,8BAC4B,IAAI,6BAAsB;mBAE7C,CAAC;;aACH,6BACoB;mBAElB,CAAC,sCAAsC;YAC9C,MAAM;gBACF,kBAAW,gBAAgB,yBAAyB,UAAU,0BAA0B;gBAC1F,OAAO,OAAO,8BAA8B;;;QAGhD;qBACW;;;yBAIQ;wBACH;;uBAED;QACf,IAAI,CAAC,OAAO,gCAAgC;;gBAG1B;QAClB,IAAI;YACF;qBACS,qBAAqB,IAAI,WAAW,GAAG;;;eAyBlC;QAChB,IAAI;uBACS,MAAM;oBACX;0BACM,CAAC,OAAO;wBACZ;;;oBAGA,CAAC,uBAAuB;;;;gBAI9B,OAAO,cAAc;;uBAEZ,aAAsB,mBAAmB,CAAC;;gBAEnD,sBAAsB;;;;;;;;;;;;;;;;oBAiBD;QACzB,IAAI;gBACE,0BAA0B,MAAM;yBACzB,CAAC,OAAO,WAAW,CAAC,wBAAwB;oBACjD;;qBAEG;gBACP,sBAAsB;;;;;;MCrNjB,QAAQ;wBAKW;QAC5B;QACA;;wBAG+B;QAC/B;YACE,UAAU;;;6BAIwB;QACpC,IAAI;mBACK;;QAET;uBACe;;6BAGqB,OAAe;gBAC3C,IAAI,CAAC,GAAG;QAChB,IAAI;;uBAEO,QAAQ,MAAM,QAAQ,CAAC;;;uBAEvB,QAAQ,OAAO,QAAQ;;;;QAIlC;gBACQ,4CAA4C;;qBAGxB,WAAqB;QACjD;QACA,IAAI,WAAW;;gBAEX,UAAU;yBACD;uBACF;gBACP,UAAU,oBAAoB;gBAC9B,QAAQ;yBACC,qBAAqB;;;;;mBAMR,WAAqB;eACxC,mCAAmC;;wBAGX;QAC/B;cACM,qBAAqB;0BACT,KAAe;;wBAGF,OAAe;QAC9C;gBACQ,IAAI,CAAC,GAAG,IAAI;sBACN,oCAAoC,CAAC,WAAW;;mBAGpC,WAAsB,WAAqB;uBACtD;;2BAEI,IAAI,qCAAqC,IAAI;;oBAGrC,WAAsB,iBAA8B,UAAmB;;gCAE1E,+CAA+C,CAAC;sBAC5D,0DAA0D,CAAC,qBAAqB,CAAC;;uBAG/D;QAC9B;;;qBAI4B;QAC5B;gBACQ,yDAAyD;;oBAGtC,UAA4C;QACvE;;;;;MC3FS,OAAO;uBAMc,WAAsB,UAAoB;QACxE,+DAA+D;QAC/D;QACA;;cAGiB;QACjB,KAAK,OAAO,IAAI;;;eAIT,2BAA2B;;kBAGd;QACpB,2BAA2B;;CAG9B;MAEY,QAAQ;uBAKa,UAAoB,UAAoB;QACtE;QACA,eAAe;QACf,gBAAgB;;yBAGc,UAAoB;;wBAEpC,CAAC,cAAc,CAAC;wBAChB,CAAC,eAAe,CAAC;;sBAGP,YAAoB,QAAgB;yBAC3C;yBACA;QACjB,IAAI;wBACU,CAAC;yBACA,CAAC;YACd,iDAAiD;oBACzC;qBACD,SAAS,IAAI;oBACd,CAAC,QAAQ,IAAI;;;;wBAGP,CAAC;yBACA,CAAC;YACd,gDAAgD;oBACxC;qBACD,SAAS,IAAI;oBACd,CAAC,QAAQ,IAAI;;;;8BAMW,cAAsB,QAAgB;6BACjD;QACrB;QACA;;;QAGA;mDACyC;;;;8BAKT;6BACX;QACrB,gBAAgB;QAChB;;;;;;;MC7ES,QAAQ;uBAgBa,UAAoB,UAAoB,OAAc,QAAgB;QACpG;QACA;QACA;QACA;QACA;QACA;QAEA;;uCAE6B;;;;;;QAM7B,gBAAgB,aAAa,cAAc;QAE3C,2BAA2B,uBAAuB;;;QAIlD;4BACkB,CAAC,uBAAuB;;;oBAIpB;QACtB;QACA,oBAAoB,YAAY,gBAAgB;QAChD,sBAAsB,uBAAuB,IAAI;QACjD;;qBAGuB;4BACH;QACpB;iBACO,WAAW;mBACT;;QAET,gCAAgC;yBACf;QACjB,WAAW,CAAC;kDAC4B,wBAAwB,EAAE,MAAM,QAAQ,CAAC;;;;;eAM1E,gCAAgC;;4BAGT;QAC9B;;;QAIA,IAAI;;;0BAGc;QAClB;;;QAGA,gBAAgB;;;4BAGE;YAChB;;;;;eAMK,sBAAsB,kBAAkB;;;eAIxC,sBAAsB;;;eAItB,iBAAiB;;qBAGE;eACnB,sBAAsB,6BAA6B;;;QAI1D,cAAc,wBAAwB;QACtC,KAAK;iBACE,iCAAiC;;;4BAIV,WAAsB;;;6BAG/B;QACrB,IAAI,MAAM,IAAI;aAEZ,IAAI,OAAO,GAAG,gBAAgB,SAC3B,IAAI,gBAAgB,GAAG,CAAC,IAAI,IAAI,IAClC,OAAO,GAAG,CAAC,CAAC,EAAE;YAEf,sCAAsC,CAAC;;8BAErB,iBAAiB;oBAC7B,GAAG;;;;iBAIF,aAAa,OAAO,aAAa,MAAM;;;;MClIvC,kBAAkB;;QAM3B;;;QAIA;QACA;QACA;;CAEH;MAEY,WAAW;wBAWM,cAA4B;QACtD;QACA;QACA,eAAe;QACf,qBAAqB;;eAGH;QAClB;;;;;wBAKc;;QAEd;;;gBAIQ;;;;;;;;;oCAUsC;gDACN;QACxC;YACE,yBAAyB,OAAO,IAAI,QAAQ,GAAG,WAAW;YAC1D,yBAAyB,OAAO,IAAI,QAAQ,GAAG;YAC/C,yCAAyC;8FACyC;;QAEpF;YACE,yBAAyB,OAAO,IAAI,QAAQ,GAAG,WAAW;YAC1D,yCAAyC;2DACM;;QAEjD;YACE,4BAA4B,OAAO,IAAI,QAAQ,GAAG,WAAW;YAC7D,yCAAyC;0DACK;;QAEhD,mBAAmB,WAAW;;;gDAIU;qCACX,YAAY,CAAC,IAAI;QAC9C;8BACoB,EAAE,UAAU,kBAAkB,MAAM,iBAAiB,KAAK,KAAK,CAAC,CAAC;;QAErF;8BACoB,EAAE,UAAU,kBAAkB,IAAI,MAAM,IAAI,CAAC,iBAAiB,KAAK,KAAK,EAAE,GAAG,CAAC;gDAC5D,aAAa,QAAkB,aAAa,CAAC,IAAI,CAAW,KAAK,CAAC,CAAC;;QAEzG;6BACmB,EAAE,UAAU,kBAAkB,IAAI,MAAM,IAAI,CAAC,iBAAiB,KAAK,KAAK,EAAE,GAAG,CAAC;;oBAErF,GAAG,IAAI,oBAAoB,IAAI,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;wCACnC,CAAC,CAAC,CAAC;yCACF,CAAC,EAAE,CAAC;QACrC,oBAAoB,IAAI,cAAc,MAAM,CAAC,EAAE,CAAC;;;;QAIhD,0BAA0B,CAAC,CAAC,CAAC;;yBAGF;QAC3B,IAAI;mBACK;;gDAE+B;QACxC,oBAAoB,oBAAoB;mBAC/B;;yBAEQ,IAAI;QACrB,IAAI;;;;;;QAKJ;eACO,IAAI;;sBAGe,SAAmB;QAC7C,IAAI;uCACyB;sBACnB;yBACG;;;;kBAKS;QACtB,IAAI;uCACyB;sBACnB;;;;gBAGJ;oCACkB;;;;sBAKE;QAC1B,IAAI;sCACwB;sBAClB;;;;;;MC/ID,SAAS;oBAOQ,UAAmB;QAC7C,cAAc;QACd,cAAc;QACd,KAAK,kBAAkB,KAAK,OAAO;QACnC,KAAK,OAAO,KAAK;;qBAGM;QACvB;QACA;;CAEH;MAEY,KAAK;gBAYJ,UAAU,WAAW,eAAe,cAAc,EAAY,QAAgB;QACxF;QACA;QACA;QACA;QACA;QACA,aAAa;QACb,mBAAmB;QACnB,WAAW;;eAGO;qBACL,KAAK;QAClB;;;gBAGM,CAAC,KAAK;;QAEZ;;;eAIO,WAAW;;aAGH;eACR,UAAU,CAAC;;qBAGK;cACjB,OAAO,IAAI,CAAC;eACX,OAAO,KAAK,IAAI,CAAC;;;eAIjB,gBAAgB;;;QAIvB,IAAI,6BAA6B,KAAK;iBAC/B,WAAW,wDAAwD,CAAC,GAAG;;;;;;;;;;;;;YAc5D;QAClB,gBAAgB,IAAI,CAAC,IAAI;QACzB;;yBAEa,KAAK;;wCAEY;uCACH;qCACJ,UAAU;;;;;yBAIpB,KAAK;;;;sCAGgB,IAAI;gBAChC,CAAC,SAAS,MAAM;6BACH;;QAEnB,IAAI,cAAc;iCACK;;QAEvB,IAAI,cAAc;iCACK;;;;;;;;;;;;;;wBAeK,UAAmB;sBACjC;QACd,uBAAuB;QACvB,mBAAmB,IAAI;wBACT,KAAK,SAAS,gBAAgB;gBACxC,kBAAkB;qCACC;;;;YAIrB;kBACI,QAAQ,CAAC,kBAAkB,IAAI,IAAI,eAAe,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC;kBAC/D,QAAQ,CAAC,kBAAkB,IAAI,IAAI,eAAe,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;4BACpD,MAAM,SAAS;YAC/B,SAAS,MAAM,MAAM,EAAE;YACvB,WAAW,MAAM,GAAG,IAAI,CAAC,MAAM,MAAM,CAAC;YACtC,WAAW,MAAM,GAAG,IAAI,CAAC,MAAM,MAAM,CAAC;;QAExC;QACA,gBAAgB;QAChB,gBAAgB;;;;;;;;;;;;;uBAcW,OAAqB,UAAoB;QACpE,KAAK,KAAK,IAAI;;;cAGR,cAAc,IAAI,2BAA2B;QACnD;QACA;YACE,aAAa,SAAS,MAAM,SAAS,KAAK,CAAC,MAAM,MAAM,MAAM;;;;;gCAIzC,gBAAgB;iCACf,IAAI;;sBAEb;QACd,mBAAmB,IAAI;qBACZ,SAAS;+CACe;sBACzB,SAAS,MAAM;;;0BAEP,SAAS;;sBAEjB,SAAS,MAAM;;;;sBAIX;cACP,CAAC,IAAI,aAAa,cAAoB,MAAM,aAAa;4BAE5C;gBACd,CAAC,KAAK,CAAC,QAAQ,YAAY,WAAW,MAAM,KAAK,iBAAiB,CAAC;2CAC1C;;;QAG/B,aAAa;QACb,aAAa;QACb;;;;MChMS,MAAM;wBAkBmB,eAAoC,QAAgB;QAhBhF;QAiBN;QACA;QACA,IAAI,OAAO;QACX,IAAI,OAAO;QACX,aAAa;QACb;QACA;QACA;QACA,WAAW;;;QAIX,IAAI,CAAC;QACL,IAAI,CAAC;QACL,oBAAoB,IAAI,IAAI,YAAY;QACxC;;eAGkB,YAAqB;QACvC,mBAAmB,IAAI,IAAI,KAAK,IAAI;QACpC,gBAAgB;QAChB;QACA;QACA,mBAAmB;QACnB,mBAAmB;QACnB;QACA,IAAI,CAAC,GAAG,CAAC;QACT,IAAI,CAAC,GAAG,CAAC;QACT;;sCAG0C;oBAC9B;oBACA;sBACE;QACd;QACA;iBACO,WAAW,qDAAqD;oBAC7D;;QAEV;iBACO,WAAW,kEAAkE,KAAK,MAAM;iBACxF;;QAEP;iBACO,WAAW,kEAAkE,KAAK,MAAM;iBACxF;;QAEP;;mBAG2B;QAC3B;QACA;QACA,KAAK;;;;;;eAOE;;yBAGoB;QAC3B,IAAI;gCACkB,eAAe,iDAAiD,CAAC,oBAAoB,CAAC;;QAE5G,KAAK;;;;;eAME;;yBAGoB;QAC3B,IAAI;gCACkB,eAAe,iDAAiD,CAAC,oBAAoB,CAAC;;QAE5G,KAAK;;;;;eAME;;;;oBAKK;aACT,CAAC,KAAK,CAAC,SAAS;sBACP;QACZ,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;;;;oBAKD;aACT,CAAC,KAAK,CAAC,KAAK,KAAK,CAAC,MAAM,MAAM,MAAM;sBAC3B;QACZ,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;;;eAIN;;;eAIA,WAAW;;;eAIX;;;wBAIS,mBAAmB,IAAI,sBAAsB;;;wBAI7C,mBAAmB,IAAI,sBAAsB;;;eAItD,oBAAoB,UAAU,YAAY,CAAC;;;eAI3C,oBAAoB,WAAW,iBAAiB,cAAc,CAAC;;;wBAItD,gBAAgB,IAAI,mBAAmB;;;wBAIvC,gBAAgB,IAAI,mBAAmB;;cAGvC;eACT,WAAW,KAAK,IAAI,IAAI;;kBAGL;QAC1B,KAAK;gBACC,aAAa;;aACZ,IAAI,UAAU,+BAA+B;gBAC9C,2BAA2B,CAAC;;aAC3B,SAAS,aAAa,WAAW,iBAAiB;gBACnD,iBAAiB,WAAW;;;mBAEzB;;eAEF;;;QAIP,aAAa,iBAAiB,gBAAgB;;gBAGtB;QACxB,UAAU,GAAG,IAAI;;iBAGQ;QACzB,UAAU,GAAG,cAAc;;wBAGO,UAAmB;QACrD;gCACsB;;;gCAEA;+BACD;;QAErB,IAAI,kBAAkB;;;aAEf,IAAI,kBAAkB;;;;uBAKF,UAAmB,iBAAiB;;2CAElB,CAAC;uBAC/B;QACf;aAEE,IAAI,qBAAqB,GAAG,CAAC,EAAE,YACvB,IAAI,IAAI,CAAC,GAAG,oBACZ,EAAE,IAAI,EAAE,EAAE;YAElB,iBAAiB,CAAC;2CACa,MAAM,MAAM;gBACzC,kBAAkB,CAAC;;;YAGrB,sBAAsB,OAAO,aAAa;gBACxC,cAAc,GAAG,KAAK;gBACtB,cAAc,GAAG,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;6BAEf,IAAI,CAAC;4BACN,MAAM,SAAS;;oBAEzB;;;;0BAGI,CAAC;;;;QAIb;QACA;gBACM,SAAS;;aACR;gBACD,iBAAiB,CAAC;;QAExB;;yBAI8B,WACsB,cAChC,UACH;QAEjB,KAAK,KAAK,IAAI,iBAAiB;;;QAG/B;QACA,uBAAuB,iBAAiB;;cAElC,eAAe,CAAC,GAAG,CAAC,CAAC;iCACF,UAAU,CAAC,GAAG;oBAC3B,uBAAuB,oBAAoB,IAAI;YACzD,MAAM,kBAAkB,CAAC;;iBAEpB,UAAU,CAAC,cAAc,MAAM,MAAM,OAAO;qBAC1C,QAAQ;6BACA,mCAAmC,QAAQ,KAAK,QAAQ,QAAQ,CAAC,CAAC,CAAC;uCACzD;;;;gBAIrB,CAAC,cAAc;gCACD;;qBAEX;;;;qBAIE;iCACU,aAAa,CAAC;;0BACjB;iCACG;;;YAGnB,cAAc;sBACJ,MAAM,oBAAoB,eAAe,EAAE,MAAM;oBACrD;gBACJ;oCACkB;qCACD,GAAG,KAAK;;oCAEP,SAAS;oBACzB;;;;oBAGA,UAAU,SAAS,SAAS,IAAI;;;gBAGlC,aAAa,CAAC;;;YAGhB,KAAK;4BACW,OAAO;gBACnB,OAAO,MAAM;kCACG,oBAAoB;;;QAG1C;QACA,0CAA0C;QAE1C,IAAI,2BAA2B;yBAChB;;aACR,oBAAoB;;;aAEpB,oBAAoB;;;;;kBAMH;QACxB,UAAU,CAAC,IAAI;;;uBAIA;aACV,IAAI,CAAC,GAAG,GAAG,aAAa;gBACvB,KAAK,CAAC;gBACR;;;;;;aAOC,IAAI,IAAI,iBAAiB,GAAG,IAAI,IAAI,IAAI;gBACvC,KAAK,CAAC;gBACR;;;;;;sBAOU;QACd,SAAS;uBACI,CAAC,KAAK,CAAC;;;;sBAKN;QACd,SAAS;uBACI,CAAC,KAAK,CAAC;;;gCAIiB,UAAoB;;sCAE7B,CAAC;;;eAItB,kBAAkB,MAAc,QAAQ,IAAI,IAAI,cAAc,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;;wBAGpD;cACpB,OAAO,UAAU,CAAC;eACjB,OAAO,KAAK,OAAO;;;eAInB;;wBAGqB;gBACpB;aACL,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,UAAU,MAAM,OAAO,CAAC;YACjD,CAAC,qBACC,WAAW,CAAC,CAAC,CAAC;;yBAGW;gBACrB;aACL,CAAC,WAAW,CAAC,KAAK,CAAC,SAAS,OAAO,CAAC;YACrC,CAAC,qBACC,WAAW,CAAC,CAAC,CAAC;;qBAGM,SAAkB;yBACzB,sBAAsB,CAAC,GAAG,IAAI,qBAAqB,CAAC;;;;ACtYzE,MAAM,cAAc;qBAUO;QACvB;QACA;QACA,KAAK,OAAO;;;eANL;;;QAUP;QACA;QACA,KAAK,IAAI,CAAC;;;QAIV,KAAK,IAAI,CAAC,IAAI;;;QAId,KAAK;;CAER;MAEY,kBAAkB;6BAiBI,OAA4B;8CACrB,CAAC;uDACQ,CAAC;QAEhD;QACA,iBAAiB;QACjB,mBAAmB;QACnB,KAAK,OAAO;QACZ,KAAK;;;kBAfK,kBAAkB,IAAI,UAAU,IAAI;;;kBAIpC,kBAAkB,IAAI,UAAU,IAAI,oBAAoB,GAAG;;cAcrD;QAChB;QACA;QACA,KAAK,IAAI,CAAC;;mBAGY,WAAwB;QAC9C;QACA;QACA;QACA,oBAAoB;QACpB,mBAAmB;QACnB,KAAK,IAAI,CAAC,IAAI;;mBAGS;QACvB;;gBAEM;;QAEN;;;;AC/EJ,MAAM,SAAS;;QAQX;;;QAIA,eAAe;QACf,WAAW;;CAEd;AAED,MAAM,KAAK;;QAMP;;;QAIA,aAAa;QACb,mBAAmB;QACnB,gBAAgB;;CAEnB;AAED,MAAM,IAAI;;QAKN;;;QAIA,aAAa;QACb,mBAAmB;;CAEtB;MAEY,UAAU;;QAsBnB,cAAc;QACd,iBAAiB;QACjB,aAAa;QACb,KAAK,OAAO,IAAI;QAChB;;;QAIA,qBAAqB;QACrB;QACA;QACA;QACA,KAAK;QACL;QACA,yBAAyB;QACzB,6BAA6B;QAC7B,iBAAiB;QACjB,iBAAiB;QACjB,cAAc;QACd;QACA;QACA;QACA;;;eAIO;;0BAG+B;QACtC;QACA,SAAS;;;;;iBAMA;;;eAIF,IAAI,kBAAkB,IAAI;;;eAI1B;;;sBAIO,iBAAiB,WAAW,KAAK,UAAU,IAAI,KAAK,aAAa,gBAAgB,GAAG,CAAC,CAAC;;uBAG3E;QACzB,gBAAgB;QAChB,0BAA0B,CAAC,IAAI,IAAI,IAAI,KAAK;QAC5C;QACA;QACA,iBAAiB;;;QAIjB;QACA;QACA;QACA;;gBAGkB;QAClB;QACA,KAAK,+BAA+B;QACpC,wBAAwB;QACxB;;iBAGmB;QACnB;QACA,KAAK,kBAAkB;QACvB,qCAAqC;QACrC;QACA,iBAAiB;;eAGA;QACjB;QACA,KAAK,kBAAkB;QACvB,qCAAqC;QACrC,eAAe;;;QAIf,kBAAkB,CAAC;QACnB,gBAAgB;;;gBAIE,OAAe,OAAe,eAAuB;QACvE;QACA;QACA;QACA,oCAAoC;;;;MC3K3B,SAAS;;QAWlB,cAAc;QACd;;;eALO,iBAAiB,IAAI;;eAQT;QACnB;QACA;gCACsB;iCACC;;;;;MCnBd,WAAW;;QAWpB;;;eAJO,oBAAoB;;;QAQ3B,eAAe;QACf,cAAc;QACd,mBAAmB;QACnB,mBAAmB;;;;MCbV,WAAW;;QAcpB;;;QAIA,gBAAgB;QAChB,eAAe;QACf,yBAAyB;QACzB;QACA,2BAA2B;QAC3B,4BAA4B;QAC5B,2BAA2B;QAC3B;;;QAIA,IAAI;wBACU;;;QAGd,IAAI;gCACkB;;;;+BAKW;uBAClB;sBACD;0BACI,IAAI,uBAAuB,cAAc,IAAI;;;;MCvCtD,KAAK;2BAmBkB,UAAoB,OAAgB;QACpE;QACA;QAEA,uBAAuB,IAAI,IAAI;QAE/B,aAAa,uBAAuB;QAEpC,aAAa;QACb,KAAK,OAAO;QACZ,cAAc;QAEd,mBAAmB;;;sBAfL,IAAI,MAAM,IAAI;;;yCAmBK;QACjC;YACE,MAAM;YACN,MAAM;;QAER;yBACe;YACb;;wBAEc;;;2DAImC,SAAS;;qCAG/B;QAE7B;YACE,KAAK;;QAEP,WAAW;;;qBAKE;sBACC,kBAAkB,KAAK,CAAC,MAAM;UACxC,EAAE;;;QAKN;QACA;QACA;;;;AC9CJ,MAAM,kBAAkB,GAAG,sBAAsB,EAAE,CAAC;AAEpD,MAAM,IAAI,GAAG,CAAC,GAAY,EAAE,IAAY,KACtC,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AAE7F,MAAM,iBAAiB,GAAG,CAAO,OAAgB,EAAE,OAAgB,EAAE,GAAa;;qBAE/D,UAAU;mBACd,yBAAyB,CAAC,WAAW;yBAC/B,sBAAsB;;;AAG3C,CAAC,CAAC;AAEF,MAAM,iBAAiB,GAAG,CAAO,OAA0D;QACrF,cAAc,8BAA8B,WAAW,EAAE;;;;;AAK/D,CAAC,CAAC;MAEW,OAAO;uBAyDwB,aAAmC,QAAgB;QApDrF;QACA;QACA;QACD;QAkDL;QACA;QACA,cAAc;QACd,gBAAgB;QAChB,kBAAkB;;0CAGgB,yBAAyB,CAAC,WAAW,IAAI;;;;oBAKnE,QAAQ;;oBAER;2DACqC,CAAC;;gCAE9B;;;gBAGZ,OAAO,0CAAY;;;;oDAKqB;YAC1C,yBAAyB,CAAC,MAAM,EAAE;;qBAE3B,KAAK,QAAQ,CAAC;;;;;aAMpB,QAAQ,EAAE,+CAA+C;sBAChD,EAAE,kBACV,sBAAsB,IAAI,EAAE;wBACd;iBACP,KAAK;;;;;;aAQb,cAAc;sBACL,EAAE;iBACL,MAAM,SAAS;YACpB,sBAAsB,IAAI,EAAE;;mBAEvB;gEAC2C,EACzC,QAAQ,EAAE,eAAe,kBAAkB;;wBAG5C,YAAY,aAAa;;;;;;;;;;;aAYhC,cAAc,+BAA+B,MAAM,IAAI,CAAC;sBAC/C,EAAE,uBAAuB;gBAC7B;oBACE,QAAQ,KAAK;;oBAEX,SAAS;YACjB,sBAAsB,IAAI,EAAE;;sBAEpB;gCACQ,SAAS;6BACd,QAAQ,CAAC;wBACd,sBAAyC;;8BAEnC;4BACF;6CACe;;;;mBAIpB;oBACD;wBACE,IAAI,CAAC,OAAO;;+BAEH,CAAC;;;;;;;;aASjB,cAAc,+BAA+B;sBACpC,EAAE;iBACL,MAAM,SAAS;YACpB,sBAAsB,IAAI,EAAE;;mBAEvB,KAAK,OAAO;;;QAIrB;;;;;sBAMY,EAAE,IAAI,EAAE;4BACc,CAAC;;gBAE7B,KAAK;;;gBAEL,KAAK,4BAA4B;;4EAC+B;gBAChE,QAAS;;;gBAET,KAAK;;YAEP,6BAA6B,EAAE;;mBAE1B,kBAAkB;qBAClB,CAAE;;;;QAKX;;;eArLO;;;eAGA;;;eAGA,gBAAgB;;+BA4B0B,eAA+B;eACzE,IAAI,SACT;YACE;gBACE,SAAS;gCACK,IAAI,OAAO;;iCAER;;2BAEJ,CAAC,MAAM,IAAI,EAAE;;qBA6IH,OAAc,QAAgB,aAAwC;;8BAE7E;iBACf,MAAM;;8BAES;;0BAER;yBACD;gBACT,QAAQ,SAAS;gBACjB,QAAQ,SAAS;2BACN;2BACA;2BACA;;;QAGf,IAAI,aAAa,CAAC,GAAG;cACf,CAAC,GAAG,GAAG,IAAI,IAAI,IAAI,OAAO;QAChC,IAAI,aAAa,CAAC,GAAG;cACf,CAAC,GAAG,GAAG,IAAI,IAAI,IAAI,OAAO;;8BAGV;iBACf,KAAK,CAAC;;QAEb,yCAAyC,IAAI;8BACvB,IAAI,IAAI,IAAI,IAAI,mBAAmB;QACzD,6BAA6B,IAAI;oBACrB,IAAI,IAAI,IAAI,IAAI,iBAAiB;;QAG7C;;QAGA;gBACM,MAAM;kCACU;;YAEpB,MAAM,cAAc;wBACR,MAAM;;4CAEY;oBAC1B,kBAAkB,aAAa;wBAC7B;;kCAEQ,iCAAiC;;;;kDAGT,gCAAgC;oBAClE;oBACA;;;;;;;;;QAUN,KAAK,OAAO;;;QAIZ,IAAI;iBACG;;QAEP,IAAI;;;mCAGuB,cAAc,IAAI;uBACH,CAAC;;;;mDAKA,CAAC,IAAI,oBAAoB,CAAC;;sBAEzD,EAAE,eAAe,EAAE;;;0DAGiB;;;;;;;sBAOpC;oBACF;;iCAEW,gBAAgB;;;;;;iBAOJ;QACjC;QACA,sDAAsD,aAAa;QACnE,cAAc;mCACW;YACvB,qBAAqB;;;;;kBAMO;QAC9B;QACA,uDAAuD,aAAa;QACpE,cAAc;oCACY;YACxB,qBAAqB;;;;;mBAM4B,KAAe;2DACf;QACnD,8DAA8D,CAAC;QAC/D,cAAc;oCACY;YACxB,qBAAqB;;;;;oBAM8B,KAAe;0CAClC,gBAAgB;QAClD,+DAA+D,CAAC;QAChE,cAAc;;YAEZ,qBAAqB;;;;;;QAOvB;QACA,cAAc;mCACW;YACvB,qBAAqB;;;;kBAKwC;;QAE/D;QACA,cAAc;oCACY;YACxB,qBAAqB;;;;;gBAMQ;QAC/B;QACA,cAAc;;YAEZ,qBAAqB;;;;;kBAMiB;QACxC;QACA,cAAc;oCACY;YACxB,qBAAqB;;;;;mBAMmB;QAC1C;QACA,cAAc;;YAEZ,qBAAqB;;;;;kBAMiB;QACxC;QACA,cAAc;oCACY;YACxB,qBAAqB;;;;;eAMW;QAClC;QACA,cAAc;;YAEZ,qBAAqB;;;;2BAKwB,UAAkB;gEACT,iBAAiB,aAAa;QACtF,KAAK;;;eAGE,mBAA4B;gBAC7B;gBACF;;;2BAGa,MAAM;;gBAEnB,OAAO;;WAER,cAAc;YACf;iBACK,WAAW,mFAAmF,CAAC;;;;yBAIzF;;;;kBAKY;yBACR;QACjB,+DAA+D;QAC/D,KAAK,KAAK;;;eAGH,gBAAgB;YACrB,CAAC,cAAc,MAAM,KAAK;YAC1B,CAAC,uCAAuC,CAAC,CAAC,MAAM;qBACzC,QAAQ;;;;;QAMjB;QACA;;;;MCteS,yBAAyB,GAAG,sBAAsB;AAE/D,IAAI,aAAa,GAAG,CAAC,CAAC;MAET,QAAQ;gBAYP,YAAY,UAAU,SAAS,UAAU,UAAU,EAAwB;sBACvE,OAAO;QACrB,IAAI,CAAC;YACH,UAAU,0CAA0C,MAAM,CAAC;;kEAGH,cAAe;;;QAIzE;QACA,gBAAgB,wDAA8D;QAC9E,cAAc,WAAW;QACzB,gBAAgB,aAAa;QAC7B,aAAa,uBAAuB;QACpC,cAAc,WAAiB,uCAAuC;QACtE,gBAAgB,sBAAsB,eAAe,eAAe,YAAY;QAChF,8CAA8C,eAAe;QAE7D;;6BAG0C,UAA2B;QACrE;;;;;;;;yBAQiB,eAAe,KAAK;QACrC;;;;YAGE,6BAA6B,IAAI,EAAE;8BACjB;;0BAEN,QAAQ,kBAAkB,CAAC;;;2BAGtB,kBAAkB,0BAA0B;QAC/D,eAAe,iCAAuC,eAAe;;oBAG5B;QACzC,oBAAoB;QACpB,YAAY;QACZ,wBAAwB,aAAa,YAAY;;mBAG1B;QACvB;;;QAGA;QACA;;;;;;AC1DG,MAAM,eAAe,GAAG,CAAC,EAC9B,KAAK,EAAE,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,GAAG,EAAE,EAAE,EACxC,OAAO,EAAE,EAAE,GAAG,EAAE,SAAS,EAAE,IAAI,EAAE,OAAO,EAAE,EACvB;sCACQ;;QAEzB;eACK;;;;UAID,SAAS;;2BAEM;gBACb,kBAAW,MAAM;gBACnB,SAAS,CAAC;;gBAER,kBAAW,OAAO;oBAChB;;YAEN;;gBAEI,kBAAW,MAAM;mBAChB,CAAC,OAAO,CAAC;;gBAEV,kBAAW,OAAO;gBACpB,SAAS,CAAC;;YAEZ;;;gBAGI,kBAAW,MAAM;8CACW;oBAC5B,SAAS,CAAC;;;oBAEV,UAAU,CAAC;;;gBAGX,kBAAW,OAAO;yBACX,4BAAe;oBACpB,QAAQ;oBACV;;;oBAEA,QAAQ,CAAC;;;YAGb;;;gBAGI,kBAAW,MAAM;mBAChB,CAAC;;gBAEF,kBAAW,OAAO;gBACpB,SAAS,CAAC;;YAEZ;;gBAEI,kBAAW,MAAM;oBACf;;gBAEF,kBAAW,OAAO;gBACpB,SAAS,CAAC;;YAEZ;;gBAEI,kBAAW,MAAM;mBAChB,CAAC,OAAO,CAAC;;gBAEV,kBAAW,OAAO;gBACpB,SAAS,CAAC;;YAEZ;4BACkB;gBACd,kBAAW,MAAM;oBACf,SAAS,CAAC;;gBAEZ,kBAAW,OAAO;gBACpB,SAAS,CAAC;;YAEZ;;gBAEI,kBAAW,MAAM;mBAChB,CAAC,OAAO,CAAC;;gBAEV,kBAAW,OAAO;gBACpB,SAAS,CAAC;;YAEZ;;gBAEI,kBAAW,MAAM;mBAChB,CAAC,QAAQ,CAAC;;gBAEX,kBAAW,OAAO;gBACpB,SAAS,CAAC;;YAEZ;;gBAEI,kBAAW,MAAM;mBAChB,CAAC,OAAO,CAAC;;gBAEV,kBAAW,OAAO;gBACpB,SAAS,CAAC;;YAEZ;2BACiB;gBACb,kBAAW,MAAM;gBACnB,QAAQ,CAAC;;gBAEP,kBAAW,OAAO;gBACpB,SAAS,CAAC;;YAEZ;;;mCAGqB;;;oBAGjB,GAAG,CAAC;;;oBAGJ,GAAG,CAAC;;mCAEa,CAAC;;gCAEN;;;;;;;;uBAOT;;YAEP;;gBAEI,kBAAW,OAAO;gBACpB,QAAQ,OAAO;;wBAEX,GAAG;;;wBAGH;;;gBAGF,kBAAW,OAAO;gBACpB,GAAG;;YAEL;;;YAGA;;gBAEI,kBAAW,OAAO;mBACjB;;gBAED,kBAAW,OAAO;gBACpB,GAAG;;YAEL;;gBAEI,kBAAW,OAAO;gBACpB,QAAQ,OAAO;;;;;;;;;wBASX,GAAG;;;gBAGL,kBAAW,OAAO;gBACpB,GAAG;;YAEL;;wBAEY;gBACV,GAAG,CAAC;;;mBAED;;YAEL;2BACiB;gBACb;YACJ;;gBAEI;YACJ;0BACgB;gBACZ,kBAAW,OAAO;gBACpB,QAAQ,OAAO;;;;;;;wBAOX;;;gBAGF,kBAAW,OAAO;;;YAGtB;;AAEN,CAAC;;MC3NY,QAAQ;gBAeP,SAAS,YAAY,UAAU,KAAK,EAA4B;QAC1E;QACA,iBAAiB;QACjB,mBAAmB;QACnB,eAAe;QACf,sBAAsB;QACtB;QACA,uCAAuC;QACvC,wBAAwB;QACxB;eACK;qBACM,gBAAgB,KAAK;YAC9B,IAAI,MAAM,KAAK,KAAK;mBACb,cAAc,KAAK;;QAG5B,gBAAgB,wDAAkE,eAAe,EAAE;QAEnG,IAAI;wCAC0B;8BACZ;oBACV;aACL;;;iBAEI;;;;QAKP,cAAc,KAAK;QACnB,qBAAqB;;QAGrB;;YAEE,eAAQ,MAAM;;;wCAIgB;qCAEzB,IAAI;mCACgB;YACvB,eAAQ,MAAM;;;;QAIlB;;qBAIiC;QACjC;;+BAGyC;QACzC,KAAK;;;;QAIL,WAAW,iCAAiC,6BAAsB;;;QAGlE;;;;YAKE,IAAI,mBAAmB,KAAK;yBACf,kBAAkB,KAAK;;;gBAIZ;6CACW;QACrC,IAAI;0BACY,WAAW;;6BAEV,cAAc,sBAAsB,CAAC;;;QAGtD,gCAAgC;QAEhC,6BAA6B;;;;iBAItB;mBACE;;;;gCAKe,QAAsB,GAC5C,IAAI;;qBAEK,QAAQ;;2BAEJ;;;eAGR,mBAA+B;;;mBAIZ,SAA0B;+BACrB,yBAAyB;gBAChD,gBAAgB;QACxB,YAAY;;;;YAIV,MAAM;;QAER;;cAGQ,SAAS,UAAU,YAAY,EAA6B;QACpE;YACE,kBAAkB;;;;aAIhB;oBACM;;;YAGR,WAAW;;QAEb;iCACuB,CAAC,MAAM;qBACrB,QAAQ;sBACP,eAAe,uBAAiC,eAAe;qBAChE,QAAQ;qBACR,WAAW;qBACX,QAAQ;;;;;kCAMS;QAC1B;;oBAEY,KAAK,eAAe;QAChC;;;QAIA,IAAI;wBACU;;QAEd;QACA;QACA,sBAAsB;mCACK,cAAc,IAAI;uBACH,CAAC;;;;;;;"}