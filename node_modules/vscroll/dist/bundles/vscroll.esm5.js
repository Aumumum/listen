/**
 * vscroll (https://github.com/dhilt/vscroll) FESM5
 * Version: 1.2.0 (2021-07-14T23:49:10.661Z)
 * Author: Denis Hilt
 * License: MIT
 */

import { __values, __read, __assign, __extends, __spreadArray } from 'tslib';

var Reactive = /** @class */ (function () {
  function Reactive(value, options) {
    this.id = 0;
    if (value !== void 0) {
      this.value = value;
      this.initialValue = value;
    }
    this.options = options || {};
    this.subscriptions = new Map();
  }
  Reactive.prototype.set = function (value) {
    var e_1, _a;
    if (this.value === value && !this.options.emitEqual) {
      return;
    }
    this.value = value;
    try {
      for (var _b = __values(this.subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2), sub = _d[1];
        sub.emit(value);
        if (this.value !== value) {
          break;
        }
      }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      }
      finally { if (e_1) throw e_1.error; }
    }
  };
  Reactive.prototype.get = function () {
    return this.value;
  };
  Reactive.prototype.on = function (func) {
    var _this = this;
    var id = this.id++;
    var subscription = {
      emit: func,
      off: function () {
        subscription.emit = function () { return null; };
        _this.subscriptions.delete(id);
      }
    };
    this.subscriptions.set(id, subscription);
    if (this.options.emitOnSubscribe) {
      subscription.emit(this.value);
    }
    return function () { return subscription.off(); };
  };
  Reactive.prototype.once = function (func) {
    var off = this.on(function (v) {
      off();
      func(v);
    });
    return off;
  };
  Reactive.prototype.reset = function () {
    this.set(this.initialValue);
  };
  Reactive.prototype.dispose = function () {
    this.subscriptions.forEach(function (sub) { return sub.off(); });
  };
  return Reactive;
}());

var AdapterPropName;
(function (AdapterPropName) {
  AdapterPropName["id"] = "id";
  AdapterPropName["mock"] = "mock";
  AdapterPropName["augmented"] = "augmented";
  AdapterPropName["version"] = "version";
  AdapterPropName["init"] = "init";
  AdapterPropName["init$"] = "init$";
  AdapterPropName["packageInfo"] = "packageInfo";
  AdapterPropName["itemsCount"] = "itemsCount";
  AdapterPropName["bufferInfo"] = "bufferInfo";
  AdapterPropName["isLoading"] = "isLoading";
  AdapterPropName["isLoading$"] = "isLoading$";
  AdapterPropName["loopPending"] = "loopPending";
  AdapterPropName["loopPending$"] = "loopPending$";
  AdapterPropName["firstVisible"] = "firstVisible";
  AdapterPropName["firstVisible$"] = "firstVisible$";
  AdapterPropName["lastVisible"] = "lastVisible";
  AdapterPropName["lastVisible$"] = "lastVisible$";
  AdapterPropName["bof"] = "bof";
  AdapterPropName["bof$"] = "bof$";
  AdapterPropName["eof"] = "eof";
  AdapterPropName["eof$"] = "eof$";
  AdapterPropName["reset"] = "reset";
  AdapterPropName["reload"] = "reload";
  AdapterPropName["append"] = "append";
  AdapterPropName["prepend"] = "prepend";
  AdapterPropName["check"] = "check";
  AdapterPropName["remove"] = "remove";
  AdapterPropName["clip"] = "clip";
  AdapterPropName["insert"] = "insert";
  AdapterPropName["replace"] = "replace";
  AdapterPropName["update"] = "update";
  AdapterPropName["fix"] = "fix";
  AdapterPropName["relax"] = "relax";
  AdapterPropName["showLog"] = "showLog";
})(AdapterPropName || (AdapterPropName = {}));
var AdapterPropType;
(function (AdapterPropType) {
  AdapterPropType[AdapterPropType["Scalar"] = 0] = "Scalar";
  AdapterPropType[AdapterPropType["Reactive"] = 1] = "Reactive";
  AdapterPropType[AdapterPropType["WorkflowRunner"] = 2] = "WorkflowRunner";
  AdapterPropType[AdapterPropType["Function"] = 3] = "Function";
})(AdapterPropType || (AdapterPropType = {}));
var Name = AdapterPropName;
var Type = AdapterPropType;
var noop = function () { return null; };
var methodPreResult = {
  immediate: true,
  success: true,
  details: 'Adapter is not initialized'
};
var noopWF = function () { return Promise.resolve(methodPreResult); };
var emptyPackageInfo = {
  core: {
    name: '',
    version: ''
  },
  consumer: {
    name: '',
    version: ''
  }
};
var bufferInfoDefault = {
  firstIndex: NaN,
  lastIndex: NaN,
  minIndex: NaN,
  maxIndex: NaN,
  absMinIndex: -Infinity,
  absMaxIndex: +Infinity,
  defaultSize: NaN,
};
var EMPTY_ITEM = {
  data: {},
  element: {}
};
var getDefaultAdapterProps = function () { return [
  {
    type: Type.Scalar,
    name: Name.id,
    value: 0,
    permanent: true
  },
  {
    type: Type.Scalar,
    name: Name.mock,
    value: true,
    permanent: true
  },
  {
    type: Type.Scalar,
    name: Name.augmented,
    value: false,
    permanent: true
  },
  {
    type: Type.Scalar,
    name: Name.version,
    value: '',
    permanent: true
  },
  {
    type: Type.Scalar,
    name: Name.init,
    value: false,
    reactive: Name.init$
  },
  {
    type: Type.Scalar,
    name: Name.packageInfo,
    value: emptyPackageInfo,
    onDemand: true
  },
  {
    type: Type.Scalar,
    name: Name.itemsCount,
    value: 0,
    onDemand: true
  },
  {
    type: Type.Scalar,
    name: Name.bufferInfo,
    value: bufferInfoDefault,
    onDemand: true
  },
  {
    type: Type.Scalar,
    name: Name.isLoading,
    value: false,
    reactive: Name.isLoading$
  },
  {
    type: Type.Scalar,
    name: Name.loopPending,
    value: false,
    reactive: Name.loopPending$
  },
  {
    type: Type.Scalar,
    name: Name.firstVisible,
    value: EMPTY_ITEM,
    reactive: Name.firstVisible$,
    wanted: true
  },
  {
    type: Type.Scalar,
    name: Name.lastVisible,
    value: EMPTY_ITEM,
    reactive: Name.lastVisible$,
    wanted: true
  },
  {
    type: Type.Scalar,
    name: Name.bof,
    value: false,
    reactive: Name.bof$
  },
  {
    type: Type.Scalar,
    name: Name.eof,
    value: false,
    reactive: Name.eof$
  },
  {
    type: Type.WorkflowRunner,
    name: Name.reset,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.reload,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.append,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.prepend,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.check,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.remove,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.clip,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.insert,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.replace,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.update,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.fix,
    value: noopWF
  },
  {
    type: Type.Function,
    name: Name.relax,
    value: noop
  },
  {
    type: Type.Function,
    name: Name.showLog,
    value: noop
  },
  {
    type: Type.Reactive,
    name: Name.init$,
    value: new Reactive()
  },
  {
    type: Type.Reactive,
    name: Name.isLoading$,
    value: new Reactive()
  },
  {
    type: Type.Reactive,
    name: Name.loopPending$,
    value: new Reactive()
  },
  {
    type: Type.Reactive,
    name: Name.firstVisible$,
    value: new Reactive(EMPTY_ITEM, { emitOnSubscribe: true })
  },
  {
    type: Type.Reactive,
    name: Name.lastVisible$,
    value: new Reactive(EMPTY_ITEM, { emitOnSubscribe: true })
  },
  {
    type: Type.Reactive,
    name: Name.bof$,
    value: new Reactive()
  },
  {
    type: Type.Reactive,
    name: Name.eof$,
    value: new Reactive()
  }
]; };
var reactiveConfigStorage = new Map();

var core = {
  name: 'vscroll',
  version: '1.2.0'
};

var instanceCount$1 = 0;
var AdapterContext = /** @class */ (function () {
  function AdapterContext(config) {
    var _this = this;
    var mock = config.mock, reactive = config.reactive;
    var id = ++instanceCount$1;
    var conf = { configurable: true };
    var reactivePropsStore = {};
    // set up permanent props
    Object.defineProperty(this, AdapterPropName.id, __assign({ get: function () { return id; } }, conf));
    Object.defineProperty(this, AdapterPropName.mock, __assign({ get: function () { return mock; } }, conf));
    Object.defineProperty(this, AdapterPropName.augmented, __assign({ get: function () { return false; } }, conf));
    Object.defineProperty(this, AdapterPropName.version, __assign({ get: function () { return core.version; } }, conf));
    // set up default props, they will be reassigned during the Adapter instantiation
    getDefaultAdapterProps()
      .filter(function (_a) {
      var permanent = _a.permanent;
      return !permanent;
    })
      .forEach(function (_a) {
      var name = _a.name, value = _a.value, type = _a.type;
      // reactive props might be reconfigured by the vscroll consumer
      if (reactive && type === AdapterPropType.Reactive) {
        var react = reactive[name];
        if (react) {
          // here we have a configured reactive property that came from the outer config
          // this prop must be exposed via Adapter, but at the same time we need to
          // persist the original default value as it will be used by the Adapter internally
          reactivePropsStore[name] = __assign(__assign({}, react), { default: value // persisting the default native Reactive prop
           });
          value = react.source; // exposing the configured prop instead of the default one
        }
      }
      Object.defineProperty(_this, name, __assign({ get: function () { return value; } }, conf));
    });
    if (reactive) { // save both configured and default reactive props in the store
      reactiveConfigStorage.set(id, reactivePropsStore);
    }
  }
  return AdapterContext;
}());

var DatasourceGeneric = /** @class */ (function () {
  function DatasourceGeneric(datasource, config) {
    this.get = datasource.get;
    if (datasource.settings) {
      this.settings = datasource.settings;
    }
    if (datasource.devSettings) {
      this.devSettings = datasource.devSettings;
    }
    var adapterContext = new AdapterContext(config || { mock: false });
    this.adapter = adapterContext;
  }
  DatasourceGeneric.prototype.dispose = function () {
    reactiveConfigStorage.delete(this.adapter.id);
  };
  return DatasourceGeneric;
}());
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
var makeDatasource = function (getConfig) {
  return /** @class */ (function (_super) {
    __extends(class_1, _super);
    function class_1(datasource) {
      var _this = this;
      var config = typeof getConfig === 'function' ? getConfig() : void 0;
      _this = _super.call(this, datasource, config) || this;
      return _this;
    }
    return class_1;
  }(DatasourceGeneric));
};
var Datasource = makeDatasource();

var Direction;
(function (Direction) {
  Direction["forward"] = "forward";
  Direction["backward"] = "backward";
})(Direction || (Direction = {}));
var SizeStrategy;
(function (SizeStrategy) {
  SizeStrategy["Average"] = "average";
  SizeStrategy["Constant"] = "constant";
  SizeStrategy["Frequent"] = "frequent";
})(SizeStrategy || (SizeStrategy = {}));

var ValidatorType;
(function (ValidatorType) {
  ValidatorType["number"] = "must be a number";
  ValidatorType["integer"] = "must be an integer";
  ValidatorType["integerUnlimited"] = "must be an integer or infinity";
  ValidatorType["moreOrEqual"] = "must be a number greater than (or equal to) {arg1}";
  ValidatorType["itemList"] = "must be an array of items {arg1}";
  ValidatorType["boolean"] = "must be a boolean";
  ValidatorType["object"] = "must be an object";
  ValidatorType["element"] = "must be an html element";
  ValidatorType["function"] = "must be a function";
  ValidatorType["funcOfxArguments"] = "must have {arg1} argument(s)";
  ValidatorType["funcOfxAndMoreArguments"] = "must have at least {arg1} argument(s)";
  ValidatorType["funcOfXToYArguments"] = "must have {arg1} to {arg2} arguments";
  ValidatorType["oneOfCan"] = "can be present as only one item of {arg1} list";
  ValidatorType["oneOfMust"] = "must be present as only one item of {arg1} list";
  ValidatorType["or"] = "must satisfy at least 1 validator from {arg1} list";
  ValidatorType["enum"] = "must belong to {arg1} list";
})(ValidatorType || (ValidatorType = {}));
var getError = function (msg, args) {
  return (args || ['']).reduce(function (acc, arg, index) { return acc.replace("{arg" + (index + 1) + "}", arg); }, msg);
};
var getNumber = function (value) {
  return typeof value === 'number' || (typeof value === 'string' && value !== '')
    ? Number(value)
    : NaN;
};
var onNumber = function (value) {
  var parsedValue = getNumber(value);
  var errors = [];
  if (Number.isNaN(parsedValue)) {
    errors.push(ValidatorType.number);
  }
  return { value: parsedValue, isSet: true, isValid: !errors.length, errors: errors };
};
var onInteger = function (value) {
  var errors = [];
  value = getNumber(value);
  var parsedValue = parseInt(String(value), 10);
  if (value !== parsedValue) {
    errors.push(ValidatorType.integer);
  }
  return { value: parsedValue, isSet: true, isValid: !errors.length, errors: errors };
};
var onIntegerUnlimited = function (value) {
  var parsedValue = value;
  var errors = [];
  value = getNumber(value);
  if (!Number.isFinite(value)) {
    parsedValue = value;
  }
  else {
    parsedValue = parseInt(String(value), 10);
  }
  if (value !== parsedValue) {
    errors.push(ValidatorType.integerUnlimited);
  }
  return { value: parsedValue, isSet: true, isValid: !errors.length, errors: errors };
};
var onMoreOrEqual = function (limit, fallback) { return function (value) {
  var result = onNumber(value);
  if (!result.isValid) {
    return result;
  }
  var parsedValue = result.value;
  var errors = [];
  if (parsedValue < limit) {
    if (!fallback) {
      errors.push(getError(ValidatorType.moreOrEqual, [String(limit)]));
    }
    else {
      parsedValue = limit;
    }
  }
  return { value: parsedValue, isSet: true, isValid: !errors.length, errors: errors };
}; };
var onBoolean = function (value) {
  var errors = [];
  var parsedValue = value;
  if (value === 'true') {
    parsedValue = true;
  }
  else if (value === 'false') {
    parsedValue = false;
  }
  if (typeof parsedValue !== 'boolean') {
    errors.push(ValidatorType.boolean);
  }
  return { value: parsedValue, isSet: true, isValid: !errors.length, errors: errors };
};
var onObject = function (value) {
  var errors = [];
  if (Object.prototype.toString.call(value) !== '[object Object]') {
    errors.push(ValidatorType.object);
  }
  return { value: value, isSet: true, isValid: !errors.length, errors: errors };
};
var onHtmlElement = function (value) {
  var errors = [];
  if (!(value instanceof Element) && !(value instanceof HTMLDocument)) {
    errors.push(ValidatorType.element);
  }
  return { value: value, isSet: true, isValid: !errors.length, errors: errors };
};
var onItemList = function (value) {
  var parsedValue = value;
  var errors = [];
  if (!Array.isArray(value)) {
    errors.push(ValidatorType.itemList);
    parsedValue = [];
  }
  else if (!value.length) {
    errors.push(getError(ValidatorType.itemList, ['with at least 1 item']));
  }
  else if (value.length > 1) {
    var type_1 = typeof value[0];
    if (value.some(function (v) { return typeof v !== type_1; })) {
      errors.push(getError(ValidatorType.itemList, ['of items of the same type']));
    }
  }
  return { value: parsedValue, isSet: true, isValid: !errors.length, errors: errors };
};
var onFunction = function (value) {
  var errors = [];
  if (typeof value !== 'function') {
    errors.push(ValidatorType.function);
  }
  return { value: value, isSet: true, isValid: !errors.length, errors: errors };
};
var onFunctionWithXArguments = function (argsCount) { return function (value) {
  var result = onFunction(value);
  if (!result.isValid) {
    return result;
  }
  value = result.value;
  var errors = [];
  if (value.length !== argsCount) {
    errors.push(getError(ValidatorType.funcOfxArguments, [String(argsCount)]));
  }
  return { value: value, isSet: true, isValid: !errors.length, errors: errors };
}; };
var onFunctionWithXAndMoreArguments = function (argsCount) { return function (value) {
  var result = onFunction(value);
  if (!result.isValid) {
    return result;
  }
  value = result.value;
  var errors = [];
  if (value.length < argsCount) {
    errors.push(getError(ValidatorType.funcOfxArguments, [String(argsCount)]));
  }
  return { value: value, isSet: true, isValid: !errors.length, errors: errors };
}; };
var onFunctionWithXToYArguments = function (from, to) { return function (value) {
  var result = onFunction(value);
  if (!result.isValid) {
    return result;
  }
  value = result.value;
  var errors = [];
  if (value.length < from || value.length > to) {
    errors.push(getError(ValidatorType.funcOfXToYArguments, [String(from), String(to)]));
  }
  return { value: value, isSet: true, isValid: !errors.length, errors: errors };
}; };
var onOneOf = function (tokens, must) { return function (value, context) {
  var errors = [];
  var isSet = value !== void 0;
  var noOneIsPresent = !isSet;
  var err = must ? ValidatorType.oneOfMust : ValidatorType.oneOfCan;
  if (!Array.isArray(tokens) || !tokens.length) {
    errors.push(getError(err, ['undefined']));
  }
  else {
    for (var i = tokens.length - 1; i >= 0; i--) {
      var token = tokens[i];
      if (typeof token !== 'string') {
        errors.push(getError(err, [tokens.join('", "')]) + ' (non-string token)');
        break;
      }
      var isAnotherPresent = context && Object.prototype.hasOwnProperty.call(context, token);
      if (isSet && isAnotherPresent) {
        errors.push(getError(err, [tokens.join('", "')]) + (" (" + token + " is present)"));
        break;
      }
      if (noOneIsPresent && isAnotherPresent) {
        noOneIsPresent = false;
      }
    }
    if (must && noOneIsPresent) {
      errors.push(getError(err, [tokens.join('", "')]));
    }
  }
  return { value: value, isSet: isSet, isValid: !errors.length, errors: errors };
}; };
var onOr = function (validators) { return function (value) {
  var errors = [];
  if (validators.every(function (validator) { return !validator.method(value).isValid; })) {
    errors.push(validators.map(function (v) { return v.type; }).join(' OR '));
  }
  return { value: value, isSet: true, isValid: !errors.length, errors: errors };
}; };
var onEnum = function (list) { return function (value) {
  var errors = [];
  var values = Object.keys(list).filter(function (k) { return isNaN(Number(k)); }).map(function (k) { return list[k]; });
  if (!values.some(function (item) { return item === value; })) {
    errors.push(getError(ValidatorType.enum, ['[' + values.join(',') + ']']));
  }
  return { value: value, isSet: true, isValid: !errors.length, errors: errors };
}; };
var VALIDATORS = {
  NUMBER: {
    type: ValidatorType.number,
    method: onNumber
  },
  INTEGER: {
    type: ValidatorType.integer,
    method: onInteger
  },
  INTEGER_UNLIMITED: {
    type: ValidatorType.integerUnlimited,
    method: onIntegerUnlimited
  },
  MORE_OR_EQUAL: function (limit, fallback) { return ({
    type: ValidatorType.moreOrEqual,
    method: onMoreOrEqual(limit, fallback)
  }); },
  BOOLEAN: {
    type: ValidatorType.boolean,
    method: onBoolean
  },
  OBJECT: {
    type: ValidatorType.object,
    method: onObject
  },
  ITEM_LIST: {
    type: ValidatorType.itemList,
    method: onItemList
  },
  ELEMENT: {
    type: ValidatorType.element,
    method: onHtmlElement
  },
  FUNC: {
    type: ValidatorType.function,
    method: onFunction
  },
  FUNC_WITH_X_ARGUMENTS: function (count) { return ({
    type: ValidatorType.funcOfxArguments,
    method: onFunctionWithXArguments(count)
  }); },
  FUNC_WITH_X_AND_MORE_ARGUMENTS: function (count) { return ({
    type: ValidatorType.funcOfxAndMoreArguments,
    method: onFunctionWithXAndMoreArguments(count)
  }); },
  FUNC_WITH_X_TO_Y_ARGUMENTS: function (from, to) { return ({
    type: ValidatorType.funcOfXToYArguments,
    method: onFunctionWithXToYArguments(from, to)
  }); },
  ONE_OF_CAN: function (list) { return ({
    type: ValidatorType.oneOfCan,
    method: onOneOf(list, false)
  }); },
  ONE_OF_MUST: function (list) { return ({
    type: ValidatorType.oneOfMust,
    method: onOneOf(list, true)
  }); },
  OR: function (list) { return ({
    type: ValidatorType.or,
    method: onOr(list)
  }); },
  ENUM: function (list) { return ({
    type: ValidatorType.enum,
    method: onEnum(list)
  }); }
};
var ValidatedData = /** @class */ (function () {
  function ValidatedData(context) {
    this.params = {};
    this.contextErrors = [];
    this.errors = [];
    this.isValid = true;
    this.setContext(context);
  }
  ValidatedData.prototype.setContext = function (context) {
    if (!context || Object.prototype.toString.call(context) !== '[object Object]') {
      this.setCommonError('context is not an object');
      this.isValidContext = false;
    }
    else {
      this.isValidContext = true;
    }
    this.context = context;
  };
  ValidatedData.prototype.setValidity = function () {
    var _this = this;
    this.errors = Object.keys(this.params).reduce(function (acc, key) { return __spreadArray(__spreadArray([], __read(acc)), __read(_this.params[key].errors)); }, []);
    this.isValid = !this.errors.length;
  };
  ValidatedData.prototype.setCommonError = function (error) {
    this.contextErrors.push(error);
    this.errors.push(error);
    this.isValid = false;
  };
  ValidatedData.prototype.setParam = function (token, value) {
    if (!value.isValid) {
      value.errors = !value.isSet
        ? ["\"" + token + "\" must be set"]
        : value.errors.map(function (err) {
          return "\"" + token + "\" " + err;
        });
    }
    this.params[token] = value;
    this.setValidity();
  };
  ValidatedData.prototype.showErrors = function () {
    return this.errors.length
      ? 'validation failed: ' + this.errors.join(', ')
      : '';
  };
  return ValidatedData;
}());
var runValidator = function (current, validator, context) {
  var value = current.value, errors = current.errors;
  var result = validator.method(value, context);
  var _errors = __spreadArray(__spreadArray([], __read(errors)), __read(result.errors));
  return {
    value: result.value,
    isSet: result.isSet,
    isValid: !_errors.length,
    errors: _errors
  };
};
var getDefault = function (value, prop) {
  var empty = value === void 0;
  var auto = !prop.mandatory && prop.defaultValue !== void 0;
  return {
    value: !empty ? value : (auto ? prop.defaultValue : void 0),
    isSet: !empty || auto,
    isValid: !empty || !prop.mandatory,
    errors: []
  };
};
var validateOne = function (context, name, prop) {
  var e_1, _a;
  var result = getDefault(context[name], prop);
  if (!result.isSet) {
    var oneOfMust = prop.validators.find(function (v) { return v.type === ValidatorType.oneOfMust; });
    if (oneOfMust) {
      return runValidator(result, oneOfMust, context);
    }
  }
  else {
    try {
      for (var _b = __values(Object.values(prop.validators)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var validator = _c.value;
        var current = runValidator(result, validator, context);
        if (!current.isValid && prop.defaultValue !== void 0) {
          return {
            value: prop.defaultValue,
            isSet: true,
            isValid: true,
            errors: []
          };
        }
        Object.assign(result, current);
      }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      }
      finally { if (e_1) throw e_1.error; }
    }
  }
  return result;
};
var validate = function (context, params) {
  var data = new ValidatedData(context);
  Object.entries(params).forEach(function (_a) {
    var _b = __read(_a, 2), key = _b[0], prop = _b[1];
    return data.setParam(key, data.isValidContext
      ? validateOne(data.context, key, prop)
      : getDefault(void 0, prop));
  });
  return data;
};

var _a$3;
var OBJECT$1 = VALIDATORS.OBJECT, FUNC_WITH_X_AND_MORE_ARGUMENTS$1 = VALIDATORS.FUNC_WITH_X_AND_MORE_ARGUMENTS;
var DatasourceProps;
(function (DatasourceProps) {
  DatasourceProps["get"] = "get";
  DatasourceProps["settings"] = "settings";
  DatasourceProps["devSettings"] = "devSettings";
})(DatasourceProps || (DatasourceProps = {}));
var DATASOURCE = (_a$3 = {},
  _a$3[DatasourceProps.get] = {
    validators: [FUNC_WITH_X_AND_MORE_ARGUMENTS$1(2)],
    mandatory: true
  },
  _a$3[DatasourceProps.settings] = {
    validators: [OBJECT$1]
  },
  _a$3[DatasourceProps.devSettings] = {
    validators: [OBJECT$1]
  },
  _a$3);

var _a$2, _b$2, _c$1;
var NUMBER = VALIDATORS.NUMBER, INTEGER$1 = VALIDATORS.INTEGER, INTEGER_UNLIMITED$1 = VALIDATORS.INTEGER_UNLIMITED, MORE_OR_EQUAL = VALIDATORS.MORE_OR_EQUAL, BOOLEAN$1 = VALIDATORS.BOOLEAN, ELEMENT = VALIDATORS.ELEMENT, FUNC = VALIDATORS.FUNC, OR$1 = VALIDATORS.OR, ENUM = VALIDATORS.ENUM;
var Settings$1;
(function (Settings) {
  Settings["adapter"] = "adapter";
  Settings["startIndex"] = "startIndex";
  Settings["minIndex"] = "minIndex";
  Settings["maxIndex"] = "maxIndex";
  Settings["itemSize"] = "itemSize";
  Settings["bufferSize"] = "bufferSize";
  Settings["padding"] = "padding";
  Settings["infinite"] = "infinite";
  Settings["horizontal"] = "horizontal";
  Settings["windowViewport"] = "windowViewport";
  Settings["viewportElement"] = "viewportElement";
  Settings["inverse"] = "inverse";
  Settings["onBeforeClip"] = "onBeforeClip";
  Settings["sizeStrategy"] = "sizeStrategy";
})(Settings$1 || (Settings$1 = {}));
var DevSettings;
(function (DevSettings) {
  DevSettings["debug"] = "debug";
  DevSettings["immediateLog"] = "immediateLog";
  DevSettings["logProcessRun"] = "logProcessRun";
  DevSettings["logTime"] = "logTime";
  DevSettings["throttle"] = "throttle";
  DevSettings["initDelay"] = "initDelay";
  DevSettings["initWindowDelay"] = "initWindowDelay";
  DevSettings["cacheData"] = "cacheData";
  DevSettings["cacheOnReload"] = "cacheOnReload";
  DevSettings["changeOverflow"] = "changeOverflow";
  DevSettings["dismissOverflowAnchor"] = "dismissOverflowAnchor";
})(DevSettings || (DevSettings = {}));
var MIN = (_a$2 = {},
  _a$2[Settings$1.itemSize] = 1,
  _a$2[Settings$1.bufferSize] = 1,
  _a$2[Settings$1.padding] = 0.01,
  _a$2[DevSettings.throttle] = 0,
  _a$2[DevSettings.initDelay] = 0,
  _a$2[DevSettings.initWindowDelay] = 0,
  _a$2);
var SETTINGS = (_b$2 = {},
  _b$2[Settings$1.adapter] = {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  _b$2[Settings$1.startIndex] = {
    validators: [INTEGER$1],
    defaultValue: 1
  },
  _b$2[Settings$1.minIndex] = {
    validators: [INTEGER_UNLIMITED$1],
    defaultValue: -Infinity
  },
  _b$2[Settings$1.maxIndex] = {
    validators: [INTEGER_UNLIMITED$1],
    defaultValue: Infinity
  },
  _b$2[Settings$1.itemSize] = {
    validators: [INTEGER$1, MORE_OR_EQUAL(MIN[Settings$1.itemSize], true)],
    defaultValue: NaN
  },
  _b$2[Settings$1.bufferSize] = {
    validators: [INTEGER$1, MORE_OR_EQUAL(MIN[Settings$1.bufferSize], true)],
    defaultValue: 5
  },
  _b$2[Settings$1.padding] = {
    validators: [NUMBER, MORE_OR_EQUAL(MIN[Settings$1.padding], true)],
    defaultValue: 0.5
  },
  _b$2[Settings$1.infinite] = {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  _b$2[Settings$1.horizontal] = {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  _b$2[Settings$1.windowViewport] = {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  _b$2[Settings$1.viewportElement] = {
    validators: [OR$1([ELEMENT, FUNC])],
    defaultValue: null
  },
  _b$2[Settings$1.inverse] = {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  _b$2[Settings$1.onBeforeClip] = {
    validators: [FUNC],
    defaultValue: null
  },
  _b$2[Settings$1.sizeStrategy] = {
    validators: [ENUM(SizeStrategy)],
    defaultValue: SizeStrategy.Average
  },
  _b$2);
var DEV_SETTINGS = (_c$1 = {},
  _c$1[DevSettings.debug] = {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  _c$1[DevSettings.immediateLog] = {
    validators: [BOOLEAN$1],
    defaultValue: true
  },
  _c$1[DevSettings.logProcessRun] = {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  _c$1[DevSettings.logTime] = {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  _c$1[DevSettings.throttle] = {
    validators: [INTEGER$1, MORE_OR_EQUAL(MIN[DevSettings.throttle], true)],
    defaultValue: 40
  },
  _c$1[DevSettings.initDelay] = {
    validators: [INTEGER$1, MORE_OR_EQUAL(MIN[DevSettings.initDelay], true)],
    defaultValue: 1
  },
  _c$1[DevSettings.initWindowDelay] = {
    validators: [INTEGER$1, MORE_OR_EQUAL(MIN[DevSettings.initWindowDelay], true)],
    defaultValue: 40
  },
  _c$1[DevSettings.cacheData] = {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  _c$1[DevSettings.cacheOnReload] = {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  _c$1[DevSettings.changeOverflow] = {
    validators: [BOOLEAN$1],
    defaultValue: false
  },
  _c$1[DevSettings.dismissOverflowAnchor] = {
    validators: [BOOLEAN$1],
    defaultValue: true
  },
  _c$1);

var CommonProcess;
(function (CommonProcess) {
  CommonProcess["init"] = "init";
  CommonProcess["scroll"] = "scroll";
  CommonProcess["start"] = "start";
  CommonProcess["preFetch"] = "preFetch";
  CommonProcess["fetch"] = "fetch";
  CommonProcess["postFetch"] = "postFetch";
  CommonProcess["render"] = "render";
  CommonProcess["preClip"] = "preClip";
  CommonProcess["clip"] = "clip";
  CommonProcess["adjust"] = "adjust";
  CommonProcess["end"] = "end";
})(CommonProcess || (CommonProcess = {}));
var AdapterProcess;
(function (AdapterProcess) {
  AdapterProcess["reset"] = "adapter.reset";
  AdapterProcess["reload"] = "adapter.reload";
  AdapterProcess["append"] = "adapter.append";
  AdapterProcess["prepend"] = "adapter.prepend";
  AdapterProcess["check"] = "adapter.check";
  AdapterProcess["remove"] = "adapter.remove";
  AdapterProcess["replace"] = "adapter.replace";
  AdapterProcess["update"] = "adapter.update";
  AdapterProcess["clip"] = "adapter.clip";
  AdapterProcess["insert"] = "adapter.insert";
  AdapterProcess["fix"] = "adapter.fix";
})(AdapterProcess || (AdapterProcess = {}));
var ProcessStatus;
(function (ProcessStatus) {
  ProcessStatus["start"] = "start";
  ProcessStatus["next"] = "next";
  ProcessStatus["done"] = "done";
  ProcessStatus["error"] = "error";
})(ProcessStatus || (ProcessStatus = {}));

var _a$1, _b$1, _c, _d, _e, _f, _g, _h, _j, _k, _l;
var INTEGER = VALIDATORS.INTEGER, INTEGER_UNLIMITED = VALIDATORS.INTEGER_UNLIMITED, BOOLEAN = VALIDATORS.BOOLEAN, OBJECT = VALIDATORS.OBJECT, ITEM_LIST = VALIDATORS.ITEM_LIST, FUNC_WITH_X_ARGUMENTS = VALIDATORS.FUNC_WITH_X_ARGUMENTS, FUNC_WITH_X_AND_MORE_ARGUMENTS = VALIDATORS.FUNC_WITH_X_AND_MORE_ARGUMENTS, FUNC_WITH_X_TO_Y_ARGUMENTS = VALIDATORS.FUNC_WITH_X_TO_Y_ARGUMENTS, ONE_OF_MUST = VALIDATORS.ONE_OF_MUST, ONE_OF_CAN = VALIDATORS.ONE_OF_CAN, OR = VALIDATORS.OR;
var AdapterNoParams;
(function (AdapterNoParams) {
})(AdapterNoParams || (AdapterNoParams = {}));
var NO_METHOD_PARAMS = {};
var RESET_METHOD_PARAMS = (_a$1 = {},
  _a$1[DatasourceProps.get] = {
    validators: [FUNC_WITH_X_AND_MORE_ARGUMENTS(2)]
  },
  _a$1[DatasourceProps.settings] = {
    validators: [OBJECT]
  },
  _a$1[DatasourceProps.devSettings] = {
    validators: [OBJECT]
  },
  _a$1);
var AdapterReloadParams;
(function (AdapterReloadParams) {
  AdapterReloadParams["reloadIndex"] = "reloadIndex";
})(AdapterReloadParams || (AdapterReloadParams = {}));
var RELOAD_METHOD_PARAMS = (_b$1 = {},
  _b$1[AdapterReloadParams.reloadIndex] = {
    validators: [INTEGER]
  },
  _b$1);
var AdapterAppendParams;
(function (AdapterAppendParams) {
  AdapterAppendParams["items"] = "items";
  AdapterAppendParams["bof"] = "bof";
  AdapterAppendParams["eof"] = "eof";
})(AdapterAppendParams || (AdapterAppendParams = {}));
var APPEND_METHOD_PARAMS = (_c = {},
  _c[AdapterAppendParams.items] = {
    validators: [ITEM_LIST],
    mandatory: true
  },
  _c[AdapterAppendParams.bof] = {
    validators: [BOOLEAN, ONE_OF_CAN([AdapterAppendParams.eof])]
  },
  _c[AdapterAppendParams.eof] = {
    validators: [BOOLEAN, ONE_OF_CAN([AdapterAppendParams.bof])]
  },
  _c);
var AdapterRemoveParams;
(function (AdapterRemoveParams) {
  AdapterRemoveParams["predicate"] = "predicate";
  AdapterRemoveParams["indexes"] = "indexes";
  AdapterRemoveParams["increase"] = "increase";
})(AdapterRemoveParams || (AdapterRemoveParams = {}));
var REMOVE_METHOD_PARAMS = (_d = {},
  _d[AdapterRemoveParams.predicate] = {
    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterRemoveParams.indexes])]
  },
  _d[AdapterRemoveParams.indexes] = {
    validators: [ITEM_LIST, ONE_OF_MUST([AdapterRemoveParams.predicate])]
  },
  _d[AdapterRemoveParams.increase] = {
    validators: [BOOLEAN],
    defaultValue: false
  },
  _d);
var AdapterClipParams;
(function (AdapterClipParams) {
  AdapterClipParams["backwardOnly"] = "backwardOnly";
  AdapterClipParams["forwardOnly"] = "forwardOnly";
})(AdapterClipParams || (AdapterClipParams = {}));
var CLIP_METHOD_PARAMS = (_e = {},
  _e[AdapterClipParams.backwardOnly] = {
    validators: [BOOLEAN, ONE_OF_CAN([AdapterClipParams.forwardOnly])],
    defaultValue: false
  },
  _e[AdapterClipParams.forwardOnly] = {
    validators: [BOOLEAN, ONE_OF_CAN([AdapterClipParams.backwardOnly])],
    defaultValue: false
  },
  _e);
var AdapterInsertParams;
(function (AdapterInsertParams) {
  AdapterInsertParams["items"] = "items";
  AdapterInsertParams["before"] = "before";
  AdapterInsertParams["after"] = "after";
  AdapterInsertParams["decrease"] = "decrease";
})(AdapterInsertParams || (AdapterInsertParams = {}));
var INSERT_METHOD_PARAMS = (_f = {},
  _f[AdapterInsertParams.items] = {
    validators: [ITEM_LIST],
    mandatory: true
  },
  _f[AdapterInsertParams.before] = {
    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterInsertParams.after])]
  },
  _f[AdapterInsertParams.after] = {
    validators: [FUNC_WITH_X_ARGUMENTS(1), ONE_OF_MUST([AdapterInsertParams.before])]
  },
  _f[AdapterInsertParams.decrease] = {
    validators: [BOOLEAN],
    defaultValue: false
  },
  _f);
var AdapterReplaceParams;
(function (AdapterReplaceParams) {
  AdapterReplaceParams["items"] = "items";
  AdapterReplaceParams["predicate"] = "predicate";
  AdapterReplaceParams["fixRight"] = "fixRight";
})(AdapterReplaceParams || (AdapterReplaceParams = {}));
var REPLACE_METHOD_PARAMS = (_g = {},
  _g[AdapterInsertParams.items] = {
    validators: [ITEM_LIST],
    mandatory: true
  },
  _g[AdapterReplaceParams.predicate] = {
    validators: [FUNC_WITH_X_ARGUMENTS(1)],
    mandatory: true
  },
  _g[AdapterReplaceParams.fixRight] = {
    validators: [BOOLEAN],
    defaultValue: false
  },
  _g);
var AdapterUpdateParams;
(function (AdapterUpdateParams) {
  AdapterUpdateParams["predicate"] = "predicate";
  AdapterUpdateParams["fixRight"] = "fixRight";
})(AdapterUpdateParams || (AdapterUpdateParams = {}));
var UPDATE_METHOD_PARAMS = (_h = {},
  _h[AdapterUpdateParams.predicate] = {
    validators: [FUNC_WITH_X_ARGUMENTS(1)],
    mandatory: true
  },
  _h[AdapterUpdateParams.fixRight] = {
    validators: [BOOLEAN],
    defaultValue: false
  },
  _h);
var AdapterFixParams;
(function (AdapterFixParams) {
  AdapterFixParams["scrollPosition"] = "scrollPosition";
  AdapterFixParams["minIndex"] = "minIndex";
  AdapterFixParams["maxIndex"] = "maxIndex";
  AdapterFixParams["updater"] = "updater";
  AdapterFixParams["scrollToItem"] = "scrollToItem";
  AdapterFixParams["scrollToItemOpt"] = "scrollToItemOpt";
})(AdapterFixParams || (AdapterFixParams = {}));
var FIX_METHOD_PARAMS = (_j = {},
  _j[AdapterFixParams.scrollPosition] = {
    validators: [INTEGER_UNLIMITED]
  },
  _j[AdapterFixParams.minIndex] = {
    validators: [INTEGER_UNLIMITED]
  },
  _j[AdapterFixParams.maxIndex] = {
    validators: [INTEGER_UNLIMITED]
  },
  _j[AdapterFixParams.updater] = {
    validators: [FUNC_WITH_X_TO_Y_ARGUMENTS(1, 2)]
  },
  _j[AdapterFixParams.scrollToItem] = {
    validators: [FUNC_WITH_X_ARGUMENTS(1)]
  },
  _j[AdapterFixParams.scrollToItemOpt] = {
    validators: [OR([BOOLEAN, OBJECT])]
  },
  _j);
var AdapterMethods = (_k = {},
  _k[AdapterProcess.reset] = DatasourceProps,
  _k[AdapterProcess.reload] = AdapterReloadParams,
  _k[AdapterProcess.append] = AdapterAppendParams,
  _k[AdapterProcess.prepend] = AdapterAppendParams,
  _k[AdapterProcess.check] = AdapterNoParams,
  _k[AdapterProcess.remove] = AdapterRemoveParams,
  _k[AdapterProcess.clip] = AdapterClipParams,
  _k[AdapterProcess.insert] = AdapterInsertParams,
  _k[AdapterProcess.replace] = AdapterReplaceParams,
  _k[AdapterProcess.update] = AdapterUpdateParams,
  _k[AdapterProcess.fix] = AdapterFixParams,
  _k);
var ADAPTER_METHODS = (_l = {},
  _l[AdapterProcess.reset] = RESET_METHOD_PARAMS,
  _l[AdapterProcess.reload] = RELOAD_METHOD_PARAMS,
  _l[AdapterProcess.append] = APPEND_METHOD_PARAMS,
  _l[AdapterProcess.prepend] = APPEND_METHOD_PARAMS,
  _l[AdapterProcess.check] = NO_METHOD_PARAMS,
  _l[AdapterProcess.remove] = REMOVE_METHOD_PARAMS,
  _l[AdapterProcess.clip] = CLIP_METHOD_PARAMS,
  _l[AdapterProcess.insert] = INSERT_METHOD_PARAMS,
  _l[AdapterProcess.replace] = REPLACE_METHOD_PARAMS,
  _l[AdapterProcess.update] = UPDATE_METHOD_PARAMS,
  _l[AdapterProcess.fix] = FIX_METHOD_PARAMS,
  _l);

var Settings = /** @class */ (function () {
  function Settings(settings, devSettings, instanceIndex) {
    this.parseInput(settings, SETTINGS);
    this.parseInput(devSettings, DEV_SETTINGS);
    this.instanceIndex = instanceIndex;
    this.initializeDelay = this.getInitializeDelay();
    this.viewport = this.getViewport();
    // todo: min/max indexes must be ignored if infinite mode is enabled ??
  }
  Settings.prototype.parseInput = function (input, props) {
    var _this = this;
    var result = validate(input, props);
    if (!result.isValid) {
      throw new Error('Invalid settings');
    }
    Object.entries(result.params).forEach(function (_a) {
      var _b;
      var _c = __read(_a, 2), key = _c[0], par = _c[1];
      return Object.assign(_this, (_b = {}, _b[key] = par.value, _b));
    });
  };
  Settings.prototype.getInitializeDelay = function () {
    var result = 0;
    if (this.windowViewport && this.initWindowDelay && !('scrollRestoration' in history)) {
      result = this.initWindowDelay;
    }
    if (this.initDelay > 0) {
      result = Math.max(result, this.initDelay);
    }
    return result;
  };
  Settings.prototype.getViewport = function () {
    if (typeof this.viewportElement !== 'function') {
      return this.viewportElement;
    }
    var value = this.viewportElement();
    var result = validateOne({ value: value }, 'value', { validators: [VALIDATORS.ELEMENT] });
    if (!result.isValid) {
      return null; // fallback to default (null) if Function didn't return HTML element synchronously
    }
    return result.value;
  };
  return Settings;
}());

var BaseProcessFactory = function (process) { var _a; return _a = /** @class */ (function () {
    function BaseProcess() {
    }
    return BaseProcess;
  }()),
  _a.process = process,
  _a; };
var BaseAdapterProcessFactory = function (process) { var _a; return _a = /** @class */ (function (_super) {
    __extends(BaseAdapterProcess, _super);
    function BaseAdapterProcess() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BaseAdapterProcess.parseInput = function (scroller, options, ignoreErrors) {
      if (ignoreErrors === void 0) { ignoreErrors = false; }
      var result = {
        data: validate(options, ADAPTER_METHODS[process])
      };
      if (result.data.isValid) {
        result.params = Object.entries(result.data.params)
          .reduce(function (acc, _a) {
          var _b;
          var _c = __read(_a, 2), key = _c[0], value = _c[1].value;
          return (__assign(__assign({}, acc), (_b = {}, _b[key] = value, _b)));
        }, {});
      }
      else {
        scroller.logger.log(function () { return result.data.showErrors(); });
        if (!ignoreErrors) {
          scroller.workflow.call({
            process: process,
            status: ProcessStatus.error,
            payload: { error: "Wrong argument of the \"" + process + "\" method call" }
          });
        }
      }
      return result;
    };
    return BaseAdapterProcess;
  }(BaseProcessFactory(process))),
  _a.process = process,
  _a; };

var initProcesses = [CommonProcess.init, AdapterProcess.reset, AdapterProcess.reload];
var Init = /** @class */ (function (_super) {
  __extends(Init, _super);
  function Init() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Init.run = function (scroller, process) {
    var cycle = scroller.state.cycle, workflow = scroller.workflow;
    var isInitial = initProcesses.includes(process);
    scroller.logger.logCycle(true);
    cycle.start(isInitial, process);
    workflow.call({
      process: Init.process,
      status: ProcessStatus.next
    });
  };
  return Init;
}(BaseProcessFactory(CommonProcess.init)));

var Scroll = /** @class */ (function (_super) {
  __extends(Scroll, _super);
  function Scroll() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  Scroll.run = function (scroller, payload) {
    var workflow = scroller.workflow, viewport = scroller.viewport;
    var position = viewport.scrollPosition;
    if (Scroll.onSynthetic(scroller, position)) {
      return;
    }
    Scroll.onThrottle(scroller, position, function () {
      return Scroll.onScroll(scroller, workflow);
    });
  };
  Scroll.onSynthetic = function (scroller, position) {
    var scrollState = scroller.state.scrollState;
    var synthPos = scrollState.syntheticPosition;
    if (synthPos !== null) {
      if (scrollState.syntheticFulfill) {
        scrollState.syntheticPosition = null;
      }
      if (!scrollState.syntheticFulfill || synthPos === position) {
        scroller.logger.log(function () { return [
          'skipping scroll', position,
          "[" + (scrollState.syntheticFulfill ? '' : 'pre-') + "synthetic]"
        ]; });
        return true;
      }
      scroller.logger.log(function () { return [
        'synthetic scroll has been fulfilled:', position, position < synthPos ? '<' : '>', synthPos
      ]; });
    }
    return false;
  };
  Scroll.onThrottle = function (scroller, position, done) {
    var scrollState = scroller.state.scrollState, throttle = scroller.settings.throttle, logger = scroller.logger;
    scrollState.current = Scroll.getScrollEvent(position, scrollState.previous);
    var _a = scrollState.current, direction = _a.direction, time = _a.time;
    var timeDiff = scrollState.previous ? time - scrollState.previous.time : Infinity;
    var delta = throttle - timeDiff;
    var shouldDelay = isFinite(delta) && delta > 0;
    var alreadyDelayed = !!scrollState.scrollTimer;
    logger.log(function () { return [
      direction === Direction.backward ? '\u2934' : '\u2935',
      position,
      shouldDelay ? (timeDiff + 'ms') : '0ms',
      shouldDelay ? (alreadyDelayed ? 'delayed' : "/ " + delta + "ms delay") : ''
    ]; });
    if (!shouldDelay) {
      if (scrollState.scrollTimer) {
        clearTimeout(scrollState.scrollTimer);
        scrollState.scrollTimer = null;
      }
      done();
      return;
    }
    if (!alreadyDelayed) {
      scrollState.scrollTimer = setTimeout(function () {
        logger.log(function () {
          var curr = Scroll.getScrollEvent(scroller.viewport.scrollPosition, scrollState.current);
          return [
            curr.direction === Direction.backward ? '\u2934' : '\u2935',
            curr.position,
            (curr.time - time) + 'ms',
            'triggered by timer set on',
            position
          ];
        });
        scrollState.scrollTimer = null;
        done();
      }, delta);
    }
  };
  Scroll.getScrollEvent = function (position, previous) {
    var time = Number(new Date());
    var direction = Direction.forward;
    if (previous) {
      if (position === previous.position) {
        direction = previous.direction;
      }
      else if (position < previous.position) {
        direction = Direction.backward;
      }
    }
    return { position: position, direction: direction, time: time };
  };
  Scroll.onScroll = function (scroller, workflow) {
    var _a = scroller.state, scrollState = _a.scrollState, cycle = _a.cycle;
    scrollState.previous = __assign({}, scrollState.current);
    scrollState.current = null;
    if (cycle.busy.get()) {
      scroller.logger.log(function () { return ['skipping scroll', scrollState.previous.position, '[pending]']; });
      return;
    }
    workflow.call({
      process: Scroll.process,
      status: ProcessStatus.next
    });
  };
  return Scroll;
}(BaseProcessFactory(CommonProcess.scroll)));

var Reset = /** @class */ (function (_super) {
  __extends(Reset, _super);
  function Reset() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Reset.run = function (scroller, options) {
    var datasource = scroller.datasource, buffer = scroller.buffer, paddings = scroller.viewport.paddings, cycle = scroller.state.cycle;
    if (options) {
      var data_1 = Reset.parseInput(scroller, options).data;
      if (!data_1.isValid) {
        return;
      }
      var constructed_1 = options instanceof Datasource;
      Object.keys(DatasourceProps).forEach(function (key) {
        var param = data_1.params[key];
        var ds = datasource;
        if (param.isSet || (constructed_1 && ds[key])) {
          ds[key] = param.value;
        }
      });
    }
    buffer.reset(true);
    paddings.backward.reset();
    paddings.forward.reset();
    var payload = { datasource: datasource };
    if (cycle.busy.get()) {
      payload.finalize = true;
      cycle.interrupter = Reset.process;
    }
    scroller.workflow.call({
      process: Reset.process,
      status: ProcessStatus.next,
      payload: payload
    });
  };
  return Reset;
}(BaseAdapterProcessFactory(AdapterProcess.reset)));

var Reload = /** @class */ (function (_super) {
  __extends(Reload, _super);
  function Reload() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Reload.run = function (scroller, reloadIndex) {
    var viewport = scroller.viewport, state = scroller.state, buffer = scroller.buffer;
    var params = Reload.parseInput(scroller, { reloadIndex: reloadIndex }, true).params;
    buffer.reset(false, params ? params.reloadIndex : void 0);
    viewport.reset(buffer.startIndex);
    var payload = {};
    if (state.cycle.busy.get()) {
      state.scrollState.cleanupTimers();
      payload.finalize = true;
      state.cycle.interrupter = Reload.process;
    }
    scroller.workflow.call({
      process: Reload.process,
      status: ProcessStatus.next,
      payload: payload
    });
  };
  return Reload;
}(BaseAdapterProcessFactory(AdapterProcess.reload)));

var Item = /** @class */ (function () {
  function Item($index, data, routines) {
    this.container = {
      $index: $index,
      data: data
    };
    this.nodeId = String($index);
    this.routines = routines;
    this.invisible = true;
    this.toRemove = false;
    this.toInsert = false;
  }
  Object.defineProperty(Item.prototype, "$index", {
    get: function () {
      return this.container.$index;
    },
    set: function (value) {
      this.container.$index = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Item.prototype, "data", {
    get: function () {
      return this.container.data;
    },
    set: function (value) {
      this.container.data = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Item.prototype, "element", {
    get: function () {
      return this.container.element;
    },
    set: function (value) {
      this.container.element = value;
    },
    enumerable: false,
    configurable: true
  });
  Item.prototype.dispose = function () {
    delete this.container.element;
  };
  Item.prototype.setSize = function () {
    this.size = this.routines.getSize(this.element);
  };
  Item.prototype.hide = function () {
    if (this.element) {
      this.routines.hideElement(this.element);
    }
  };
  Item.prototype.scrollTo = function (argument) {
    if (this.element) {
      this.routines.scrollTo(this.element, argument);
    }
  };
  Item.prototype.updateIndex = function (index) {
    this.$index = index;
    this.nodeId = String(index);
  };
  Item.prototype.get = function () {
    return this.container;
  };
  return Item;
}());

var Append = /** @class */ (function (_super) {
  __extends(Append, _super);
  function Append() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Append.run = function (scroller, _a) {
    var process = _a.process, options = _a.options;
    var params = Append.parseInput(scroller, options).params;
    if (!params) {
      return;
    }
    var items = params.items, bof = params.bof, eof = params.eof;
    var prepend = process !== AdapterProcess.append;
    var _eof = !!(prepend ? bof : eof);
    // virtual prepend case: shift abs min index and update viewport params
    if ((prepend && _eof && !scroller.buffer.bof.get()) ||
      (!prepend && _eof && !scroller.buffer.eof.get())) {
      Append.doVirtualize(scroller, items, prepend);
      scroller.workflow.call({
        process: Append.process,
        status: ProcessStatus.done
      });
      return;
    }
    Append.simulateFetch(scroller, items, _eof, prepend);
    scroller.workflow.call({
      process: Append.process,
      status: ProcessStatus.next
    });
  };
  Append.doVirtualize = function (scroller, items, prepend) {
    var buffer = scroller.buffer, paddings = scroller.viewport.paddings;
    var bufferToken = prepend ? 'absMinIndex' : 'absMaxIndex';
    if (isFinite(buffer[bufferToken])) {
      var size = items.length * buffer.defaultSize;
      var padding = prepend ? paddings.backward : paddings.forward;
      buffer[bufferToken] += (prepend ? -1 : 1) * items.length;
      padding.size += size;
      if (prepend) {
        scroller.viewport.scrollPosition += size;
      }
      scroller.logger.log(function () { return "buffer." + [bufferToken] + " value is set to " + buffer[bufferToken]; });
      scroller.logger.stat("after virtual " + (prepend ? 'prepend' : 'append'));
    }
  };
  Append.simulateFetch = function (scroller, items, eof, prepend) {
    var buffer = scroller.buffer, fetch = scroller.state.fetch;
    var bufferToken = prepend ? 'absMinIndex' : 'absMaxIndex';
    var indexToAdd = buffer.getIndexToAdd(eof, prepend);
    var bufferLimit = buffer[bufferToken];
    var newItems = [];
    for (var i = 0; i < items.length; i++) {
      var itemToAdd = new Item(indexToAdd, items[i], scroller.routines);
      if (isFinite(bufferLimit) && ((prepend && indexToAdd < bufferLimit) ||
        (!prepend && indexToAdd > bufferLimit))) {
        bufferLimit += (prepend ? -1 : 1);
      }
      (prepend ? Array.prototype.unshift : Array.prototype.push).apply(newItems, [itemToAdd]);
      // (prepend ? newItems.unshift : newItems.push)(itemToAdd);
      indexToAdd += (prepend ? -1 : 1);
    }
    if (bufferLimit !== buffer[bufferToken]) {
      buffer[bufferToken] = bufferLimit;
      scroller.logger.log(function () { return "buffer." + bufferToken + " value is set to " + buffer[bufferToken]; });
    }
    (prepend ? fetch.prepend : fetch.append).call(fetch, newItems);
    (prepend ? buffer.prepend : buffer.append).call(buffer, newItems);
    fetch.first.indexBuffer = !isNaN(buffer.firstIndex) ? buffer.firstIndex : indexToAdd;
    fetch.last.indexBuffer = !isNaN(buffer.lastIndex) ? buffer.lastIndex : indexToAdd;
    return true;
  };
  return Append;
}(BaseAdapterProcessFactory(AdapterProcess.append)));

var Check = /** @class */ (function (_super) {
  __extends(Check, _super);
  function Check() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Check.run = function (scroller) {
    var workflow = scroller.workflow, buffer = scroller.buffer, fetch = scroller.state.fetch, viewport = scroller.viewport;
    var min = Infinity, max = -Infinity;
    buffer.items.forEach(function (item) {
      var size = item.size;
      item.setSize();
      if (item.size !== size) {
        buffer.cacheItem(item);
        min = Math.min(min, item.$index);
        max = Math.max(max, item.$index);
      }
    });
    if (Number.isFinite(min)) {
      fetch.first.indexBuffer = buffer.firstIndex;
      fetch.last.indexBuffer = buffer.lastIndex;
      var _a = viewport.getEdgeVisibleItem(buffer.items, Direction.backward), firstIndex = _a.index, diff = _a.diff;
      fetch.firstVisibleIndex = firstIndex;
      if (!isNaN(firstIndex)) {
        fetch.firstVisibleItemDelta = -buffer.getSizeByIndex(firstIndex) + diff;
      }
      fetch.check(buffer.items.filter(function (item) { return item.$index >= min && item.$index <= max; }));
    }
    scroller.logger.stat('check');
    workflow.call({
      process: Check.process,
      status: Number.isFinite(min) ? ProcessStatus.next : ProcessStatus.done
    });
  };
  return Check;
}(BaseAdapterProcessFactory(AdapterProcess.check)));

var Remove = /** @class */ (function (_super) {
  __extends(Remove, _super);
  function Remove() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Remove.run = function (scroller, options) {
    var params = Remove.parseInput(scroller, options).params;
    if (!params) {
      return;
    }
    var shouldRemove = Remove.doRemove(scroller, params);
    scroller.workflow.call({
      process: Remove.process,
      status: shouldRemove ? ProcessStatus.next : ProcessStatus.done
    });
  };
  Remove.doRemove = function (scroller, params, sequenceOnly) {
    if (sequenceOnly === void 0) { sequenceOnly = false; }
    var fetch = scroller.state.fetch;
    fetch.firstVisibleIndex = NaN;
    var bufferRemoveList = Remove.removeBufferedItems(scroller, params);
    if (params.indexes && params.indexes.length) { // to avoid duplicate buffer-virtual removals
      params.indexes = params.indexes.filter(function (i) { return !bufferRemoveList.includes(i); });
    }
    var shouldRemoveBuffered = bufferRemoveList.length > 0;
    var shouldRemoveVirtual = Remove.removeVirtualItems(scroller, params, sequenceOnly);
    if (!shouldRemoveBuffered && !shouldRemoveVirtual) {
      return false;
    }
    if (!isNaN(fetch.firstVisibleIndex)) {
      fetch.remove();
    }
    scroller.logger.stat('after remove');
    return true;
  };
  Remove.removeBufferedItems = function (scroller, options) {
    var predicate = options.predicate, indexes = options.indexes, increase = options.increase;
    var result = [];
    if (predicate) {
      result = Remove.runPredicateOverBuffer(scroller, predicate, !!increase);
    }
    if (indexes) {
      var indexPredicate = function (_a) {
        var $index = _a.$index;
        return indexes.indexOf($index) >= 0;
      };
      result = Remove.runPredicateOverBuffer(scroller, indexPredicate, !!increase);
    }
    return result;
  };
  Remove.runPredicateOverBuffer = function (scroller, predicate, increase) {
    var viewport = scroller.viewport, buffer = scroller.buffer, items = scroller.buffer.items, fetch = scroller.state.fetch;
    // get items to remove
    var clipList = [];
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (predicate(item.get())) {
        clipList.push(item);
        item.toRemove = true;
      }
      else if (clipList.length) {
        break; // allow only first strict uninterrupted sequence
      }
    }
    if (!clipList.length) {
      return [];
    }
    // what item should be shown after remove (1-4)
    var firstClipIndex = clipList[0].$index, lastClipIndex = clipList[clipList.length - 1].$index;
    // 1) current first visible item will remain
    var _a = viewport.getEdgeVisibleItem(buffer.items, Direction.backward), firstIndex = _a.index, diff = _a.diff;
    if (firstIndex < firstClipIndex || firstIndex > lastClipIndex) {
      fetch.firstVisibleIndex = firstIndex;
      fetch.firstVisibleItemDelta = -buffer.getSizeByIndex(firstIndex) + diff;
    }
    // 2) next after the last removed item
    if (isNaN(fetch.firstVisibleIndex) && lastClipIndex < buffer.finiteAbsMaxIndex) {
      fetch.firstVisibleIndex = lastClipIndex + 1;
    }
    // 3) prev before the first removed item
    if (isNaN(fetch.firstVisibleIndex) && firstClipIndex > buffer.finiteAbsMinIndex) {
      fetch.firstVisibleIndex = firstClipIndex - 1;
    }
    // 4) prev before the first removed item
    if (isNaN(fetch.firstVisibleIndex)) {
      fetch.firstVisibleIndex = buffer.finiteAbsMinIndex;
    }
    // logical removal
    var indexListToRemove = clipList.map(function (item) { return item.$index; });
    scroller.logger.log(function () {
      return "going to remove " + clipList.length + " item(s) from Buffer: [" + indexListToRemove.join(',') + "]";
    });
    buffer.removeItems(indexListToRemove, increase, false);
    buffer.checkDefaultSize();
    Remove.shiftFirstVisibleIndex(scroller, indexListToRemove, increase);
    // physical removal (hiding)
    clipList.forEach(function (item) { return item.hide(); });
    return indexListToRemove;
  };
  Remove.removeVirtualItems = function (scroller, params, sequenceOnly) {
    var indexes = params.indexes, increase = params.increase;
    if (!indexes || !indexes.length) {
      return false;
    }
    var buffer = scroller.buffer, viewport = scroller.viewport, fetch = scroller.state.fetch;
    // get items to remove
    var finiteAbsMinIndex = buffer.finiteAbsMinIndex, firstIndex = buffer.firstIndex, finiteAbsMaxIndex = buffer.finiteAbsMaxIndex, lastIndex = buffer.lastIndex;
    var toRemove = [];
    var last = NaN;
    for (var i = 0, len = indexes.length; i < len; i++) {
      var index = indexes[i];
      if (index >= finiteAbsMinIndex && !isNaN(firstIndex) && index < firstIndex) {
        toRemove.push(index); // backward;
      }
      else if (index <= finiteAbsMaxIndex && !isNaN(lastIndex) && index > lastIndex) {
        toRemove.push(index); // forward;
      }
      else {
        continue;
      }
      if (sequenceOnly && !isNaN(last) && Math.abs(last - index) > 1) {
        // allow only first strict uninterrupted sequence
        break;
      }
      last = index;
    }
    if (!toRemove.length) {
      return false;
    }
    // what should be shown after remove; Buffer removal has priority
    if (isNaN(fetch.firstVisibleIndex)) {
      var _a = viewport.getEdgeVisibleItem(buffer.items, Direction.backward), index = _a.index, diff = _a.diff;
      if (!isNaN(index)) {
        fetch.firstVisibleIndex = index;
        fetch.firstVisibleItemDelta = -buffer.getSizeByIndex(index) + diff;
      }
    }
    // virtual removal
    scroller.logger.log(function () { return "going to remove " + toRemove.length + " item(s) virtually"; });
    buffer.removeItems(toRemove, !!increase, true);
    buffer.checkDefaultSize();
    Remove.shiftFirstVisibleIndex(scroller, toRemove, !!increase);
    return true;
  };
  Remove.shiftFirstVisibleIndex = function (_a, listToRemove, increase) {
    var fetch = _a.state.fetch;
    if (isNaN(fetch.firstVisibleIndex)) {
      return;
    }
    var shift = listToRemove.reduce(function (acc, index) { return acc + (((increase && index > fetch.firstVisibleIndex) || (!increase && index < fetch.firstVisibleIndex)) ? 1 : 0); }, 0);
    fetch.firstVisibleIndex = fetch.firstVisibleIndex + (increase ? shift : -shift);
  };
  return Remove;
}(BaseAdapterProcessFactory(AdapterProcess.remove)));

var UserClip = /** @class */ (function (_super) {
  __extends(UserClip, _super);
  function UserClip() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  UserClip.run = function (scroller, options) {
    var params = UserClip.parseInput(scroller, options).params;
    scroller.state.clip.forceForward = !(params && params.backwardOnly);
    scroller.state.clip.forceBackward = !(params && params.forwardOnly);
    scroller.workflow.call({
      process: UserClip.process,
      status: ProcessStatus.next
    });
  };
  return UserClip;
}(BaseAdapterProcessFactory(AdapterProcess.clip)));

var Update = /** @class */ (function (_super) {
  __extends(Update, _super);
  function Update() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Update.run = function (scroller, options) {
    var params = Update.parseInput(scroller, options).params;
    if (!params) {
      return;
    }
    var shouldUpdate = Update.doUpdate(scroller, params);
    scroller.workflow.call({
      process: Update.process,
      status: shouldUpdate ? ProcessStatus.next : ProcessStatus.done
    });
  };
  Update.doUpdate = function (scroller, params) {
    var buffer = scroller.buffer, viewport = scroller.viewport, fetch = scroller.state.fetch, routines = scroller.routines, logger = scroller.logger;
    if (!buffer.items) {
      logger.log(function () { return 'no items in Buffer'; });
      return false;
    }
    var before = __spreadArray([], __read(buffer.items));
    var _a = viewport.getEdgeVisibleItem(buffer.items, Direction.backward), firstItem = _a.item, firstIndex = _a.index, firstItemDiff = _a.diff;
    var trackedIndex = buffer.updateItems(params.predicate, function (index, data) { return new Item(index, data, routines); }, firstIndex, !!params.fixRight);
    var delta = 0;
    var trackedItem = buffer.get(trackedIndex);
    if (firstItem && firstItem === trackedItem) {
      delta = -buffer.getSizeByIndex(trackedIndex) + firstItemDiff;
    }
    var itemsToRemove = before.filter(function (_a) {
      var toRemove = _a.toRemove;
      return toRemove;
    });
    itemsToRemove.forEach(function (item) { return item.hide(); });
    logger.log(function () { return itemsToRemove.length
      ? 'items to remove: [' + itemsToRemove.map(function (_a) {
        var $index = _a.$index;
        return $index;
      }).join(',') + ']'
      : 'no items to remove'; });
    var itemsToRender = buffer.items.filter(function (_a) {
      var toInsert = _a.toInsert;
      return toInsert;
    });
    logger.log(function () { return itemsToRender.length
      ? 'items to render: [' + itemsToRender.map(function (_a) {
        var $index = _a.$index;
        return $index;
      }).join(',') + ']'
      : 'no items to render'; });
    fetch.update(trackedIndex, delta, itemsToRender, itemsToRemove);
    return !!itemsToRemove.length || !!itemsToRender.length;
  };
  return Update;
}(BaseAdapterProcessFactory(AdapterProcess.update)));

var Insert = /** @class */ (function (_super) {
  __extends(Insert, _super);
  function Insert() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Insert.run = function (scroller, options) {
    var params = Insert.parseInput(scroller, options).params;
    if (!params) {
      return;
    }
    var shouldInsert = Insert.doInsert(scroller, params);
    scroller.workflow.call({
      process: Insert.process,
      status: shouldInsert ? ProcessStatus.next : ProcessStatus.done
    });
  };
  Insert.doInsert = function (scroller, params) {
    var before = params.before, after = params.after, items = params.items, decrease = params.decrease;
    var method = (before || after);
    var found = scroller.buffer.items.find(function (item) { return method(item.get()); });
    if (!found) {
      scroller.logger.log('no item to insert found');
      return false;
    }
    var indexToInsert = found.$index;
    var updateOptions = {
      predicate: function (_a) {
        var $index = _a.$index, data = _a.data;
        if (indexToInsert === $index) {
          return before ? __spreadArray(__spreadArray([], __read(items)), [data]) : __spreadArray([data], __read(items));
        }
        return true;
      },
      fixRight: decrease
    };
    return Update.doUpdate(scroller, updateOptions);
  };
  return Insert;
}(BaseAdapterProcessFactory(AdapterProcess.insert)));

var Replace = /** @class */ (function (_super) {
  __extends(Replace, _super);
  function Replace() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Replace.run = function (scroller, options) {
    var params = Replace.parseInput(scroller, options).params;
    if (!params) {
      return;
    }
    var shouldReplace = Replace.doReplace(scroller, params);
    scroller.workflow.call({
      process: Replace.process,
      status: shouldReplace ? ProcessStatus.next : ProcessStatus.done,
    });
  };
  Replace.doReplace = function (scroller, params) {
    var toRemove = scroller.buffer.items
      .filter(function (item) { return params.predicate(item); })
      .map(function (item) { return item.$index; });
    if (!toRemove.length) {
      scroller.logger.log('no items to be replaced');
      return false;
    }
    var injected = false;
    var updateOptions = {
      predicate: function (_a) {
        var $index = _a.$index;
        if (!toRemove.includes($index)) {
          return true;
        }
        if (!injected) {
          injected = true;
          return params.items;
        }
        return false;
      },
      fixRight: params.fixRight
    };
    return Update.doUpdate(scroller, updateOptions);
  };
  return Replace;
}(BaseAdapterProcessFactory(AdapterProcess.replace)));

var _a = AdapterMethods, _b = AdapterProcess.fix, FixParams = _a[_b];
var Fix = /** @class */ (function (_super) {
  __extends(Fix, _super);
  function Fix() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Fix.run = function (scroller, options) {
    var workflow = scroller.workflow;
    var _a = Fix.parseInput(scroller, options), data = _a.data, params = _a.params;
    if (!params) {
      return;
    }
    Object.entries(data.params).forEach(function (_a) {
      var _b = __read(_a, 2), key = _b[0], value = _b[1];
      if (value.isSet && value.isValid) {
        Fix.runByType(scroller, key, value.value, data);
      }
    });
    workflow.call({
      process: Fix.process,
      status: ProcessStatus.done
    });
  };
  Fix.runByType = function (scroller, token, value, methodData) {
    switch (token) {
      case FixParams.scrollPosition:
        return Fix.setScrollPosition(scroller, value);
      case FixParams.minIndex:
        return Fix.setMinIndex(scroller, value);
      case FixParams.maxIndex:
        return Fix.setMaxIndex(scroller, value);
      case FixParams.updater:
        return Fix.updateItems(scroller, value);
      case FixParams.scrollToItem:
        if (methodData.params) {
          var scrollToItemOpt = methodData.params[FixParams.scrollToItemOpt];
          var options = scrollToItemOpt ? scrollToItemOpt.value : void 0;
          return Fix.scrollToItem(scroller, value, options);
        }
        return;
      case FixParams.scrollToItemOpt:
        return;
    }
  };
  Fix.setScrollPosition = function (_a, value) {
    var viewport = _a.viewport;
    var result = value;
    if (value === -Infinity) {
      result = 0;
    }
    else if (value === Infinity) {
      result = viewport.getScrollableSize();
    }
    viewport.setPosition(result);
  };
  Fix.setMinIndex = function (_a, value) {
    var buffer = _a.buffer, settings = _a.settings;
    settings.minIndex = value;
    buffer.absMinIndex = value;
  };
  Fix.setMaxIndex = function (_a, value) {
    var buffer = _a.buffer, settings = _a.settings;
    settings.maxIndex = value;
    buffer.absMaxIndex = value;
  };
  Fix.updateItems = function (_a, value) {
    var buffer = _a.buffer, logger = _a.logger;
    var updateReference = false;
    var updater = function () { return updateReference = true; };
    buffer.items.forEach(function (item) { return value(item.get(), updater); });
    if (updateReference) {
      logger.log(function () { return 'update Buffer.items reference'; });
      buffer.items = __spreadArray([], __read(buffer.items));
    }
  };
  Fix.scrollToItem = function (scroller, value, options) {
    var found = scroller.buffer.items.find(function (item) { return value(item.get()); });
    if (!found) {
      scroller.logger.log(function () { return 'scrollToItem cancelled, item not found'; });
      return;
    }
    found.scrollTo(options);
  };
  return Fix;
}(BaseAdapterProcessFactory(AdapterProcess.fix)));

var Start = /** @class */ (function (_super) {
  __extends(Start, _super);
  function Start() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Start.run = function (scroller) {
    var payload = scroller.state.startInnerLoop();
    scroller.workflow.call({
      process: Start.process,
      status: ProcessStatus.next,
      payload: payload
    });
  };
  return Start;
}(BaseProcessFactory(CommonProcess.start)));

var PreFetch = /** @class */ (function (_super) {
  __extends(PreFetch, _super);
  function PreFetch() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PreFetch.run = function (scroller) {
    var workflow = scroller.workflow, buffer = scroller.buffer, _a = scroller.state, fetch = _a.fetch, cycle = _a.cycle;
    fetch.minIndex = buffer.minIndex;
    // set first and last indexes of items to fetch
    PreFetch.setPositionsAndIndexes(scroller);
    // skip indexes that are in buffer
    PreFetch.skipBufferedItems(scroller);
    if (scroller.settings.infinite) {
      // fill indexes to include buffer if no clip
      PreFetch.checkBufferGaps(scroller);
    }
    // add indexes if there are too few items to fetch (clip padding)
    PreFetch.checkFetchPackSize(scroller);
    // set fetch direction
    PreFetch.setFetchDirection(scroller);
    workflow.call({
      process: PreFetch.process,
      status: PreFetch.getStatus(scroller),
      payload: { process: cycle.initiator }
    });
  };
  PreFetch.setPositionsAndIndexes = function (scroller) {
    PreFetch.setPositions(scroller);
    PreFetch.setFirstIndex(scroller);
    PreFetch.setLastIndex(scroller);
    scroller.logger.fetch();
  };
  PreFetch.setPositions = function (scroller) {
    var positions = scroller.state.fetch.positions, viewport = scroller.viewport;
    var paddingDelta = viewport.getBufferPadding();
    positions.before = viewport.scrollPosition;
    positions.startDelta = PreFetch.getStartDelta(scroller);
    positions.relative = positions.before - positions.startDelta;
    positions.start = positions.relative - paddingDelta;
    positions.end = positions.relative + viewport.getSize() + paddingDelta;
  };
  PreFetch.getStartDelta = function (scroller) {
    var buffer = scroller.buffer, offset = scroller.viewport.offset;
    var startDelta = 0;
    if (offset) {
      startDelta += offset;
    }
    if (!buffer.defaultSize) {
      return startDelta;
    }
    for (var index = buffer.finiteAbsMinIndex; index < buffer.startIndex; index++) {
      startDelta += buffer.getSizeByIndex(index);
    }
    scroller.logger.log(function () { return __spreadArray([
      "start delta is " + startDelta
    ], __read((offset ? [" (+" + offset + " offset)"] : []))); });
    return startDelta;
  };
  PreFetch.setFirstIndex = function (scroller) {
    var state = scroller.state, buffer = scroller.buffer;
    var _a = state.fetch, start = _a.positions.start, first = _a.first;
    var firstIndex = buffer.startIndex;
    var firstIndexPosition = 0;
    if (state.cycle.innerLoop.isInitial) {
      scroller.logger.log('skipping fetch backward direction [initial loop]');
    }
    else if (!buffer.defaultSize) {
      scroller.logger.log('skipping fetch backward direction [no item size]');
    }
    else {
      var position = firstIndexPosition;
      var index = firstIndex;
      while (1) { // eslint-disable-line no-constant-condition
        if (start >= 0) {
          var size = buffer.getSizeByIndex(index);
          var diff = (position + size) - start;
          if (diff > 0) {
            firstIndex = index;
            firstIndexPosition = position;
            break;
          }
          position += size;
          index++;
          if (index < buffer.absMinIndex) {
            break;
          }
        }
        if (start < 0) {
          index--;
          if (index < buffer.absMinIndex) {
            break;
          }
          position -= buffer.getSizeByIndex(index);
          var diff = position - start;
          firstIndex = index;
          firstIndexPosition = position;
          if (diff <= 0) {
            break;
          }
        }
      }
    }
    first.index = first.indexBuffer = Math.max(firstIndex, buffer.absMinIndex);
    first.position = firstIndexPosition;
  };
  PreFetch.setLastIndex = function (scroller) {
    var _a = scroller.state, fetch = _a.fetch, cycle = _a.cycle, buffer = scroller.buffer, settings = scroller.settings;
    var _b = fetch.positions, relative = _b.relative, end = _b.end, first = fetch.first, last = fetch.last;
    var lastIndex;
    if (!buffer.defaultSize) {
      // just to fetch forward bufferSize items if neither averageItemSize nor itemSize are present
      lastIndex = buffer.startIndex + settings.bufferSize - 1;
      scroller.logger.log('forcing fetch forward direction [no item size]');
    }
    else {
      var index = first.indexBuffer;
      var position = first.position;
      lastIndex = index;
      while (1) { // eslint-disable-line no-constant-condition
        lastIndex = index;
        var size = buffer.getSizeByIndex(index);
        position += size;
        if (isNaN(fetch.firstVisibleIndex) && position > relative) {
          fetch.firstVisibleIndex = index;
          if (!cycle.innerLoop.isInitial) {
            fetch.firstVisibleItemDelta = position - size - relative;
          }
        }
        if (position >= end) {
          break;
        }
        if (index++ > buffer.absMaxIndex) {
          break;
        }
      }
    }
    last.index = last.indexBuffer = Math.min(lastIndex, buffer.absMaxIndex);
  };
  PreFetch.skipBufferedItems = function (scroller) {
    var buffer = scroller.buffer;
    if (!buffer.size) {
      return;
    }
    var fetch = scroller.state.fetch;
    var firstIndex = fetch.first.index;
    var lastIndex = fetch.last.index;
    var packs = [[]];
    var p = 0;
    for (var i = firstIndex; i <= lastIndex; i++) {
      if (!buffer.get(i)) {
        packs[p].push(i);
      }
      else if (packs[p].length) {
        packs[++p] = [];
      }
    }
    var pack = packs[0];
    if (packs[0].length && packs[1] && packs[1].length) {
      fetch.hasAnotherPack = true;
      // todo: need to look for biggest pack in visible area
      // todo: or think about merging two requests in a single Fetch process
      if (packs[1].length >= packs[0].length) {
        pack = packs[1];
      }
    }
    fetch.first.index = Math.max(pack[0], buffer.absMinIndex);
    fetch.last.index = Math.min(pack[pack.length - 1], buffer.absMaxIndex);
    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {
      scroller.logger.fetch('after Buffer flushing');
    }
  };
  PreFetch.checkBufferGaps = function (scroller) {
    var buffer = scroller.buffer, fetch = scroller.state.fetch;
    if (!buffer.size) {
      return;
    }
    var fetchFirst = fetch.first.index;
    var bufferLast = buffer.lastIndex;
    if (fetchFirst > bufferLast) {
      fetch.first.index = fetch.first.indexBuffer = bufferLast + 1;
    }
    var bufferFirst = buffer.firstIndex;
    var fetchLast = fetch.last.index;
    if (fetchLast < bufferFirst) {
      fetch.last.index = fetch.last.indexBuffer = bufferFirst - 1;
    }
    if (fetch.first.index !== fetchFirst || fetch.last.index !== fetchLast) {
      scroller.logger.fetch('after Buffer filling (no clip case)');
    }
  };
  PreFetch.checkFetchPackSize = function (scroller) {
    var buffer = scroller.buffer, fetch = scroller.state.fetch;
    if (!fetch.shouldFetch) {
      return;
    }
    var firstIndex = fetch.first.index;
    var lastIndex = fetch.last.index;
    var diff = scroller.settings.bufferSize - (lastIndex - firstIndex + 1);
    if (diff <= 0) {
      return;
    }
    if (!buffer.size || lastIndex > buffer.items[0].$index) { // forward
      var newLastIndex = Math.min(lastIndex + diff, buffer.absMaxIndex);
      if (newLastIndex > lastIndex) {
        fetch.last.index = fetch.last.indexBuffer = newLastIndex;
      }
    }
    else {
      var newFirstIndex = Math.max(firstIndex - diff, buffer.absMinIndex);
      if (newFirstIndex < firstIndex) {
        fetch.first.index = fetch.first.indexBuffer = newFirstIndex;
      }
    }
    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {
      scroller.logger.fetch('after bufferSize adjustment');
      PreFetch.skipBufferedItems(scroller);
    }
  };
  PreFetch.setFetchDirection = function (scroller) {
    var buffer = scroller.buffer, fetch = scroller.state.fetch;
    if (fetch.last.index) {
      var direction_1 = Direction.forward;
      if (buffer.size) {
        direction_1 = fetch.last.index < buffer.items[0].$index ? Direction.backward : Direction.forward;
      }
      fetch.direction = direction_1;
      scroller.logger.log(function () { return "fetch direction is \"" + direction_1 + "\""; });
    }
  };
  PreFetch.getStatus = function (scroller) {
    var _a = scroller.state, cycle = _a.cycle, fetch = _a.fetch;
    if (cycle.initiator === AdapterProcess.clip) {
      scroller.logger.log(function () { return "going to skip fetch due to \"" + AdapterProcess.clip + "\" process"; });
      return ProcessStatus.next;
    }
    if (fetch.shouldFetch) {
      scroller.logger.log(function () { return "going to fetch " + fetch.count + " items started from index " + fetch.index; });
      return ProcessStatus.next;
    }
    return ProcessStatus.done;
  };
  return PreFetch;
}(BaseProcessFactory(CommonProcess.preFetch)));

var Fetch = /** @class */ (function (_super) {
  __extends(Fetch, _super);
  function Fetch() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Fetch.run = function (scroller) {
    var workflow = scroller.workflow;
    var box = {
      success: function (data) {
        scroller.logger.log(function () {
          return "resolved " + data.length + " items " +
            ("(index = " + scroller.state.fetch.index + ", count = " + scroller.state.fetch.count + ")");
        });
        scroller.state.fetch.newItemsData = data;
        workflow.call({
          process: Fetch.process,
          status: ProcessStatus.next
        });
      },
      fail: function (error) {
        return workflow.call({
          process: Fetch.process,
          status: ProcessStatus.error,
          payload: { error: error }
        });
      }
    };
    var result = Fetch.get(scroller);
    Fetch.complete(scroller, box, result);
  };
  Fetch.complete = function (scroller, box, result) {
    if (Object.prototype.hasOwnProperty.call(result, 'data')) {
      var _a = result, data = _a.data, error = _a.error, isError = _a.isError;
      if (!isError) {
        box.success(data || []);
      }
      else {
        box.fail(error);
      }
    }
    else {
      var _b = scroller.state, scrollState = _b.scrollState, fetch_1 = _b.fetch, viewport = scroller.viewport;
      if (scrollState.positionBeforeAsync === null) {
        scrollState.positionBeforeAsync = viewport.scrollPosition;
      }
      fetch_1.cancel = function () {
        box.success = function () { return null; };
        box.fail = function () { return null; };
      };
      result.then(function (data) { return box.success(data); }, function (error) { return box.fail(error); });
    }
  };
  Fetch.get = function (scroller) {
    var _get = scroller.datasource.get;
    var _a = scroller.state.fetch, index = _a.index, count = _a.count;
    var immediateData, immediateError;
    var resolve, reject;
    var done = function (data) {
      if (!resolve) {
        immediateData = data || null;
        return;
      }
      resolve(data);
    };
    var fail = function (error) {
      if (!reject) {
        immediateError = error || null;
        return;
      }
      reject(error);
    };
    var getResult = _get(index, count, done, fail);
    if (getResult && typeof getResult === 'object' && getResult !== null) {
      if (typeof getResult.then === 'function') {
        return getResult;
      }
      else if (typeof getResult.subscribe === 'function') {
        var sub_1 = getResult.subscribe(done, fail, function () {
          if (sub_1 && typeof sub_1 === 'object' && typeof sub_1.unsubscribe === 'function') {
            sub_1.unsubscribe();
          }
        });
      }
    }
    if (immediateData || immediateError) { // callback case or immediate observable
      return {
        data: immediateError ? null : (immediateData || []),
        error: immediateError,
        isError: !!immediateError
      };
    }
    return new Promise(function (_resolve, _reject) {
      resolve = _resolve;
      reject = _reject;
    });
  };
  return Fetch;
}(BaseProcessFactory(CommonProcess.fetch)));

var PostFetch = /** @class */ (function (_super) {
  __extends(PostFetch, _super);
  function PostFetch() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PostFetch.run = function (scroller) {
    var workflow = scroller.workflow;
    if (PostFetch.setItems(scroller)) {
      PostFetch.setBufferLimits(scroller);
      workflow.call({
        process: PostFetch.process,
        status: scroller.state.fetch.hasNewItems
          ? ProcessStatus.next
          : ProcessStatus.done
      });
    }
    else {
      workflow.call({
        process: PostFetch.process,
        status: ProcessStatus.error,
        payload: { error: 'Can\'t set buffer items' }
      });
    }
  };
  PostFetch.setBufferLimits = function (scroller) {
    var buffer = scroller.buffer, _a = scroller.state, fetch = _a.fetch, items = _a.fetch.items, innerLoop = _a.cycle.innerLoop;
    var first = fetch.first.index;
    var last = fetch.last.index;
    if (!items.length) {
      if (last < buffer.minIndex || innerLoop.isInitial) {
        buffer.absMinIndex = buffer.minIndex;
      }
      if (first > buffer.maxIndex || innerLoop.isInitial) {
        buffer.absMaxIndex = buffer.maxIndex;
      }
    }
    else {
      var lastIndex = items.length - 1;
      if (first < items[0].$index) {
        buffer.absMinIndex = items[0].$index;
      }
      if (last > items[lastIndex].$index) {
        buffer.absMaxIndex = items[lastIndex].$index;
      }
    }
  };
  PostFetch.setItems = function (scroller) {
    var buffer = scroller.buffer, _a = scroller.state, fetch = _a.fetch, cycle = _a.cycle;
    var items = fetch.newItemsData;
    if (!items || !items.length) { // empty result
      return true;
    }
    // eof/bof case, need to shift fetch index if bof
    var fetchIndex = fetch.index;
    if (items.length < fetch.count) {
      if (cycle.innerLoop.isInitial) {
        // let's treat initial poor fetch as startIndex-bof
        fetchIndex = buffer.startIndex;
      }
      else if (fetch.first.index < buffer.minIndex) { // normal bof
        fetchIndex = buffer.minIndex - items.length;
      }
    }
    fetch.items = items.map(function (item, index) {
      return new Item(fetchIndex + index, item, scroller.routines);
    });
    fetch.isPrepend = !!buffer.items.length && buffer.items[0].$index > fetch.items[fetch.items.length - 1].$index;
    return buffer.setItems(fetch.items);
  };
  return PostFetch;
}(BaseProcessFactory(CommonProcess.postFetch)));

var Render = /** @class */ (function (_super) {
  __extends(Render, _super);
  function Render() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Render.run = function (scroller) {
    var workflow = scroller.workflow, _a = scroller.state, cycle = _a.cycle, render = _a.render, scrollState = _a.scrollState, viewport = scroller.viewport;
    scroller.logger.stat('before new items render');
    if (scrollState.positionBeforeAsync === null) {
      scrollState.positionBeforeAsync = viewport.scrollPosition;
    }
    render.renderTimer = setTimeout(function () {
      render.renderTimer = null;
      if (Render.doRender(scroller)) {
        workflow.call({
          process: Render.process,
          status: render.noSize ? ProcessStatus.done : ProcessStatus.next,
          payload: { process: cycle.initiator }
        });
      }
      else {
        workflow.call({
          process: Render.process,
          status: ProcessStatus.error,
          payload: { error: 'Can\'t associate item with element' }
        });
      }
    }, 0);
  };
  Render.doRender = function (scroller) {
    var _a = scroller.state, fetch = _a.fetch, render = _a.render, viewport = scroller.viewport, buffer = scroller.buffer, logger = scroller.logger;
    render.positionBefore = viewport.scrollPosition;
    if (!fetch.isCheck) {
      render.sizeBefore = viewport.getScrollableSize();
      if (fetch.items.map(function (item) { return Render.processElement(scroller, item); }).some(function (x) { return !x; })) {
        return false;
      }
    }
    buffer.checkDefaultSize();
    render.sizeAfter = viewport.getScrollableSize();
    logger.stat('after new items render');
    logger.log(function () { return render.noSize ? 'viewport size has not been changed' : void 0; });
    return true;
  };
  Render.processElement = function (scroller, item) {
    var fetch = scroller.state.fetch, viewport = scroller.viewport, buffer = scroller.buffer;
    var element = viewport.element.querySelector("[data-sid=\"" + item.nodeId + "\"]");
    if (!element) {
      return false;
    }
    item.element = element;
    item.element.style.left = '';
    item.element.style.top = '';
    item.element.style.position = '';
    item.invisible = false;
    item.setSize();
    buffer.cacheItem(item);
    if (item.$index < fetch.minIndex) {
      fetch.negativeSize += item.size;
    }
    return true;
  };
  return Render;
}(BaseProcessFactory(CommonProcess.render)));

var Adjust = /** @class */ (function (_super) {
  __extends(Adjust, _super);
  function Adjust() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Adjust.run = function (scroller) {
    var workflow = scroller.workflow, viewport = scroller.viewport, scrollState = scroller.state.scrollState;
    scrollState.positionBeforeAdjust = viewport.scrollPosition;
    Adjust.setPaddings(scroller);
    scrollState.positionAfterAdjust = viewport.scrollPosition;
    // scroll position adjustments
    var position = Adjust.calculatePosition(scroller);
    // set new position using animation frame
    Adjust.setPosition(scroller, position, function () {
      return workflow.call({
        process: Adjust.process,
        status: ProcessStatus.done
      });
    });
  };
  Adjust.setPaddings = function (scroller) {
    var viewport = scroller.viewport, buffer = scroller.buffer, inverse = scroller.settings.inverse, fetch = scroller.state.fetch;
    var firstItem = buffer.getFirstVisibleItem();
    var lastItem = buffer.getLastVisibleItem();
    var first, last;
    if (firstItem && lastItem) {
      first = firstItem.$index;
      last = lastItem.$index;
    }
    else {
      first = !isNaN(fetch.firstVisibleIndex) ? fetch.firstVisibleIndex : buffer.startIndex;
      last = first - 1;
    }
    var _a = viewport.paddings, forward = _a.forward, backward = _a.backward;
    var index, bwdSize = 0, fwdSize = 0;
    // new backward and forward paddings size
    for (index = buffer.finiteAbsMinIndex; index < first; index++) {
      bwdSize += buffer.getSizeByIndex(index);
    }
    for (index = last + 1; index <= buffer.finiteAbsMaxIndex; index++) {
      fwdSize += buffer.getSizeByIndex(index);
    }
    // lack of items case
    var bufferSize = viewport.getScrollableSize() - forward.size - backward.size;
    var viewportSizeDiff = viewport.getSize() - (bwdSize + bufferSize + fwdSize);
    if (viewportSizeDiff > 0) {
      if (inverse) {
        bwdSize += viewportSizeDiff;
      }
      else {
        fwdSize += viewportSizeDiff;
      }
      scroller.logger.log(function () {
        return inverse ? 'backward' : 'forward' + (" padding will be increased by " + viewportSizeDiff + " to fill the viewport");
      });
    }
    backward.size = bwdSize;
    forward.size = fwdSize;
    scroller.logger.stat('after paddings adjustments');
  };
  Adjust.calculatePosition = function (scroller) {
    var viewport = scroller.viewport, buffer = scroller.buffer, state = scroller.state;
    var fetch = state.fetch, render = state.render, scrollState = state.scrollState;
    var position = viewport.paddings.backward.size;
    // backward outlet increase
    if (!isNaN(fetch.firstVisibleIndex) && !isNaN(buffer.firstIndex)) {
      for (var i = buffer.firstIndex; i < fetch.firstVisibleIndex; i++) {
        position += buffer.getSizeByIndex(i);
      }
      if (fetch.firstVisibleItemDelta) {
        position -= fetch.firstVisibleItemDelta;
      }
    }
    else {
      if (fetch.isPrepend && fetch.negativeSize) {
        position += fetch.negativeSize;
      }
    }
    // change per slow fetch/render
    if (scrollState.positionBeforeAsync !== null) {
      var diff = render.positionBefore - scrollState.positionBeforeAsync;
      if (diff !== 0) {
        scroller.logger.log("shift position due to fetch-render difference (" + diff + ")");
        position += diff;
      }
    }
    // offset increase
    if (viewport.offset > 0 && (position || fetch.positions.before)) {
      position += viewport.offset;
    }
    return Math.round(position);
  };
  Adjust.setPosition = function (scroller, position, done) {
    var scrollState = scroller.state.scrollState, viewport = scroller.viewport;
    if (!scrollState.hasPositionChanged(position)) {
      return done();
    }
    scrollState.syntheticPosition = position;
    scrollState.syntheticFulfill = false;
    scrollState.animationFrameId = requestAnimationFrame(function () {
      var inertiaDiff = scrollState.positionAfterAdjust - viewport.scrollPosition;
      var diffLog = '';
      if (inertiaDiff > 0) {
        position -= inertiaDiff;
        scrollState.syntheticPosition = position;
        diffLog = " (-" + inertiaDiff + ")";
      }
      scrollState.syntheticFulfill = true;
      viewport.scrollPosition = position;
      scroller.logger.stat('after scroll adjustment' + diffLog);
      done();
    });
  };
  return Adjust;
}(BaseProcessFactory(CommonProcess.adjust)));

var PreClip = /** @class */ (function (_super) {
  __extends(PreClip, _super);
  function PreClip() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PreClip.run = function (scroller) {
    PreClip.prepareClip(scroller);
    scroller.workflow.call({
      process: PreClip.process,
      status: ProcessStatus.next,
      payload: {
        doClip: scroller.state.clip.doClip
      }
    });
  };
  PreClip.prepareClip = function (scroller) {
    var _a = scroller.state, fetch = _a.fetch, clip = _a.clip;
    if (PreClip.shouldNotClip(scroller)) {
      return;
    }
    var firstIndex = fetch.first.indexBuffer;
    var lastIndex = fetch.last.indexBuffer;
    scroller.logger.log(function () {
      return "looking for " + (fetch.direction ? 'anti-' + fetch.direction + ' ' : '') + "items " +
        ("that are out of [" + firstIndex + ".." + lastIndex + "] range");
    });
    if (PreClip.isBackward(scroller, firstIndex)) {
      PreClip.prepareClipByDirection(scroller, Direction.backward, firstIndex);
    }
    if (PreClip.isForward(scroller, lastIndex)) {
      PreClip.prepareClipByDirection(scroller, Direction.forward, lastIndex);
    }
    if (!clip.doClip) {
      scroller.logger.log('skipping clip [no items to clip]');
    }
    return;
  };
  PreClip.shouldNotClip = function (scroller) {
    var settings = scroller.settings, buffer = scroller.buffer, state = scroller.state;
    if (settings.infinite && !state.clip.force) {
      scroller.logger.log('skipping clip [infinite mode]');
      return true;
    }
    if (!buffer.size) {
      scroller.logger.log('skipping clip [empty buffer]');
      return true;
    }
    if (state.cycle.isInitial) {
      scroller.logger.log('skipping clip [initial cycle]');
      return true;
    }
    return false;
  };
  PreClip.isBackward = function (scroller, firstIndex) {
    var buffer = scroller.buffer, _a = scroller.state, clip = _a.clip, fetch = _a.fetch;
    if (clip.force) {
      return clip.forceBackward;
    }
    if (fetch.direction !== Direction.backward) {
      if (firstIndex - 1 >= buffer.absMinIndex) {
        return true;
      }
    }
    return false;
  };
  PreClip.isForward = function (scroller, lastIndex) {
    var buffer = scroller.buffer, _a = scroller.state, clip = _a.clip, fetch = _a.fetch;
    if (clip.force) {
      return clip.forceForward;
    }
    if (fetch.direction !== Direction.forward) {
      if (lastIndex + 1 <= buffer.absMaxIndex) {
        return true;
      }
    }
    return false;
  };
  PreClip.prepareClipByDirection = function (scroller, direction, edgeIndex) {
    var forward = direction === Direction.forward;
    scroller.buffer.items.forEach(function (item) {
      if ((!forward && item.$index < edgeIndex) ||
        (forward && item.$index > edgeIndex)) {
        item.toRemove = true;
        item.removeDirection = direction;
        scroller.state.clip.doClip = true;
      }
    });
  };
  return PreClip;
}(BaseProcessFactory(CommonProcess.preClip)));

var Clip = /** @class */ (function (_super) {
  __extends(Clip, _super);
  function Clip() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Clip.run = function (scroller) {
    var workflow = scroller.workflow;
    Clip.doClip(scroller);
    workflow.call({
      process: Clip.process,
      status: ProcessStatus.next
    });
  };
  Clip.doClip = function (scroller) {
    var _a;
    var buffer = scroller.buffer, paddings = scroller.viewport.paddings, clip = scroller.state.clip, logger = scroller.logger;
    var size = (_a = {}, _a[Direction.backward] = 0, _a[Direction.forward] = 0, _a);
    logger.stat("before clip (" + ++clip.callCount + ")");
    var itemsToRemove = buffer.items.filter(function (item) {
      if (!item.toRemove) {
        return false;
      }
      item.hide();
      size[item.removeDirection] += item.size;
      return true;
    });
    if (itemsToRemove.length) {
      if (size[Direction.backward]) {
        paddings.byDirection(Direction.backward).size += size[Direction.backward];
      }
      if (size[Direction.forward]) {
        paddings.byDirection(Direction.forward).size += size[Direction.forward];
      }
      if (scroller.settings.onBeforeClip) {
        scroller.settings.onBeforeClip(itemsToRemove.map(function (item) { return item.get(); }));
      }
    }
    buffer.clip();
    logger.log(function () {
      var list = itemsToRemove.map(function (_a) {
        var $index = _a.$index;
        return $index;
      });
      return list.length
        ? [
          "clipped " + list.length + " item(s) from Buffer" +
            (size.backward ? ", +" + size.backward + " fwd px" : '') +
            (size.forward ? ", +" + size.forward + " bwd px" : '') +
            (", range: [" + list[0] + ".." + list[list.length - 1] + "]")
        ]
        : 'clipped 0 items from Buffer';
    });
    logger.stat('after clip');
  };
  return Clip;
}(BaseProcessFactory(CommonProcess.clip)));

var isInterrupted = function (_a) {
  var call = _a.call;
  return !!call.interrupted;
};
var End = /** @class */ (function (_super) {
  __extends(End, _super);
  function End() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  End.run = function (scroller, _a) {
    var _b = _a === void 0 ? {} : _a, error = _b.error;
    var workflow = scroller.workflow, interrupter = scroller.state.cycle.interrupter;
    if (!error && !interrupter) {
      // set out params accessible via Adapter
      End.calculateParams(scroller, workflow);
    }
    // explicit interruption for we don't want to go through the inner loop finalizing
    if (isInterrupted(workflow)) {
      workflow.call({ process: End.process, status: ProcessStatus.done });
      return;
    }
    var next = End.finalizeInnerLoop(scroller, error);
    workflow.call({
      process: End.process,
      status: next ? ProcessStatus.next : ProcessStatus.done,
      payload: __assign({}, (interrupter ? { process: interrupter } : {}))
    });
  };
  End.calculateParams = function (scroller, workflow) {
    var adapter = scroller.adapter, viewport = scroller.viewport, items = scroller.buffer.items;
    if (adapter.wanted.firstVisible) {
      var item = viewport.getEdgeVisibleItem(items, Direction.backward).item;
      if (!item || item.element !== adapter.firstVisible.element) {
        adapter.firstVisible = item ? item.get() : EMPTY_ITEM;
      }
    }
    // the workflow can be interrupter on firstVisible change
    if (adapter.wanted.lastVisible && !isInterrupted(workflow)) {
      var item = viewport.getEdgeVisibleItem(items, Direction.forward).item;
      if (!item || item.element !== adapter.lastVisible.element) {
        adapter.lastVisible = item ? item.get() : EMPTY_ITEM;
      }
    }
  };
  End.finalizeInnerLoop = function (scroller, error) {
    var state = scroller.state, _a = scroller.state, cycle = _a.cycle, clip = _a.clip, fetch = _a.fetch;
    var next = !!cycle.interrupter || (error ? false : End.getNext(scroller));
    cycle.innerLoop.isInitial = false;
    fetch.stopSimulate();
    clip.reset(true);
    state.endInnerLoop();
    return next;
  };
  End.getNext = function (scroller) {
    var _a = scroller.state, fetch = _a.fetch, render = _a.render;
    if (fetch.simulate && fetch.isCheck && !render.noSize) { // Adapter.check
      return true;
    }
    if (fetch.simulate && fetch.doRemove) { // Adapter.remove or Adapter.update with clip
      return true;
    }
    if ( // common inner loop (App start, Scroll, Adapter.clip) accompanied by fetch
    !fetch.simulate && ((fetch.hasNewItems && !render.noSize) || fetch.hasAnotherPack)) {
      return true;
    }
    return false;
  };
  return End;
}(BaseProcessFactory(CommonProcess.end)));

var Logger = /** @class */ (function () {
  function Logger(scroller, packageInfo, adapter) {
    var _this = this;
    this.logs = [];
    this.logAdapterMethod = function (methodName, args, add) {
      if (!_this.debug) {
        return;
      }
      var params = (args === void 0 ? [] : (Array.isArray(args) ? args : [args]))
        .map(function (arg) {
        if (typeof arg === 'function') {
          return 'func';
        }
        else if (typeof arg !== 'object' || !arg) {
          return arg;
        }
        else if (Array.isArray(arg)) {
          return "[of " + arg.length + "]";
        }
        return '{ ' + Object.keys(arg).join(', ') + ' }';
      })
        .join(', ');
      _this.log("adapter: " + methodName + "(" + (params || '') + ")" + (add || ''));
    };
    var settings = scroller.settings;
    this.debug = settings.debug;
    this.immediateLog = settings.immediateLog;
    this.logTime = settings.logTime;
    this.getTime = function () {
      return scroller.state && " // time: " + scroller.state.time;
    };
    this.getStat = function () {
      var buffer = scroller.buffer, viewport = scroller.viewport;
      var first = buffer.getFirstVisibleItem();
      var last = buffer.getLastVisibleItem();
      return 'pos: ' + viewport.scrollPosition + ', ' +
        'size: ' + viewport.getScrollableSize() + ', ' +
        'bwd_p: ' + viewport.paddings.backward.size + ', ' +
        'fwd_p: ' + viewport.paddings.forward.size + ', ' +
        'default: ' + (buffer.defaultSize || 'no') + ', ' +
        'items: ' + buffer.getVisibleItemsCount() + ', ' +
        'range: ' + (first && last ? "[" + first.$index + ".." + last.$index + "]" : 'no');
    };
    this.getFetchRange = function () {
      var _a = scroller.state.fetch, first = _a.first.index, last = _a.last.index;
      return !Number.isNaN(first) && !Number.isNaN(last)
        ? "[" + first + ".." + last + "]"
        : 'no';
    };
    this.getLoopId = function () { return scroller.state.cycle.loopId; };
    this.getLoopIdNext = function () { return scroller.state.cycle.loopIdNext; };
    this.getWorkflowCycleData = function () {
      return settings.instanceIndex + "-" + scroller.state.cycle.count;
    };
    this.getScrollPosition = function (element) { return scroller.routines.getScrollPosition(element); };
    this.log(function () {
      return 'vscroll Workflow has been started, ' +
        ("core: " + packageInfo.core.name + " v" + packageInfo.core.version + ", ") +
        ("consumer: " + packageInfo.consumer.name + " v" + packageInfo.consumer.version + ", ") +
        ("workflow instance: " + settings.instanceIndex + ", adapter ") +
        (!adapter ? 'is not instantiated' : "instance: " + adapter.id);
    });
  }
  Logger.prototype.object = function (str, obj, stringify) {
    this.log(function () { return [
      str,
      stringify
        ? JSON.stringify(obj, function (k, v) {
          if (Number.isNaN(v)) {
            return 'NaN';
          }
          if (v === Infinity) {
            return 'Infinity';
          }
          if (v === -Infinity) {
            return '-Infinity';
          }
          if (v instanceof Element) {
            return 'HTMLElement';
          }
          if (v instanceof HTMLDocument) {
            return 'HTMLDocument';
          }
          if (typeof v === 'function') {
            return 'Function';
          }
          return v;
        })
          .replace(/"/g, '')
          .replace(/(\{|:|,)/g, '$1 ')
          .replace(/(\})/g, ' $1')
        : obj
    ]; });
  };
  Logger.prototype.stat = function (str) {
    var _this = this;
    if (this.debug) {
      var logStyles_1 = [
        'color: #888; border: dashed #888 0; border-bottom-width: 0px',
        'color: #000; border-width: 0'
      ];
      this.log(function () { return __spreadArray(['%cstat' + (str ? " " + str : '') + ',%c ' + _this.getStat()], __read(logStyles_1)); });
    }
  };
  Logger.prototype.fetch = function (str) {
    var _this = this;
    if (this.debug) {
      var _text_1 = 'fetch interval' + (str ? " " + str : '');
      var logStyles_2 = ['color: #888', 'color: #000'];
      this.log(function () { return __spreadArray(["%c" + _text_1 + ": %c" + _this.getFetchRange()], __read(logStyles_2)); });
    }
  };
  Logger.prototype.prepareForLog = function (data) {
    return data instanceof Event && data.target
      ? this.getScrollPosition(data.target)
      : data;
  };
  Logger.prototype.logProcess = function (data) {
    if (!this.debug) {
      return;
    }
    var process = data.process, status = data.status, payload = data.payload;
    // inner loop start-end log
    var loopLog = [];
    if (process === CommonProcess.init && status === ProcessStatus.next) {
      loopLog.push("%c---=== loop " + this.getLoopIdNext() + " start");
    }
    else if (process === CommonProcess.end) {
      loopLog.push("%c---=== loop " + this.getLoopId() + " done");
      var parent_1 = payload && payload.process;
      if (status === ProcessStatus.next && (parent_1 !== AdapterProcess.reset && parent_1 !== AdapterProcess.reload)) {
        loopLog[0] += ", loop " + this.getLoopIdNext() + " start";
      }
    }
    if (loopLog.length) {
      this.log(function () { return __spreadArray(__spreadArray([], __read(loopLog)), ['color: #006600;']); });
    }
  };
  Logger.prototype.logCycle = function (start) {
    if (start === void 0) { start = true; }
    var logData = this.getWorkflowCycleData();
    var border = start ? '1px 0 0 1px' : '0 0 1px 1px';
    var logStyles = "color: #0000aa; border: solid #555 1px; border-width: " + border + "; margin-left: -2px";
    this.log(function () { return ["%c   ~~~ WF Cycle " + logData + " " + (start ? 'STARTED' : 'FINALIZED') + " ~~~  ", logStyles]; });
  };
  Logger.prototype.logError = function (str) {
    var _this = this;
    if (this.debug) {
      var logStyles_3 = ['color: #a00;', 'color: #000'];
      this.log(function () { return __spreadArray(['error:%c' + (str ? " " + str : '') + ("%c (loop " + _this.getLoopIdNext() + ")")], __read(logStyles_3)); });
    }
  };
  Logger.prototype.log = function () {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.debug) {
      if (typeof args[0] === 'function') {
        args = args[0]();
        if (!Array.isArray(args)) {
          args = [args];
        }
      }
      if (args.every(function (item) { return item === void 0; })) {
        return;
      }
      if (this.logTime) {
        args = __spreadArray(__spreadArray([], __read(args)), [this.getTime()]);
      }
      args = args.map(function (arg) { return _this.prepareForLog(arg); });
      if (this.immediateLog) {
        console.log.apply(this, args);
      }
      else {
        this.logs.push(args);
      }
    }
  };
  // logNow(...args: any[]) {
  //   const immediateLog = this.immediateLog;
  //   const debug = this.debug;
  //   (this as any).debug = true;
  //   (this as any).immediateLog = true;
  //   this.log.apply(this, args);
  //   (this as any).debug = debug;
  //   (this as any).immediateLog = immediateLog;
  // }
  Logger.prototype.logForce = function () {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.debug) {
      if (!this.immediateLog && this.logs.length) {
        this.logs.forEach(function (logArgs) { return console.log.apply(_this, logArgs); });
        this.logs = [];
      }
      if (args.length) {
        console.log.apply(this, args);
      }
    }
  };
  return Logger;
}());

var Routines = /** @class */ (function () {
  function Routines(settings) {
    this.horizontal = settings.horizontal;
    this.window = settings.windowViewport;
  }
  Routines.prototype.checkElement = function (element) {
    if (!element) {
      throw new Error('HTML element is not defined');
    }
  };
  Routines.prototype.getScrollPosition = function (element) {
    if (this.window) {
      return window.pageYOffset;
    }
    this.checkElement(element);
    return element[this.horizontal ? 'scrollLeft' : 'scrollTop'];
  };
  Routines.prototype.setScrollPosition = function (element, value) {
    value = Math.max(0, value);
    if (this.window) {
      if (this.horizontal) {
        window.scrollTo(value, window.scrollY);
      }
      else {
        window.scrollTo(window.scrollX, value);
      }
      return;
    }
    this.checkElement(element);
    element[this.horizontal ? 'scrollLeft' : 'scrollTop'] = value;
  };
  Routines.prototype.getParams = function (element, doNotBind) {
    this.checkElement(element);
    if (this.window && doNotBind) {
      return {
        'height': element.clientHeight,
        'width': element.clientWidth,
        'top': element.clientTop,
        'bottom': element.clientTop + element.clientHeight,
        'left': element.clientLeft,
        'right': element.clientLeft + element.clientWidth
      };
    }
    return element.getBoundingClientRect();
  };
  Routines.prototype.getSize = function (element, doNotBind) {
    return this.getParams(element, doNotBind)[this.horizontal ? 'width' : 'height'];
  };
  Routines.prototype.getSizeStyle = function (element) {
    this.checkElement(element);
    var size = element.style[this.horizontal ? 'width' : 'height'];
    return parseFloat(size) || 0;
  };
  Routines.prototype.setSizeStyle = function (element, value) {
    this.checkElement(element);
    value = Math.max(0, Math.round(value));
    element.style[this.horizontal ? 'width' : 'height'] = value + "px";
  };
  Routines.prototype.getEdge = function (element, direction, doNotBind) {
    var params = this.getParams(element, doNotBind);
    var isFwd = direction === Direction.forward;
    return params[isFwd ? (this.horizontal ? 'right' : 'bottom') : (this.horizontal ? 'left' : 'top')];
  };
  Routines.prototype.getEdge2 = function (element, direction, relativeElement, opposite) {
    // vertical only ?
    return element.offsetTop - (relativeElement ? relativeElement.scrollTop : 0) +
      (direction === (!opposite ? Direction.forward : Direction.backward) ? this.getSize(element) : 0);
  };
  Routines.prototype.hideElement = function (element) {
    this.checkElement(element);
    element.style.display = 'none';
  };
  Routines.prototype.getOffset = function (element) {
    this.checkElement(element);
    return (this.horizontal ? element.offsetLeft : element.offsetTop) || 0;
  };
  Routines.prototype.scrollTo = function (element, argument) {
    this.checkElement(element);
    element.scrollIntoView(argument);
  };
  return Routines;
}());

var Padding = /** @class */ (function () {
  function Padding(element, direction, routines) {
    this.element = element.querySelector("[data-padding-" + direction + "]");
    this.direction = direction;
    this.routines = routines;
  }
  Padding.prototype.reset = function (size) {
    this.size = size || 0;
  };
  Object.defineProperty(Padding.prototype, "size", {
    get: function () {
      return this.routines.getSizeStyle(this.element);
    },
    set: function (value) {
      this.routines.setSizeStyle(this.element, value);
    },
    enumerable: false,
    configurable: true
  });
  return Padding;
}());
var Paddings = /** @class */ (function () {
  function Paddings(element, routines, settings) {
    this.settings = settings;
    this.forward = new Padding(element, Direction.forward, routines);
    this.backward = new Padding(element, Direction.backward, routines);
  }
  Paddings.prototype.byDirection = function (direction, opposite) {
    return direction === Direction.backward
      ? (opposite ? this.forward : this.backward)
      : (opposite ? this.backward : this.forward);
  };
  Paddings.prototype.reset = function (viewportSize, startIndex, offset) {
    var positive = this.getPositiveSize(startIndex, viewportSize, offset);
    var negative = this.getNegativeSize(startIndex);
    if (this.settings.inverse) {
      this.forward.reset(negative);
      this.backward.reset(positive);
      var diff = viewportSize - this.backward.size - offset;
      if (diff > 0) {
        this.backward.size += diff;
        this.forward.size -= diff;
      }
    }
    else {
      this.forward.reset(positive);
      this.backward.reset(negative);
      var diff = viewportSize - this.forward.size - offset;
      if (diff > 0) {
        this.backward.size -= diff;
        this.forward.size += diff;
      }
    }
  };
  Paddings.prototype.getPositiveSize = function (startIndex, viewportSize, offset) {
    var settings = this.settings;
    var positiveSize = viewportSize;
    if (isFinite(settings.maxIndex)) {
      positiveSize = (settings.maxIndex - startIndex + 1) * settings.itemSize;
    }
    if (offset) {
      positiveSize = Math.max(positiveSize - offset, 0);
    }
    return positiveSize;
  };
  Paddings.prototype.getNegativeSize = function (startIndex) {
    var settings = this.settings;
    var negativeSize = 0;
    if (isFinite(settings.minIndex)) {
      negativeSize = (startIndex - settings.minIndex) * settings.itemSize;
    }
    return negativeSize;
  };
  return Paddings;
}());

var Viewport = /** @class */ (function () {
  function Viewport(element, settings, routines, state, logger) {
    this.element = element;
    this.settings = settings;
    this.routines = routines;
    this.state = state;
    this.logger = logger;
    this.disabled = false;
    if (settings.windowViewport) {
      this.hostElement = document.documentElement;
      this.scrollEventReceiver = window;
    }
    else {
      this.hostElement = settings.viewport || this.element.parentElement;
      this.scrollEventReceiver = this.hostElement;
    }
    this.paddings = new Paddings(this.element, this.routines, settings);
    if (settings.windowViewport && 'scrollRestoration' in history) {
      history.scrollRestoration = 'manual';
    }
    if (settings.dismissOverflowAnchor) {
      this.hostElement.style.overflowAnchor = 'none';
    }
  }
  Viewport.prototype.reset = function (startIndex) {
    this.setOffset();
    this.paddings.reset(this.getSize(), startIndex, this.offset);
    this.scrollPosition = this.paddings.backward.size || 0;
    this.state.scrollState.reset();
  };
  Viewport.prototype.setPosition = function (value) {
    var oldPosition = this.scrollPosition;
    if (oldPosition === value) {
      this.logger.log(function () { return ['setting scroll position at', value, '[cancelled]']; });
      return value;
    }
    this.routines.setScrollPosition(this.hostElement, value);
    var position = this.scrollPosition;
    this.logger.log(function () { return __spreadArray([
      'setting scroll position at', position
    ], __read((position !== value ? ["(" + value + ")"] : []))); });
    return position;
  };
  Object.defineProperty(Viewport.prototype, "scrollPosition", {
    get: function () {
      return this.routines.getScrollPosition(this.hostElement);
    },
    set: function (value) {
      this.setPosition(value);
    },
    enumerable: false,
    configurable: true
  });
  Viewport.prototype.disableScrollForOneLoop = function () {
    var _this = this;
    if (this.disabled) {
      return;
    }
    var style = this.hostElement.style;
    if (style.overflowY === 'hidden') {
      return;
    }
    this.disabled = true;
    var overflow = style.overflowY;
    setTimeout(function () {
      _this.disabled = false;
      style.overflowY = overflow;
    });
    style.overflowY = 'hidden';
  };
  Viewport.prototype.getSize = function () {
    return this.routines.getSize(this.hostElement, true);
  };
  Viewport.prototype.getScrollableSize = function () {
    return this.routines.getSize(this.element);
  };
  Viewport.prototype.getBufferPadding = function () {
    return this.getSize() * this.settings.padding;
  };
  Viewport.prototype.getEdge = function (direction) {
    return this.routines.getEdge(this.hostElement, direction, true);
  };
  Viewport.prototype.setOffset = function () {
    this.offset = this.routines.getOffset(this.element);
    if (!this.settings.windowViewport) {
      this.offset -= this.routines.getOffset(this.hostElement);
    }
  };
  Viewport.prototype.getEdgeVisibleItem = function (items, direction) {
    var bwd = direction === Direction.backward;
    var opposite = bwd ? Direction.forward : Direction.backward;
    var viewportEdge = this.getEdge(direction);
    var item, diff = 0;
    for (var i = bwd ? 0 : items.length - 1; bwd ? i <= items.length - 1 : i >= 0; i += bwd ? 1 : -1) {
      var itemEdge = this.routines.getEdge(items[i].element, opposite);
      diff = itemEdge - viewportEdge;
      if (bwd && diff > 0 || !bwd && diff < 0) {
        item = items[i];
        break;
      }
    }
    return { item: item, index: item ? item.$index : NaN, diff: diff };
  };
  return Viewport;
}());

var SizesRecalculation = /** @class */ (function () {
  function SizesRecalculation() {
    this.reset();
  }
  SizesRecalculation.prototype.reset = function () {
    this.newItems = [];
    this.oldItems = [];
    this.removed = [];
  };
  return SizesRecalculation;
}());
var DefaultSize = /** @class */ (function () {
  function DefaultSize(itemSize, sizeStrategy) {
    this.itemSize = itemSize;
    this.sizeStrategy = sizeStrategy;
    this.sizeMap = new Map();
    this.recalculation = new SizesRecalculation();
  }
  DefaultSize.prototype.reset = function (force) {
    if (force) {
      this.constantSize = this.itemSize;
      this.frequentSize = this.itemSize;
      this.averageSize = this.itemSize;
      this.averageSizeFloat = this.itemSize;
      this.sizeMap.clear();
    }
    this.recalculation.reset();
  };
  DefaultSize.prototype.get = function () {
    switch (this.sizeStrategy) {
      case SizeStrategy.Average:
        return this.averageSize;
      case SizeStrategy.Frequent:
        return this.frequentSize;
      default:
        return this.constantSize;
    }
  };
  DefaultSize.prototype.recalculateAverageSize = function (cacheSize) {
    var _a = this.recalculation, oldItems = _a.oldItems, newItems = _a.newItems, removed = _a.removed;
    if (oldItems.length) {
      var oldSize = oldItems.reduce(function (acc, item) { return acc + item.size; }, 0);
      var newSize = oldItems.reduce(function (acc, item) { return acc + item.newSize; }, 0);
      var averageSize = this.averageSizeFloat || 0;
      this.averageSizeFloat = averageSize - (oldSize - newSize) / (cacheSize - newItems.length);
    }
    if (newItems.length) {
      var newSize = newItems.reduce(function (acc, item) { return acc + item.size; }, 0);
      var averageSize = this.averageSizeFloat || 0;
      this.averageSizeFloat = ((cacheSize - newItems.length) * averageSize + newSize) / cacheSize;
    }
    if (removed.length) {
      var removedSize = removed.reduce(function (acc, item) { return acc + item.size; }, 0);
      var averageSize = this.averageSizeFloat || 0;
      this.averageSizeFloat = ((cacheSize + removed.length) * averageSize - removedSize) / cacheSize;
    }
    this.averageSize = Math.round(this.averageSizeFloat);
  };
  DefaultSize.prototype.recalculateFrequentSize = function () {
    var _this = this;
    var _a = this.recalculation, oldItems = _a.oldItems, newItems = _a.newItems, removed = _a.removed;
    var oldFrequentSizeCount = this.sizeMap.get(this.frequentSize);
    if (newItems.length) {
      newItems.forEach(function (_a) {
        var size = _a.size;
        return _this.sizeMap.set(size, (_this.sizeMap.get(size) || 0) + 1);
      });
    }
    if (oldItems.length) {
      oldItems.forEach(function (_a) {
        var size = _a.size;
        return _this.sizeMap.set(size, Math.max((_this.sizeMap.get(size) || 0) - 1, 0));
      });
      oldItems.forEach(function (_a) {
        var s = _a.newSize;
        return _this.sizeMap.set(s, (_this.sizeMap.get(s) || 0) + 1);
      });
    }
    if (removed.length) {
      removed.forEach(function (_a) {
        var size = _a.size;
        return _this.sizeMap.set(size, Math.max((_this.sizeMap.get(size) || 0) - 1, 0));
      });
    }
    var sorted = __spreadArray([], __read(this.sizeMap.entries())).sort(function (a, b) { return b[1] - a[1]; });
    var mostFrequentCount = sorted[0][1];
    var listEqual = sorted.filter(function (i) { return i[1] === mostFrequentCount; });
    if (listEqual.length > 1 && listEqual.find(function (i) { return i[0] === oldFrequentSizeCount; })) {
      // if there are more than 1 most frequent sizes, but the old one is present
      return;
    }
    this.frequentSize = sorted[0][0];
  };
  DefaultSize.prototype.recalculate = function (cacheSize) {
    if (this.sizeStrategy === SizeStrategy.Constant) {
      return false;
    }
    var _a = this.recalculation, oldItems = _a.oldItems, newItems = _a.newItems, removed = _a.removed;
    if (!oldItems.length && !newItems.length && !removed.length) {
      return false;
    }
    var oldValue = this.get();
    if (this.sizeStrategy === SizeStrategy.Average) {
      this.recalculateAverageSize(cacheSize);
    }
    else {
      this.recalculateFrequentSize();
    }
    this.recalculation.reset();
    return this.get() !== oldValue;
  };
  DefaultSize.prototype.setExisted = function (oldItem, newItem) {
    if (this.sizeStrategy !== SizeStrategy.Constant) {
      this.recalculation.oldItems.push({
        size: oldItem.size,
        newSize: newItem.size
      });
    }
  };
  DefaultSize.prototype.setNew = function (newItem) {
    if (this.sizeStrategy !== SizeStrategy.Constant) {
      this.recalculation.newItems.push({
        size: newItem.size
      });
    }
    else {
      if (!this.constantSize) {
        this.constantSize = newItem.size;
      }
    }
  };
  DefaultSize.prototype.setRemoved = function (oldItem) {
    if (this.sizeStrategy !== SizeStrategy.Constant) {
      this.recalculation.removed.push({
        size: oldItem.size
      });
    }
  };
  return DefaultSize;
}());

var ItemCache = /** @class */ (function () {
  function ItemCache(item, saveData) {
    this.$index = item.$index;
    this.nodeId = item.nodeId;
    this.data = saveData ? item.data : null;
    this.size = item.size;
  }
  ItemCache.prototype.changeIndex = function (value) {
    this.$index = value;
    this.nodeId = String(value);
  };
  return ItemCache;
}());
var Cache = /** @class */ (function () {
  function Cache(_a, logger) {
    var itemSize = _a.itemSize, cacheData = _a.cacheData, cacheOnReload = _a.cacheOnReload, sizeStrategy = _a.sizeStrategy;
    this.itemSize = itemSize;
    this.saveData = cacheData;
    this.cacheOnReload = cacheOnReload;
    this.sizeStrategy = sizeStrategy;
    this.logger = logger;
    this.items = new Map();
    this.defaultSize = new DefaultSize(itemSize, sizeStrategy);
    this.reset(true);
  }
  Cache.prototype.reset = function (force) {
    force = force || !this.cacheOnReload;
    if (force) {
      this.minIndex = +Infinity;
      this.maxIndex = -Infinity;
      this.items.clear();
    }
    this.defaultSize.reset(force);
  };
  Object.defineProperty(Cache.prototype, "size", {
    get: function () {
      return this.items.size;
    },
    enumerable: false,
    configurable: true
  });
  Cache.prototype.get = function (index) {
    return this.items.get(index);
  };
  Cache.prototype.getItemSize = function (index) {
    var item = this.get(index);
    return item ? item.size : 0;
  };
  Cache.prototype.getDefaultSize = function () {
    return this.defaultSize.get();
  };
  Cache.prototype.recalculateDefaultSize = function () {
    var _this = this;
    if (this.defaultSize.recalculate(this.size)) {
      this.logger.log(function () { return "default size has been updated: " + _this.defaultSize.get(); });
      return true;
    }
    return false;
  };
  /**
   * Adds item to Set by $index, replaces existed item if $index matches.
   * Maintains min/max indexes and default item size.
   *
   * @param {Item<Data>} item A Buffer item to be cached, an objects with { $index, data, size } props.
   *
   * @returns {ItemCache<Data>} Cached item.
   */
  Cache.prototype.add = function (item) {
    var itemCache = this.get(item.$index);
    if (itemCache) { // adding item is already cached
      if (this.saveData) {
        itemCache.data = item.data;
      }
      if (itemCache.size !== item.size) { // size changes
        if (itemCache.size !== void 0) {
          this.defaultSize.setExisted(itemCache, item);
        }
        else {
          this.defaultSize.setNew(item);
        }
        itemCache.size = item.size;
      }
    }
    else {
      itemCache = new ItemCache(item, this.saveData);
      this.items.set(item.$index, itemCache);
      this.defaultSize.setNew(itemCache);
    }
    if (item.$index < this.minIndex) {
      this.minIndex = item.$index;
    }
    if (item.$index > this.maxIndex) {
      this.maxIndex = item.$index;
    }
    return itemCache;
  };
  /**
   * Removes items from Set, shifts $indexes of items that remain.
   * Replaces current Set with a new one with new regular $indexes.
   * Maintains min/max indexes and default item size.
   *
   * @param {number[]} toRemove List of indexes to be removed.
   * @param {boolean} fixRight Defines indexes shifting strategy.
   * If false, indexes that are greater than the removed ones will be decreased.
   * If true, indexes that are less than than the removed ones will be increased.
   */
  Cache.prototype.removeItems = function (toRemove, fixRight) {
    var _this = this;
    var items = new Map();
    var min = Infinity, max = -Infinity;
    this.items.forEach(function (item) {
      if (toRemove.some(function (index) { return index === item.$index; })) {
        if (item.size !== void 0) {
          _this.defaultSize.setRemoved(item);
        }
        return;
      }
      var diff = fixRight
        ? toRemove.reduce(function (acc, index) { return acc + (item.$index < index ? 1 : 0); }, 0)
        : toRemove.reduce(function (acc, index) { return acc - (item.$index > index ? 1 : 0); }, 0);
      item.changeIndex(item.$index + diff);
      items.set(item.$index, item);
      min = item.$index < min ? item.$index : min;
      max = item.$index > max ? item.$index : max;
    });
    this.items = items;
    this.minIndex = min;
    this.maxIndex = max;
  };
  /**
   * Destructively updates Set based on subset (before-after) changes.
   * Replaces current Set with a new one with new regular $indexes.
   * Maintains min/max indexes. Maintains default item size on remove only.
   * Inserted and replaced items will be taken into account on Cache.add async calls after render.
   *
   * @param {number[]} before Initial subset of indexes to be replaced by "after". Must be incremental.
   * @param {Item<Data>[]} after Transformed subset that replaces "before". Must be be $index-incremental.
   * Must contain at least 1 $index from "before" or be empty.
   * @param {boolean} fixRight This is to fix right indexes during subset collapsing. Acts only if "after" is empty.
   */
  Cache.prototype.updateSubset = function (before, after, fixRight) {
    var _this = this;
    if (!this.size || !before.length) {
      return;
    }
    var minB = before[0], maxB = before[before.length - 1];
    var leftDiff, rightDiff, found;
    if (after.length) {
      var minA = after[0].$index, maxA = after[after.length - 1].$index;
      leftDiff = minA - minB;
      rightDiff = maxA - maxB;
    }
    else {
      leftDiff = fixRight ? maxB - minB + 1 : 0;
      rightDiff = fixRight ? 0 : minB - maxB - 1;
    }
    var items = new Map();
    this.items.forEach(function (item) {
      if (item.$index < minB) { // items to the left of the subset
        item.changeIndex(item.$index + leftDiff);
        items.set(item.$index, item);
        return;
      }
      else if (item.$index > maxB) { // items to the right of the subset
        item.changeIndex(item.$index + rightDiff);
        items.set(item.$index, item);
        return;
      }
    });
    after.forEach(function (item) {
      return items.set(item.$index, new ItemCache(item, _this.saveData));
    });
    before.forEach(function (index) {
      if (!after.some(function (_a) {
        var $index = _a.$index;
        return index === $index;
      }) && (found = _this.get(index))) {
        _this.defaultSize.setRemoved(found);
      }
    });
    this.minIndex += leftDiff;
    this.maxIndex += rightDiff;
    this.items = items;
  };
  return Cache;
}());

var Buffer = /** @class */ (function () {
  function Buffer(settings, onDataChanged, logger) {
    this._items = [];
    this.logger = logger;
    this.changeItems = onDataChanged;
    this.bof = new Reactive(false);
    this.eof = new Reactive(false);
    this.cache = new Cache(settings, logger);
    this.startIndexUser = settings.startIndex;
    this.minIndexUser = settings.minIndex;
    this.maxIndexUser = settings.maxIndex;
    this.reset(true);
  }
  Buffer.prototype.dispose = function () {
    this.bof.dispose();
    this.eof.dispose();
    this._items.forEach(function (item) { return item.dispose(); });
    this._items = [];
  };
  Buffer.prototype.reset = function (force, startIndex) {
    this.items.forEach(function (item) { return item.hide(); });
    this.pristine = true;
    this.items = [];
    this.cache.reset(force);
    this.absMinIndex = this.minIndexUser;
    this.absMaxIndex = this.maxIndexUser;
    this.setCurrentStartIndex(startIndex);
    this.bof.set(false);
    this.eof.set(false);
    this.pristine = false;
  };
  Buffer.prototype.setCurrentStartIndex = function (newStartIndex) {
    var min = this.minIndexUser;
    var max = this.maxIndexUser;
    var start = this.startIndexUser;
    var index = Number(newStartIndex);
    if (Number.isNaN(index)) {
      this.logger.log(function () { return "fallback startIndex to settings.startIndex (" + start + ")"; });
      index = start;
    }
    if (index < min) {
      this.logger.log(function () { return "setting startIndex to settings.minIndex (" + min + ") because " + index + " < " + min; });
      index = min;
    }
    if (index > max) {
      this.logger.log(function () { return "setting startIndex to settings.maxIndex (" + max + ") because " + index + " > " + max; });
      index = max;
    }
    this.startIndex = index;
  };
  Object.defineProperty(Buffer.prototype, "items", {
    get: function () {
      return this._items;
    },
    set: function (items) {
      this._items = items;
      this.changeItems(items);
      if (!this.pristine) {
        this.checkBOF();
        this.checkEOF();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "absMinIndex", {
    get: function () {
      return this._absMinIndex;
    },
    set: function (value) {
      if (this._absMinIndex !== value) {
        this._absMinIndex = Number.isFinite(this._absMaxIndex) && value > this._absMaxIndex ? this._absMaxIndex : value;
      }
      if (!this.pristine) {
        this.checkBOF();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "absMaxIndex", {
    get: function () {
      return this._absMaxIndex;
    },
    set: function (value) {
      if (this._absMaxIndex !== value) {
        this._absMaxIndex = Number.isFinite(this._absMinIndex) && value < this._absMinIndex ? this._absMinIndex : value;
      }
      if (!this.pristine) {
        this.checkEOF();
      }
    },
    enumerable: false,
    configurable: true
  });
  Buffer.prototype.checkBOF = function () {
    // since bof has no setter, need to call checkBOF() on items and absMinIndex change
    var bof = this.items.length
      ? (this.items[0].$index === this.absMinIndex)
      : isFinite(this.absMinIndex);
    this.bof.set(bof);
  };
  Buffer.prototype.checkEOF = function () {
    // since eof has no setter, need to call checkEOF() on items and absMaxIndex change
    var eof = this.items.length
      ? (this.items[this.items.length - 1].$index === this.absMaxIndex)
      : isFinite(this.absMaxIndex);
    this.eof.set(eof);
  };
  Object.defineProperty(Buffer.prototype, "size", {
    get: function () {
      return this._items.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "cacheSize", {
    get: function () {
      return this.cache.size;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "defaultSize", {
    get: function () {
      return this.cache.getDefaultSize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "minIndex", {
    get: function () {
      return isFinite(this.cache.minIndex) ? this.cache.minIndex : this.startIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "maxIndex", {
    get: function () {
      return isFinite(this.cache.maxIndex) ? this.cache.maxIndex : this.startIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "firstIndex", {
    get: function () {
      return this.items.length ? this.items[0].$index : NaN;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "lastIndex", {
    get: function () {
      return this.items.length ? this.items[this.items.length - 1].$index : NaN;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "finiteAbsMinIndex", {
    get: function () {
      return isFinite(this.absMinIndex) ? this.absMinIndex : this.minIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "finiteAbsMaxIndex", {
    get: function () {
      return isFinite(this.absMaxIndex) ? this.absMaxIndex : this.maxIndex;
    },
    enumerable: false,
    configurable: true
  });
  Buffer.prototype.get = function ($index) {
    return this.items.find(function (item) { return item.$index === $index; });
  };
  Buffer.prototype.setItems = function (items) {
    if (!this.items.length) {
      this.items = __spreadArray([], __read(items));
    }
    else if (this.items[0].$index > items[items.length - 1].$index) {
      this.items = __spreadArray(__spreadArray([], __read(items)), __read(this.items));
    }
    else if (items[0].$index > this.items[this.items.length - 1].$index) {
      this.items = __spreadArray(__spreadArray([], __read(this.items)), __read(items));
    }
    else {
      return false;
    }
    return true;
  };
  Buffer.prototype.clip = function () {
    this.items = this.items.filter(function (_a) {
      var toRemove = _a.toRemove;
      return !toRemove;
    });
  };
  Buffer.prototype.append = function (items) {
    this.items = __spreadArray(__spreadArray([], __read(this.items)), __read(items));
  };
  Buffer.prototype.prepend = function (items) {
    this.items = __spreadArray(__spreadArray([], __read(items)), __read(this.items));
  };
  Buffer.prototype.shiftExtremum = function (amount, fixRight) {
    if (!fixRight) {
      this.absMaxIndex += amount;
    }
    else {
      this.absMinIndex -= amount;
      this.startIndex -= amount;
    }
    if (this.startIndex > this.absMaxIndex) {
      this.startIndex = this.absMaxIndex;
    }
    else if (this.startIndex < this.absMinIndex) {
      this.startIndex = this.absMinIndex;
    }
  };
  Buffer.prototype.removeItems = function (indexes, fixRight, virtual) {
    if (virtual === void 0) { virtual = false; }
    var result = [];
    var toRemove = virtual ? indexes : [];
    var length = this.items.length;
    var shifted = false;
    var _loop_1 = function (i) {
      var item = this_1.items[i];
      if (!virtual && indexes.indexOf(item.$index) >= 0) {
        toRemove.push(item.$index);
        return "continue";
      }
      var diff = toRemove.reduce(function (acc, index) { return acc + (fixRight
        ? (item.$index < index ? 1 : 0)
        : (item.$index > index ? -1 : 0)); }, 0);
      shifted = shifted || !!diff;
      item.updateIndex(item.$index + diff);
      if (!virtual) {
        if (fixRight) {
          result.unshift(item);
        }
        else {
          result.push(item);
        }
      }
    };
    var this_1 = this;
    for (var i = fixRight ? length - 1 : 0; fixRight ? i >= 0 : i < length; fixRight ? i-- : i++) {
      _loop_1(i);
    }
    this.shiftExtremum(-toRemove.length, fixRight);
    if (!virtual) {
      this.items = result;
    }
    else if (shifted) {
      this.items = __spreadArray([], __read(this.items));
    }
    this.cache.removeItems(toRemove, fixRight);
  };
  Buffer.prototype.updateItems = function (predicate, generator, indexToTrack, fixRight) {
    var _this = this;
    if (!this.size || Number.isNaN(this.firstIndex)) {
      return NaN;
    }
    var _indexToTrack = indexToTrack;
    var index = fixRight ? this.lastIndex : this.firstIndex;
    var items = [];
    var diff = fixRight ? -1 : 1;
    var initialIndexList = this.items.map(function (_a) {
      var $index = _a.$index;
      return $index;
    });
    (fixRight ? this.items.reverse() : this.items).forEach(function (item) {
      var result = predicate(item);
      // if predicate result is falsy or empty array -> delete
      if (!result || (Array.isArray(result) && !result.length)) {
        item.toRemove = true;
        _indexToTrack += item.$index >= indexToTrack ? (fixRight ? 1 : 0) : (fixRight ? 0 : -1);
        _this.shiftExtremum(-1, fixRight);
        return;
      }
      // if predicate result is truthy but not array -> leave
      if (!Array.isArray(result)) {
        item.updateIndex(index);
        items.push(item);
        index += diff;
        return;
      }
      // if predicate result is non-empty array -> insert/replace
      if (item.$index < indexToTrack) {
        _indexToTrack += fixRight ? 0 : result.length - 1;
      }
      else if (item.$index > indexToTrack) {
        _indexToTrack += fixRight ? 1 - result.length : 0;
      }
      var toRemove = true;
      var newItems = [];
      (fixRight ? __spreadArray([], __read(result)).reverse() : result).forEach(function (data, i) {
        var newItem;
        if (item.data === data) {
          if (indexToTrack === item.$index) {
            _indexToTrack = index + i * diff;
          }
          item.updateIndex(index + i * diff);
          newItem = item;
          toRemove = false; // insert case
        }
        else {
          newItem = generator(index + i * diff, data);
          newItem.toInsert = true;
        }
        newItems.push(newItem);
      });
      item.toRemove = toRemove;
      items.push.apply(items, __spreadArray([], __read(newItems)));
      index += diff * result.length;
      if (result.length > 1) {
        _this.shiftExtremum(result.length - 1, fixRight);
      }
    });
    this.items = fixRight ? items.reverse() : items;
    this.cache.updateSubset(initialIndexList, this.items, fixRight);
    if (this.finiteAbsMinIndex === this.finiteAbsMaxIndex) {
      _indexToTrack = NaN;
    }
    else if (_indexToTrack > this.finiteAbsMaxIndex) {
      _indexToTrack = this.finiteAbsMaxIndex;
    }
    else if (_indexToTrack < this.finiteAbsMinIndex) {
      _indexToTrack = this.finiteAbsMinIndex;
    }
    return _indexToTrack;
  };
  Buffer.prototype.cacheItem = function (item) {
    this.cache.add(item);
  };
  Buffer.prototype.getFirstVisibleItemIndex = function () {
    var length = this.items.length;
    for (var i = 0; i < length; i++) {
      if (!this.items[i].invisible) {
        return i;
      }
    }
    return -1;
  };
  Buffer.prototype.getLastVisibleItemIndex = function () {
    for (var i = this.items.length - 1; i >= 0; i--) {
      if (!this.items[i].invisible) {
        return i;
      }
    }
    return -1;
  };
  Buffer.prototype.getFirstVisibleItem = function () {
    var index = this.getFirstVisibleItemIndex();
    if (index >= 0) {
      return this.items[index];
    }
  };
  Buffer.prototype.getLastVisibleItem = function () {
    var index = this.getLastVisibleItemIndex();
    if (index >= 0) {
      return this.items[index];
    }
  };
  Buffer.prototype.getEdgeVisibleItem = function (direction, opposite) {
    return direction === (!opposite ? Direction.forward : Direction.backward) ?
      this.getLastVisibleItem() : this.getFirstVisibleItem();
  };
  Buffer.prototype.getVisibleItemsCount = function () {
    return this.items.reduce(function (acc, item) { return acc + (item.invisible ? 0 : 1); }, 0);
  };
  Buffer.prototype.getSizeByIndex = function (index) {
    var item = this.cache.get(index);
    return item ? item.size : this.defaultSize;
  };
  Buffer.prototype.checkDefaultSize = function () {
    return this.cache.recalculateDefaultSize();
  };
  Buffer.prototype.getIndexToAppend = function (eof) {
    return (!eof
      ? (this.size ? this.items[this.size - 1].$index : this.maxIndex)
      : this.absMaxIndex) + (this.size ? 1 : 0);
  };
  Buffer.prototype.getIndexToPrepend = function (bof) {
    return (!bof
      ? (this.size ? this.items[0].$index : this.minIndex)
      : this.absMinIndex) - (this.size ? 1 : 0);
  };
  Buffer.prototype.getIndexToAdd = function (eof, prepend) {
    return prepend ? this.getIndexToPrepend(eof) : this.getIndexToAppend(eof);
  };
  return Buffer;
}());

var InnerLoopModel = /** @class */ (function () {
  function InnerLoopModel(total) {
    this.total = total;
    this.isInitial = false;
    this.busy = new Reactive(false);
  }
  Object.defineProperty(InnerLoopModel.prototype, "first", {
    get: function () {
      return this.count === 0;
    },
    enumerable: false,
    configurable: true
  });
  InnerLoopModel.prototype.done = function () {
    this.count++;
    this.total++;
    this.busy.set(false);
  };
  InnerLoopModel.prototype.start = function () {
    this.busy.set(true);
  };
  InnerLoopModel.prototype.dispose = function () {
    this.busy.dispose();
  };
  return InnerLoopModel;
}());
var WorkflowCycleModel = /** @class */ (function () {
  function WorkflowCycleModel(instanceIndex, cycle) {
    var cycleCount = cycle ? cycle.count : 1;
    var loopCount = cycle ? cycle.innerLoop.count : 0;
    this.instanceIndex = instanceIndex;
    this.innerLoop = new InnerLoopModel(loopCount);
    this.interrupter = null;
    this.busy = new Reactive(false);
    this.done(cycleCount);
  }
  Object.defineProperty(WorkflowCycleModel.prototype, "loopId", {
    get: function () {
      return this.instanceIndex + "-" + this.count + "-" + this.innerLoop.total;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WorkflowCycleModel.prototype, "loopIdNext", {
    get: function () {
      return this.instanceIndex + "-" + this.count + "-" + (this.innerLoop.total + 1);
    },
    enumerable: false,
    configurable: true
  });
  WorkflowCycleModel.prototype.done = function (count) {
    this.count = count;
    this.isInitial = false;
    this.busy.set(false);
  };
  WorkflowCycleModel.prototype.start = function (isInitial, initiator) {
    this.isInitial = isInitial;
    this.initiator = initiator;
    this.innerLoop.isInitial = isInitial;
    this.innerLoop.count = 0;
    this.interrupter = null;
    this.busy.set(true);
  };
  WorkflowCycleModel.prototype.dispose = function (forever) {
    if (forever) {
      // otherwise the value will be persisted during re-instantiation
      this.busy.dispose();
    }
    this.innerLoop.dispose();
  };
  return WorkflowCycleModel;
}());

var Positions = /** @class */ (function () {
  function Positions() {
    this.reset();
  }
  Positions.prototype.reset = function () {
    this.startDelta = 0;
    this.before = 0;
  };
  return Positions;
}());
var First = /** @class */ (function () {
  function First() {
    this.reset();
  }
  First.prototype.reset = function () {
    this.index = NaN;
    this.indexBuffer = NaN;
    this.position = NaN;
  };
  return First;
}());
var Last = /** @class */ (function () {
  function Last() {
    this.reset();
  }
  Last.prototype.reset = function () {
    this.index = NaN;
    this.indexBuffer = NaN;
  };
  return Last;
}());
var FetchModel = /** @class */ (function () {
  function FetchModel() {
    this.callCount = 0;
    this.positions = new Positions();
    this.first = new First();
    this.last = new Last();
    this.reset();
  }
  FetchModel.prototype.reset = function () {
    this._newItemsData = null;
    this.items = [];
    this.positions.reset();
    this.first.reset();
    this.last.reset();
    this.hasAnotherPack = false;
    this.firstVisibleIndex = NaN;
    this.firstVisibleItemDelta = NaN;
    this.negativeSize = 0;
    this.direction = null;
    this.cancel = null;
    this.simulate = false;
    this.isPrepend = false;
    this.isCheck = false;
    this.doRemove = false;
  };
  Object.defineProperty(FetchModel.prototype, "newItemsData", {
    get: function () {
      return this._newItemsData;
    },
    set: function (items) {
      this._newItemsData = items;
      if (items && items.length) {
        this.callCount++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FetchModel.prototype, "shouldFetch", {
    get: function () {
      return !!this.count;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FetchModel.prototype, "hasNewItems", {
    get: function () {
      return !!((this._newItemsData && this._newItemsData.length));
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FetchModel.prototype, "index", {
    get: function () {
      return this.first.index;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FetchModel.prototype, "count", {
    get: function () {
      return !isNaN(this.first.index) && !isNaN(this.last.index) ? this.last.index - this.first.index + 1 : 0;
    },
    enumerable: false,
    configurable: true
  });
  FetchModel.prototype.startSimulate = function (items) {
    this.simulate = true;
    this._newItemsData = items.map(function (item) { return item.data; });
    this.items = items;
    this.hasAnotherPack = false;
    this.negativeSize = 0;
  };
  FetchModel.prototype.stopSimulate = function () {
    this.simulate = false;
    this.isPrepend = false;
    this.isCheck = false;
    this.doRemove = false;
  };
  FetchModel.prototype.append = function (items) {
    this.startSimulate(items);
    this.last.index = items[items.length - 1].$index;
    this.first.index = items[0].$index;
    this.direction = Direction.forward;
  };
  FetchModel.prototype.prepend = function (items) {
    this.startSimulate(items);
    this.last.index = items[0].$index;
    this.first.index = items[items.length - 1].$index;
    this.direction = Direction.backward;
    this.isPrepend = true;
  };
  FetchModel.prototype.check = function (items) {
    this.startSimulate(items);
    this.last.index = items[0].$index;
    this.first.index = items[items.length - 1].$index;
    this.isCheck = true;
  };
  FetchModel.prototype.remove = function () {
    this.startSimulate([]);
    this.doRemove = true;
    // firstVisibleIndex & delta should be set inside process
  };
  FetchModel.prototype.update = function (index, delta, items, itemsToRemove) {
    this.startSimulate(items);
    this.firstVisibleIndex = index;
    this.firstVisibleItemDelta = delta;
    this.doRemove = itemsToRemove.length > 0;
  };
  return FetchModel;
}());

var ClipModel = /** @class */ (function () {
  function ClipModel() {
    this.callCount = 0;
    this.reset();
  }
  Object.defineProperty(ClipModel.prototype, "force", {
    get: function () {
      return this.forceForward || this.forceBackward;
    },
    enumerable: false,
    configurable: true
  });
  ClipModel.prototype.reset = function (force) {
    this.doClip = false;
    if (!force) {
      this.forceForward = false;
      this.forceBackward = false;
    }
  };
  return ClipModel;
}());

var RenderModel = /** @class */ (function () {
  function RenderModel() {
    this.reset();
  }
  Object.defineProperty(RenderModel.prototype, "noSize", {
    get: function () {
      return this.sizeBefore === this.sizeAfter;
    },
    enumerable: false,
    configurable: true
  });
  RenderModel.prototype.reset = function () {
    this.sizeBefore = 0;
    this.sizeAfter = 0;
    this.positionBefore = 0;
    this.renderTimer = null;
  };
  return RenderModel;
}());

var ScrollState = /** @class */ (function () {
  function ScrollState() {
    this.reset();
  }
  ScrollState.prototype.reset = function () {
    this.previous = null;
    this.current = null;
    this.syntheticPosition = null;
    this.syntheticFulfill = false;
    this.positionBeforeAsync = null;
    this.positionBeforeAdjust = null;
    this.positionAfterAdjust = null;
    this.cleanupTimers();
  };
  ScrollState.prototype.cleanupTimers = function () {
    if (this.scrollTimer) {
      clearTimeout(this.scrollTimer);
      this.scrollTimer = null;
    }
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = 0;
    }
  };
  ScrollState.prototype.hasPositionChanged = function (position) {
    var before = this.positionBeforeAdjust;
    var after = this.positionAfterAdjust;
    return before === null || before !== position || after === null || after !== position;
  };
  return ScrollState;
}());

var State = /** @class */ (function () {
  function State(packageInfo, settings, state) {
    this.packageInfo = packageInfo;
    this.settings = settings;
    this.initTime = Number(new Date());
    this.cycle = new WorkflowCycleModel(this.settings.instanceIndex, state ? state.cycle : void 0);
    this.fetch = new FetchModel();
    this.clip = new ClipModel();
    this.render = new RenderModel();
    this.scrollState = new ScrollState();
  }
  Object.defineProperty(State.prototype, "time", {
    get: function () {
      return Number(new Date()) - this.initTime;
    },
    enumerable: false,
    configurable: true
  });
  State.prototype.endInnerLoop = function () {
    var _a = this, fetch = _a.fetch, render = _a.render, cycle = _a.cycle;
    if (fetch.cancel) {
      fetch.cancel();
      fetch.cancel = null;
    }
    if (render.renderTimer) {
      clearTimeout(render.renderTimer);
      render.renderTimer = null;
    }
    cycle.innerLoop.done();
  };
  State.prototype.startInnerLoop = function () {
    var _a = this, cycle = _a.cycle, scroll = _a.scrollState, fetch = _a.fetch, render = _a.render, clip = _a.clip;
    cycle.innerLoop.start();
    scroll.positionBeforeAsync = null;
    if (!fetch.simulate) {
      fetch.reset();
    }
    clip.reset(clip.force);
    render.reset();
    return __assign({}, (cycle.innerLoop.first ? {
      process: cycle.initiator,
      doRender: fetch.simulate && fetch.items.length > 0
    } : {}));
  };
  State.prototype.dispose = function () {
    this.cycle.dispose();
    this.endInnerLoop();
    this.scrollState.cleanupTimers();
  };
  return State;
}());

var ADAPTER_PROPS_STUB = getDefaultAdapterProps();
var _has = function (obj, prop) {
  return typeof obj === 'object' && obj !== null && Object.prototype.hasOwnProperty.call(obj, prop);
};
var convertAppendArgs = function (prepend, options, eof) {
  var result = options;
  if (!_has(options, 'items')) {
    var items = !Array.isArray(options) ? [options] : options;
    result = prepend ? { items: items, bof: eof } : { items: items, eof: eof };
  }
  return result;
};
var convertRemoveArgs = function (options) {
  if (!(_has(options, 'predicate') || _has(options, 'indexes'))) {
    var predicate = options;
    options = { predicate: predicate };
  }
  return options;
};
var Adapter = /** @class */ (function () {
  function Adapter(context, getWorkflow, logger) {
    var _this = this;
    this.source = {}; // for Reactive props
    this.box = {}; // for Scalars over Reactive props
    this.demand = {}; // for Scalars on demand
    this.wanted = {};
    this.getWorkflow = getWorkflow;
    this.logger = logger;
    this.relax$ = null;
    this.relaxRun = null;
    this.reloadCounter = 0;
    // public context (if exists) should provide access Reactive props configuration by id
    var reactivePropsStore = context && reactiveConfigStorage.get(context.id) || {};
    // make array of the original values from public context if present
    var adapterProps = context
      ? ADAPTER_PROPS_STUB.map(function (prop) {
        var value = context[prop.name];
        // if context is augmented, we need to replace external reactive props with inner ones
        if (context.augmented) {
          var reactiveProp = reactivePropsStore[prop.name];
          if (reactiveProp) {
            value = reactiveProp.default; // boolean doesn't matter here
          }
        }
        return (__assign(__assign({}, prop), { value: value }));
      })
      : getDefaultAdapterProps();
    // restore default reactive props if they were configured
    Object.entries(reactivePropsStore).forEach(function (_a) {
      var _b = __read(_a, 2), key = _b[0], value = _b[1];
      var prop = adapterProps.find(function (_a) {
        var name = _a.name;
        return name === key;
      });
      if (prop && value) {
        prop.value = value.default;
      }
    });
    // Scalar permanent props
    adapterProps
      .filter(function (_a) {
      var type = _a.type, permanent = _a.permanent;
      return type === AdapterPropType.Scalar && permanent;
    })
      .forEach(function (_a) {
      var name = _a.name, value = _a.value;
      return Object.defineProperty(_this, name, {
        configurable: true,
        get: function () { return value; }
      });
    });
    // Reactive props
    // 1) store original values in "source" container, to avoid extra .get() calls on scalar twins set
    // 2) "wanted" container is bound with scalars; get() updates it
    adapterProps
      .filter(function (prop) { return prop.type === AdapterPropType.Reactive; })
      .forEach(function (_a) {
      var name = _a.name, value = _a.value;
      _this.source[name] = value;
      Object.defineProperty(_this, name, {
        configurable: true,
        get: function () {
          var scalarWanted = ADAPTER_PROPS_STUB.find(function (_a) {
            var wanted = _a.wanted, reactive = _a.reactive;
            return wanted && reactive === name;
          });
          if (scalarWanted) {
            _this.wanted[scalarWanted.name] = true;
          }
          return _this.source[name];
        }
      });
    });
    // Scalar props that have Reactive twins
    // 1) scalars should use "box" container
    // 2) "wanted" should be updated on get
    // 3) reactive props (from "source") are triggered on set
    adapterProps
      .filter(function (prop) { return prop.type === AdapterPropType.Scalar && !!prop.reactive; })
      .forEach(function (_a) {
      var name = _a.name, value = _a.value, reactive = _a.reactive, wanted = _a.wanted;
      if (wanted) {
        _this.wanted[name] = false;
      }
      _this.box[name] = value;
      Object.defineProperty(_this, name, {
        configurable: true,
        set: function (newValue) {
          if (newValue !== _this.box[name]) {
            _this.box[name] = newValue;
            _this.source[reactive].set(newValue);
            // need to emit new value through the configured reactive prop if present
            var reactiveProp = reactivePropsStore[reactive];
            if (reactiveProp) {
              reactiveProp.emit(reactiveProp.source, newValue);
            }
          }
        },
        get: function () {
          if (wanted) {
            _this.wanted[name] = true;
          }
          return _this.box[name];
        }
      });
    });
    // Scalar props on-demand
    // these scalars should use "demand" container
    // setting defaults should be overridden on init()
    adapterProps
      .filter(function (prop) { return prop.type === AdapterPropType.Scalar && prop.onDemand; })
      .forEach(function (_a) {
      var name = _a.name, value = _a.value;
      _this.demand[name] = value;
      Object.defineProperty(_this, name, {
        configurable: true,
        get: function () { return _this.demand[name]; }
      });
    });
    if (!context) {
      return;
    }
    // Adapter public context augmentation
    adapterProps
      .forEach(function (_a) {
      var name = _a.name, type = _a.type, defaultValue = _a.value, permanent = _a.permanent;
      var value = _this[name];
      if (type === AdapterPropType.Function) {
        value = value.bind(_this);
      }
      else if (type === AdapterPropType.WorkflowRunner) {
        value = _this.getPromisifiedMethod(value, defaultValue);
      }
      else if (type === AdapterPropType.Reactive && reactivePropsStore[name]) {
        value = context[name];
      }
      else if (name === AdapterPropName.augmented) {
        value = true;
      }
      Object.defineProperty(context, name, {
        configurable: true,
        get: function () { return !permanent && type === AdapterPropType.Scalar
          ? _this[name] // non-permanent Scalars should be taken in runtime
          : value; } // Reactive props and methods (Functions/WorkflowRunners) can be defined once
      });
    });
    this.externalContext = context;
  }
  Object.defineProperty(Adapter.prototype, "workflow", {
    get: function () {
      return this.getWorkflow();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Adapter.prototype, "reloadCount", {
    get: function () {
      return this.reloadCounter;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Adapter.prototype, "reloadId", {
    get: function () {
      return this.id + '.' + this.reloadCounter;
    },
    enumerable: false,
    configurable: true
  });
  Adapter.prototype.getPromisifiedMethod = function (method, defaultMethod) {
    var _this = this;
    return function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return _this.relax$
        ? new Promise(function (resolve) {
          if (_this.relax$) {
            _this.relax$.once(function (value) { return resolve(value); });
          }
          method.apply(_this, args);
        })
        : defaultMethod.apply(_this, args);
    };
  };
  Adapter.prototype.initialize = function (buffer, state, logger, adapterRun$) {
    var _this = this;
    // buffer
    Object.defineProperty(this.demand, AdapterPropName.itemsCount, {
      get: function () { return buffer.getVisibleItemsCount(); }
    });
    Object.defineProperty(this.demand, AdapterPropName.bufferInfo, {
      get: function () { return ({
        firstIndex: buffer.firstIndex,
        lastIndex: buffer.lastIndex,
        minIndex: buffer.minIndex,
        maxIndex: buffer.maxIndex,
        absMinIndex: buffer.absMinIndex,
        absMaxIndex: buffer.absMaxIndex,
        defaultSize: buffer.defaultSize,
      }); }
    });
    this.bof = buffer.bof.get();
    buffer.bof.on(function (bof) { return _this.bof = bof; });
    this.eof = buffer.eof.get();
    buffer.eof.on(function (eof) { return _this.eof = eof; });
    // state
    Object.defineProperty(this.demand, AdapterPropName.packageInfo, {
      get: function () { return state.packageInfo; }
    });
    this.loopPending = state.cycle.innerLoop.busy.get();
    state.cycle.innerLoop.busy.on(function (busy) { return _this.loopPending = busy; });
    this.isLoading = state.cycle.busy.get();
    state.cycle.busy.on(function (busy) { return _this.isLoading = busy; });
    // logger
    this.logger = logger;
    // self-pending subscription; set up only on the very first init
    if (adapterRun$) {
      if (!this.relax$) {
        this.relax$ = new Reactive();
      }
      var relax$_1 = this.relax$;
      adapterRun$.on(function (_a) {
        var status = _a.status, payload = _a.payload;
        var unSubRelax = function () { };
        if (status === ProcessStatus.start) {
          unSubRelax = _this.isLoading$.on(function (value) {
            if (!value) {
              unSubRelax();
              relax$_1.set({ success: true, immediate: false, details: null });
            }
          });
        }
        else if (status === ProcessStatus.done || status === ProcessStatus.error) {
          unSubRelax();
          relax$_1.set({
            success: status !== ProcessStatus.error,
            immediate: true,
            details: status === ProcessStatus.error && payload ? String(payload.error) : null
          });
        }
      });
    }
    // init
    this.init = true;
  };
  Adapter.prototype.dispose = function () {
    var _this = this;
    if (this.relax$) {
      this.relax$.dispose();
    }
    if (this.externalContext) {
      this.resetContext();
    }
    Object.getOwnPropertyNames(this).forEach(function (prop) {
      delete _this[prop];
    });
  };
  Adapter.prototype.resetContext = function () {
    var _this = this;
    var reactiveStore = reactiveConfigStorage.get(this.externalContext.id);
    ADAPTER_PROPS_STUB
      .forEach(function (_a) {
      var type = _a.type, permanent = _a.permanent, name = _a.name, value = _a.value;
      // assign initial values to non-reactive non-permanent props
      if (type !== AdapterPropType.Reactive && !permanent) {
        Object.defineProperty(_this.externalContext, name, {
          configurable: true,
          get: function () { return value; }
        });
      }
      // reset reactive props
      if (type === AdapterPropType.Reactive && reactiveStore) {
        var property = reactiveStore[name];
        if (property) {
          property.default.reset();
          property.emit(property.source, property.default.get());
        }
      }
    });
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Adapter.prototype.reset = function (options) {
    this.reloadCounter++;
    this.logger.logAdapterMethod('reset', options, " of " + this.reloadId);
    this.workflow.call({
      process: AdapterProcess.reset,
      status: ProcessStatus.start,
      payload: { options: options }
    });
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Adapter.prototype.reload = function (options) {
    this.reloadCounter++;
    this.logger.logAdapterMethod('reload', options, " of " + this.reloadId);
    this.workflow.call({
      process: AdapterProcess.reload,
      status: ProcessStatus.start,
      payload: { options: options }
    });
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Adapter.prototype.append = function (_options, eof) {
    var options = convertAppendArgs(false, _options, eof); // support old signature
    this.logger.logAdapterMethod('append', [options.items, options.eof]);
    this.workflow.call({
      process: AdapterProcess.append,
      status: ProcessStatus.start,
      payload: { options: options }
    });
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Adapter.prototype.prepend = function (_options, bof) {
    var options = convertAppendArgs(true, _options, bof); // support old signature
    this.logger.logAdapterMethod('prepend', [options.items, options.bof]);
    this.workflow.call({
      process: AdapterProcess.prepend,
      status: ProcessStatus.start,
      payload: { options: options }
    });
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Adapter.prototype.check = function () {
    this.logger.logAdapterMethod('check');
    this.workflow.call({
      process: AdapterProcess.check,
      status: ProcessStatus.start
    });
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Adapter.prototype.remove = function (options) {
    options = convertRemoveArgs(options); // support old signature
    this.logger.logAdapterMethod('remove', options);
    this.workflow.call({
      process: AdapterProcess.remove,
      status: ProcessStatus.start,
      payload: { options: options }
    });
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Adapter.prototype.clip = function (options) {
    this.logger.logAdapterMethod('clip', options);
    this.workflow.call({
      process: AdapterProcess.clip,
      status: ProcessStatus.start,
      payload: { options: options }
    });
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Adapter.prototype.insert = function (options) {
    this.logger.logAdapterMethod('insert', options);
    this.workflow.call({
      process: AdapterProcess.insert,
      status: ProcessStatus.start,
      payload: { options: options }
    });
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Adapter.prototype.replace = function (options) {
    this.logger.logAdapterMethod('replace', options);
    this.workflow.call({
      process: AdapterProcess.replace,
      status: ProcessStatus.start,
      payload: { options: options }
    });
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Adapter.prototype.update = function (options) {
    this.logger.logAdapterMethod('update', options);
    this.workflow.call({
      process: AdapterProcess.update,
      status: ProcessStatus.start,
      payload: { options: options }
    });
  };
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Adapter.prototype.fix = function (options) {
    this.logger.logAdapterMethod('fix', options);
    this.workflow.call({
      process: AdapterProcess.fix,
      status: ProcessStatus.start,
      payload: { options: options }
    });
  };
  Adapter.prototype.relaxUnchained = function (callback, reloadId) {
    var _this = this;
    var runCallback = function () { return typeof callback === 'function' && reloadId === _this.reloadId && callback(); };
    if (!this.isLoading) {
      runCallback();
    }
    return new Promise(function (resolve) {
      if (!_this.isLoading) {
        resolve(true);
        return;
      }
      _this.isLoading$.once(function () {
        runCallback();
        resolve(false);
      });
    }).then(function (immediate) {
      var success = reloadId === _this.reloadId;
      _this.logger.log(function () { return !success ? "relax promise cancelled due to " + reloadId + " != " + _this.reloadId : void 0; });
      return {
        immediate: immediate,
        success: success,
        details: !success ? 'Interrupted by reload or reset' : null
      };
    });
  };
  Adapter.prototype.relax = function (callback) {
    var _this = this;
    var reloadId = this.reloadId;
    this.logger.logAdapterMethod('relax', callback, " of " + reloadId);
    if (!this.init) {
      return Promise.resolve(methodPreResult);
    }
    return this.relaxRun = this.relaxRun
      ? this.relaxRun.then(function () { return _this.relaxUnchained(callback, reloadId); })
      : this.relaxUnchained(callback, reloadId).then(function (result) {
        _this.relaxRun = null;
        return result;
      });
  };
  Adapter.prototype.showLog = function () {
    this.logger.logAdapterMethod('showLog');
    this.logger.logForce();
  };
  return Adapter;
}());

var INVALID_DATASOURCE_PREFIX = 'Invalid datasource:';
var instanceCount = 0;
var Scroller = /** @class */ (function () {
  function Scroller(_a) {
    var datasource = _a.datasource, consumer = _a.consumer, element = _a.element, workflow = _a.workflow, scroller = _a.scroller;
    var get = validate(datasource, DATASOURCE).params.get;
    if (!get.isValid) {
      throw new Error(INVALID_DATASOURCE_PREFIX + " " + get.errors[0]);
    }
    var packageInfo = scroller ? scroller.state.packageInfo : { consumer: consumer, core: core };
    element = scroller ? scroller.viewport.element : element;
    workflow = scroller ? scroller.workflow : workflow;
    this.workflow = workflow;
    this.settings = new Settings(datasource.settings, datasource.devSettings, ++instanceCount);
    this.logger = new Logger(this, packageInfo, datasource.adapter);
    this.routines = new Routines(this.settings);
    this.state = new State(packageInfo, this.settings, scroller ? scroller.state : void 0);
    this.buffer = new Buffer(this.settings, workflow.onDataChanged, this.logger);
    this.viewport = new Viewport(element, this.settings, this.routines, this.state, this.logger);
    this.logger.object('vscroll settings object', this.settings, true);
    this.initDatasource(datasource, scroller);
  }
  Scroller.prototype.initDatasource = function (datasource, scroller) {
    var _this = this;
    if (scroller) { // scroller re-instantiating case
      this.datasource = datasource;
      this.adapter = scroller.adapter;
      // todo: what about (this.settings.adapter !== scroller.setting.adapter) case?
      return;
    }
    // scroller is being instantiated for the first time
    var constructed = datasource instanceof DatasourceGeneric;
    var mockAdapter = !constructed && !this.settings.adapter;
    if (constructed) { // datasource is already instantiated
      this.datasource = datasource;
    }
    else { // datasource as POJO
      var DS = makeDatasource(function () { return ({ mock: mockAdapter }); });
      this.datasource = new DS(datasource);
      if (this.settings.adapter) {
        datasource.adapter = this.datasource.adapter;
      }
    }
    var publicContext = !mockAdapter ? this.datasource.adapter : null;
    this.adapter = new Adapter(publicContext, function () { return _this.workflow; }, this.logger);
  };
  Scroller.prototype.init = function (adapterRun$) {
    this.viewport.reset(this.buffer.startIndex);
    this.logger.stat('initialization');
    this.adapter.initialize(this.buffer, this.state, this.logger, adapterRun$);
  };
  Scroller.prototype.dispose = function (forever) {
    if (forever) { // Adapter is not re-instantiated on reset
      this.adapter.dispose();
    }
    this.buffer.dispose();
    this.state.dispose();
  };
  Scroller.prototype.finalize = function () {
  };
  return Scroller;
}());

var runStateMachine = function (_a) {
  var _b = _a.input, process = _b.process, status = _b.status, _c = _b.payload, payload = _c === void 0 ? {} : _c, _d = _a.methods, run = _d.run, interrupt = _d.interrupt, done = _d.done, onError = _d.onError;
  if (status === ProcessStatus.error) {
    onError(process, payload);
    if (!process.startsWith('adapter')) {
      run(End)(payload);
    }
    return;
  }
  var options = payload.options;
  switch (process) {
    case CommonProcess.init:
      if (status === ProcessStatus.start) { // App start
        run(Init)(process);
      }
      if (status === ProcessStatus.next) {
        run(Start)();
      }
      break;
    case CommonProcess.scroll:
      if (status === ProcessStatus.start) {
        run(Scroll)(payload);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.reset:
    case AdapterProcess.reload:
      if (status === ProcessStatus.start) {
        if (process === AdapterProcess.reset) {
          run(Reset)(options);
        }
        else {
          run(Reload)(options);
        }
      }
      if (status === ProcessStatus.next) {
        interrupt(__assign({ process: process }, payload));
        if (payload.finalize) {
          run(End)();
        }
        else {
          run(Init)(process);
        }
      }
      break;
    case AdapterProcess.append:
    case AdapterProcess.prepend:
      if (status === ProcessStatus.start) {
        run(Append)({ process: process, options: options });
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.check:
      if (status === ProcessStatus.start) {
        run(Check)();
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.remove:
      if (status === ProcessStatus.start) {
        run(Remove)(options);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.clip:
      if (status === ProcessStatus.start) {
        run(UserClip)(options);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.insert:
      if (status === ProcessStatus.start) {
        run(Insert)(options);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.replace:
      if (status === ProcessStatus.start) {
        run(Replace)(options);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.update:
      if (status === ProcessStatus.start) {
        run(Update)(options);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case AdapterProcess.fix:
      if (status === ProcessStatus.start) {
        run(Fix)(options);
      }
      if (status === ProcessStatus.next) {
        run(Init)(process);
      }
      break;
    case CommonProcess.start:
      switch (payload.process) {
        case AdapterProcess.append:
        case AdapterProcess.check:
        case AdapterProcess.insert:
          run(Render)();
          break;
        case AdapterProcess.remove:
          run(Adjust)();
          break;
        case AdapterProcess.replace:
        case AdapterProcess.update:
          if (payload.doRender) {
            run(Render)();
          }
          else {
            run(Adjust)();
          }
          break;
        default:
          run(PreFetch)();
      }
      break;
    case CommonProcess.preFetch:
      if (status === ProcessStatus.next) {
        switch (payload.process) {
          case AdapterProcess.clip:
            run(PreClip)();
            break;
          default:
            run(Fetch)();
        }
      }
      if (status === ProcessStatus.done) {
        run(End)();
      }
      break;
    case CommonProcess.fetch:
      run(PostFetch)();
      break;
    case CommonProcess.postFetch:
      if (status === ProcessStatus.next) {
        run(Render)();
      }
      if (status === ProcessStatus.done) {
        run(End)();
      }
      break;
    case CommonProcess.render:
      if (status === ProcessStatus.next) {
        switch (payload.process) {
          case AdapterProcess.append:
          case AdapterProcess.check:
          case AdapterProcess.insert:
          case AdapterProcess.replace:
          case AdapterProcess.update:
            run(Adjust)();
            break;
          default:
            run(PreClip)();
        }
      }
      if (status === ProcessStatus.done) {
        run(End)();
      }
      break;
    case CommonProcess.preClip:
      if (payload.doClip) {
        run(Clip)();
      }
      else {
        run(Adjust)();
      }
      break;
    case CommonProcess.clip:
      run(Adjust)();
      break;
    case CommonProcess.adjust:
      run(End)();
      break;
    case CommonProcess.end:
      if (status === ProcessStatus.next) {
        switch (payload.process) {
          case AdapterProcess.reset:
          case AdapterProcess.reload:
            done();
            run(Init)(payload.process);
            break;
          default:
            run(Start)();
        }
      }
      if (status === ProcessStatus.done) {
        done();
      }
      break;
  }
};

var Workflow = /** @class */ (function () {
  function Workflow(_a) {
    var _this = this;
    var element = _a.element, datasource = _a.datasource, consumer = _a.consumer, run = _a.run;
    this.isInitialized = false;
    this.initTimer = null;
    this.adapterRun$ = new Reactive();
    this.cyclesDone = 0;
    this.interruptionCount = 0;
    this.errors = [];
    this.disposeScrollEventHandler = function () { return null; };
    this.propagateChanges = run;
    this.stateMachineMethods = {
      run: this.runProcess(),
      interrupt: this.interrupt.bind(this),
      done: this.done.bind(this),
      onError: this.onError.bind(this)
    };
    this.scroller = new Scroller({ element: element, datasource: datasource, consumer: consumer, workflow: this.getUpdater() });
    if (this.scroller.settings.initializeDelay) {
      this.initTimer = setTimeout(function () {
        _this.initTimer = null;
        _this.init();
      }, this.scroller.settings.initializeDelay);
    }
    else {
      this.init();
    }
  }
  Workflow.prototype.init = function () {
    var _this = this;
    this.scroller.init(this.adapterRun$);
    this.isInitialized = true;
    // run the Workflow
    this.callWorkflow({
      process: CommonProcess.init,
      status: ProcessStatus.start
    });
    // set up scroll event listener
    var scrollEventReceiver = this.scroller.viewport.scrollEventReceiver;
    var onScrollHandler = function (event) { return _this.callWorkflow({
      process: CommonProcess.scroll,
      status: ProcessStatus.start,
      payload: { event: event }
    }); };
    scrollEventReceiver.addEventListener('scroll', onScrollHandler);
    this.disposeScrollEventHandler = function () {
      return scrollEventReceiver.removeEventListener('scroll', onScrollHandler);
    };
  };
  Workflow.prototype.changeItems = function (items) {
    this.propagateChanges(items);
  };
  Workflow.prototype.callWorkflow = function (processSubject) {
    if (!this.isInitialized) {
      return;
    }
    var process = processSubject.process, status = processSubject.status;
    if (process && process.startsWith('adapter') && status !== ProcessStatus.next) {
      this.adapterRun$.set(processSubject);
    }
    this.process(processSubject);
  };
  Workflow.prototype.getUpdater = function () {
    return {
      call: this.callWorkflow.bind(this),
      onDataChanged: this.changeItems.bind(this),
    };
  };
  Workflow.prototype.process = function (data) {
    var status = data.status, process = data.process, payload = data.payload;
    if (this.scroller.settings.logProcessRun) {
      this.scroller.logger.log(function () { return __spreadArray(__spreadArray(__spreadArray([
        '%cfire%c'
      ], ['color: #cc7777;', 'color: #000000;']), [
        process,
        "\"" + status + "\""
      ]), __read((payload !== void 0 ? [payload] : []))); });
    }
    this.scroller.logger.logProcess(data);
    if (process === CommonProcess.end) {
      this.scroller.finalize();
    }
    runStateMachine({
      input: data,
      methods: this.stateMachineMethods
    });
  };
  Workflow.prototype.runProcess = function () {
    var _this = this;
    return function (_a) {
      var run = _a.run, process = _a.process, name = _a.name;
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (_this.scroller.settings.logProcessRun) {
          _this.scroller.logger.log(function () { return __spreadArray(__spreadArray(__spreadArray([
            '%crun%c'
          ], ['color: #333399;', 'color: #000000;']), [
            process || name
          ]), __read(args)); });
        }
        run.apply(void 0, __spreadArray([_this.scroller], __read(args)));
      };
    };
  };
  Workflow.prototype.onError = function (process, payload) {
    var message = payload && String(payload.error) || '';
    var _a = this.scroller.state, time = _a.time, cycle = _a.cycle;
    this.errors.push({
      process: process,
      message: message,
      time: time,
      loop: cycle.loopIdNext
    });
    this.scroller.logger.logError(message);
  };
  Workflow.prototype.interrupt = function (_a) {
    var _this = this;
    var process = _a.process, finalize = _a.finalize, datasource = _a.datasource;
    if (finalize) {
      var _b = this.scroller, workflow = _b.workflow, logger_1 = _b.logger;
      // we are going to create a new reference for the scroller.workflow object
      // calling the old version of the scroller.workflow by any outstanding async processes will be skipped
      workflow.call = function (p) {
        return logger_1.log('[skip wf call]');
      };
      workflow.call.interrupted = true;
      this.scroller.workflow = this.getUpdater();
      this.interruptionCount++;
      logger_1.log(function () { return "workflow had been interrupted by the " + process + " process (" + _this.interruptionCount + ")"; });
    }
    if (datasource) { // Scroller re-initialization case
      this.scroller.adapter.relax(function () {
        _this.scroller.logger.log('new Scroller instantiation');
        var scroller = new Scroller({ datasource: datasource, scroller: _this.scroller });
        _this.scroller.dispose();
        _this.scroller = scroller;
        _this.scroller.init();
      });
    }
  };
  Workflow.prototype.done = function () {
    var _a = this.scroller, state = _a.state, logger = _a.logger;
    this.cyclesDone++;
    logger.logCycle(false);
    state.cycle.done(this.cyclesDone + 1);
    this.finalize();
  };
  Workflow.prototype.dispose = function () {
    var _this = this;
    if (this.initTimer) {
      clearTimeout(this.initTimer);
    }
    this.disposeScrollEventHandler();
    this.adapterRun$.dispose();
    this.scroller.dispose(true);
    Object.getOwnPropertyNames(this).forEach(function (prop) {
      delete _this[prop];
    });
  };
  Workflow.prototype.finalize = function () {
  };
  return Workflow;
}());

export { AdapterPropName, Direction, EMPTY_ITEM, INVALID_DATASOURCE_PREFIX, SizeStrategy, Workflow, getDefaultAdapterProps, makeDatasource, core as packageInfo };
//# sourceMappingURL=vscroll.esm5.js.map
