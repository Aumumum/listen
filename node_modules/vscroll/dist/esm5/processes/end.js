import { __assign, __extends } from "tslib";
import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';
import { Direction } from '../inputs/index';
import { EMPTY_ITEM } from '../classes/adapter/props';
var isInterrupted = function (_a) {
  var call = _a.call;
  return !!call.interrupted;
};
var End = /** @class */ (function (_super) {
  __extends(End, _super);
  function End() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  End.run = function (scroller, _a) {
    var _b = _a === void 0 ? {} : _a, error = _b.error;
    var workflow = scroller.workflow, interrupter = scroller.state.cycle.interrupter;
    if (!error && !interrupter) {
      // set out params accessible via Adapter
      End.calculateParams(scroller, workflow);
    }
    // explicit interruption for we don't want to go through the inner loop finalizing
    if (isInterrupted(workflow)) {
      workflow.call({ process: End.process, status: ProcessStatus.done });
      return;
    }
    var next = End.finalizeInnerLoop(scroller, error);
    workflow.call({
      process: End.process,
      status: next ? ProcessStatus.next : ProcessStatus.done,
      payload: __assign({}, (interrupter ? { process: interrupter } : {}))
    });
  };
  End.calculateParams = function (scroller, workflow) {
    var adapter = scroller.adapter, viewport = scroller.viewport, items = scroller.buffer.items;
    if (adapter.wanted.firstVisible) {
      var item = viewport.getEdgeVisibleItem(items, Direction.backward).item;
      if (!item || item.element !== adapter.firstVisible.element) {
        adapter.firstVisible = item ? item.get() : EMPTY_ITEM;
      }
    }
    // the workflow can be interrupter on firstVisible change
    if (adapter.wanted.lastVisible && !isInterrupted(workflow)) {
      var item = viewport.getEdgeVisibleItem(items, Direction.forward).item;
      if (!item || item.element !== adapter.lastVisible.element) {
        adapter.lastVisible = item ? item.get() : EMPTY_ITEM;
      }
    }
  };
  End.finalizeInnerLoop = function (scroller, error) {
    var state = scroller.state, _a = scroller.state, cycle = _a.cycle, clip = _a.clip, fetch = _a.fetch;
    var next = !!cycle.interrupter || (error ? false : End.getNext(scroller));
    cycle.innerLoop.isInitial = false;
    fetch.stopSimulate();
    clip.reset(true);
    state.endInnerLoop();
    return next;
  };
  End.getNext = function (scroller) {
    var _a = scroller.state, fetch = _a.fetch, render = _a.render;
    if (fetch.simulate && fetch.isCheck && !render.noSize) { // Adapter.check
      return true;
    }
    if (fetch.simulate && fetch.doRemove) { // Adapter.remove or Adapter.update with clip
      return true;
    }
    if ( // common inner loop (App start, Scroll, Adapter.clip) accompanied by fetch
    !fetch.simulate && ((fetch.hasNewItems && !render.noSize) || fetch.hasAnotherPack)) {
      return true;
    }
    return false;
  };
  return End;
}(BaseProcessFactory(CommonProcess.end)));
export default End;
//# sourceMappingURL=end.js.map