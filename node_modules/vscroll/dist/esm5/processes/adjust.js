import { __extends } from "tslib";
import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';
var Adjust = /** @class */ (function (_super) {
  __extends(Adjust, _super);
  function Adjust() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Adjust.run = function (scroller) {
    var workflow = scroller.workflow, viewport = scroller.viewport, scrollState = scroller.state.scrollState;
    scrollState.positionBeforeAdjust = viewport.scrollPosition;
    Adjust.setPaddings(scroller);
    scrollState.positionAfterAdjust = viewport.scrollPosition;
    // scroll position adjustments
    var position = Adjust.calculatePosition(scroller);
    // set new position using animation frame
    Adjust.setPosition(scroller, position, function () {
      return workflow.call({
        process: Adjust.process,
        status: ProcessStatus.done
      });
    });
  };
  Adjust.setPaddings = function (scroller) {
    var viewport = scroller.viewport, buffer = scroller.buffer, inverse = scroller.settings.inverse, fetch = scroller.state.fetch;
    var firstItem = buffer.getFirstVisibleItem();
    var lastItem = buffer.getLastVisibleItem();
    var first, last;
    if (firstItem && lastItem) {
      first = firstItem.$index;
      last = lastItem.$index;
    }
    else {
      first = !isNaN(fetch.firstVisibleIndex) ? fetch.firstVisibleIndex : buffer.startIndex;
      last = first - 1;
    }
    var _a = viewport.paddings, forward = _a.forward, backward = _a.backward;
    var index, bwdSize = 0, fwdSize = 0;
    // new backward and forward paddings size
    for (index = buffer.finiteAbsMinIndex; index < first; index++) {
      bwdSize += buffer.getSizeByIndex(index);
    }
    for (index = last + 1; index <= buffer.finiteAbsMaxIndex; index++) {
      fwdSize += buffer.getSizeByIndex(index);
    }
    // lack of items case
    var bufferSize = viewport.getScrollableSize() - forward.size - backward.size;
    var viewportSizeDiff = viewport.getSize() - (bwdSize + bufferSize + fwdSize);
    if (viewportSizeDiff > 0) {
      if (inverse) {
        bwdSize += viewportSizeDiff;
      }
      else {
        fwdSize += viewportSizeDiff;
      }
      scroller.logger.log(function () {
        return inverse ? 'backward' : 'forward' + (" padding will be increased by " + viewportSizeDiff + " to fill the viewport");
      });
    }
    backward.size = bwdSize;
    forward.size = fwdSize;
    scroller.logger.stat('after paddings adjustments');
  };
  Adjust.calculatePosition = function (scroller) {
    var viewport = scroller.viewport, buffer = scroller.buffer, state = scroller.state;
    var fetch = state.fetch, render = state.render, scrollState = state.scrollState;
    var position = viewport.paddings.backward.size;
    // backward outlet increase
    if (!isNaN(fetch.firstVisibleIndex) && !isNaN(buffer.firstIndex)) {
      for (var i = buffer.firstIndex; i < fetch.firstVisibleIndex; i++) {
        position += buffer.getSizeByIndex(i);
      }
      if (fetch.firstVisibleItemDelta) {
        position -= fetch.firstVisibleItemDelta;
      }
    }
    else {
      if (fetch.isPrepend && fetch.negativeSize) {
        position += fetch.negativeSize;
      }
    }
    // change per slow fetch/render
    if (scrollState.positionBeforeAsync !== null) {
      var diff = render.positionBefore - scrollState.positionBeforeAsync;
      if (diff !== 0) {
        scroller.logger.log("shift position due to fetch-render difference (" + diff + ")");
        position += diff;
      }
    }
    // offset increase
    if (viewport.offset > 0 && (position || fetch.positions.before)) {
      position += viewport.offset;
    }
    return Math.round(position);
  };
  Adjust.setPosition = function (scroller, position, done) {
    var scrollState = scroller.state.scrollState, viewport = scroller.viewport;
    if (!scrollState.hasPositionChanged(position)) {
      return done();
    }
    scrollState.syntheticPosition = position;
    scrollState.syntheticFulfill = false;
    scrollState.animationFrameId = requestAnimationFrame(function () {
      var inertiaDiff = scrollState.positionAfterAdjust - viewport.scrollPosition;
      var diffLog = '';
      if (inertiaDiff > 0) {
        position -= inertiaDiff;
        scrollState.syntheticPosition = position;
        diffLog = " (-" + inertiaDiff + ")";
      }
      scrollState.syntheticFulfill = true;
      viewport.scrollPosition = position;
      scroller.logger.stat('after scroll adjustment' + diffLog);
      done();
    });
  };
  return Adjust;
}(BaseProcessFactory(CommonProcess.adjust)));
export default Adjust;
//# sourceMappingURL=adjust.js.map