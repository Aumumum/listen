import { __extends } from "tslib";
import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';
var Fetch = /** @class */ (function (_super) {
  __extends(Fetch, _super);
  function Fetch() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Fetch.run = function (scroller) {
    var workflow = scroller.workflow;
    var box = {
      success: function (data) {
        scroller.logger.log(function () {
          return "resolved " + data.length + " items " +
            ("(index = " + scroller.state.fetch.index + ", count = " + scroller.state.fetch.count + ")");
        });
        scroller.state.fetch.newItemsData = data;
        workflow.call({
          process: Fetch.process,
          status: ProcessStatus.next
        });
      },
      fail: function (error) {
        return workflow.call({
          process: Fetch.process,
          status: ProcessStatus.error,
          payload: { error: error }
        });
      }
    };
    var result = Fetch.get(scroller);
    Fetch.complete(scroller, box, result);
  };
  Fetch.complete = function (scroller, box, result) {
    if (Object.prototype.hasOwnProperty.call(result, 'data')) {
      var _a = result, data = _a.data, error = _a.error, isError = _a.isError;
      if (!isError) {
        box.success(data || []);
      }
      else {
        box.fail(error);
      }
    }
    else {
      var _b = scroller.state, scrollState = _b.scrollState, fetch_1 = _b.fetch, viewport = scroller.viewport;
      if (scrollState.positionBeforeAsync === null) {
        scrollState.positionBeforeAsync = viewport.scrollPosition;
      }
      fetch_1.cancel = function () {
        box.success = function () { return null; };
        box.fail = function () { return null; };
      };
      result.then(function (data) { return box.success(data); }, function (error) { return box.fail(error); });
    }
  };
  Fetch.get = function (scroller) {
    var _get = scroller.datasource.get;
    var _a = scroller.state.fetch, index = _a.index, count = _a.count;
    var immediateData, immediateError;
    var resolve, reject;
    var done = function (data) {
      if (!resolve) {
        immediateData = data || null;
        return;
      }
      resolve(data);
    };
    var fail = function (error) {
      if (!reject) {
        immediateError = error || null;
        return;
      }
      reject(error);
    };
    var getResult = _get(index, count, done, fail);
    if (getResult && typeof getResult === 'object' && getResult !== null) {
      if (typeof getResult.then === 'function') {
        return getResult;
      }
      else if (typeof getResult.subscribe === 'function') {
        var sub_1 = getResult.subscribe(done, fail, function () {
          if (sub_1 && typeof sub_1 === 'object' && typeof sub_1.unsubscribe === 'function') {
            sub_1.unsubscribe();
          }
        });
      }
    }
    if (immediateData || immediateError) { // callback case or immediate observable
      return {
        data: immediateError ? null : (immediateData || []),
        error: immediateError,
        isError: !!immediateError
      };
    }
    return new Promise(function (_resolve, _reject) {
      resolve = _resolve;
      reject = _reject;
    });
  };
  return Fetch;
}(BaseProcessFactory(CommonProcess.fetch)));
export default Fetch;
//# sourceMappingURL=fetch.js.map