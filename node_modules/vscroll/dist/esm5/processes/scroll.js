import { __assign, __extends } from "tslib";
import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';
import { Direction } from '../inputs/index';
var Scroll = /** @class */ (function (_super) {
  __extends(Scroll, _super);
  function Scroll() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  Scroll.run = function (scroller, payload) {
    var workflow = scroller.workflow, viewport = scroller.viewport;
    var position = viewport.scrollPosition;
    if (Scroll.onSynthetic(scroller, position)) {
      return;
    }
    Scroll.onThrottle(scroller, position, function () {
      return Scroll.onScroll(scroller, workflow);
    });
  };
  Scroll.onSynthetic = function (scroller, position) {
    var scrollState = scroller.state.scrollState;
    var synthPos = scrollState.syntheticPosition;
    if (synthPos !== null) {
      if (scrollState.syntheticFulfill) {
        scrollState.syntheticPosition = null;
      }
      if (!scrollState.syntheticFulfill || synthPos === position) {
        scroller.logger.log(function () { return [
          'skipping scroll', position,
          "[" + (scrollState.syntheticFulfill ? '' : 'pre-') + "synthetic]"
        ]; });
        return true;
      }
      scroller.logger.log(function () { return [
        'synthetic scroll has been fulfilled:', position, position < synthPos ? '<' : '>', synthPos
      ]; });
    }
    return false;
  };
  Scroll.onThrottle = function (scroller, position, done) {
    var scrollState = scroller.state.scrollState, throttle = scroller.settings.throttle, logger = scroller.logger;
    scrollState.current = Scroll.getScrollEvent(position, scrollState.previous);
    var _a = scrollState.current, direction = _a.direction, time = _a.time;
    var timeDiff = scrollState.previous ? time - scrollState.previous.time : Infinity;
    var delta = throttle - timeDiff;
    var shouldDelay = isFinite(delta) && delta > 0;
    var alreadyDelayed = !!scrollState.scrollTimer;
    logger.log(function () { return [
      direction === Direction.backward ? '\u2934' : '\u2935',
      position,
      shouldDelay ? (timeDiff + 'ms') : '0ms',
      shouldDelay ? (alreadyDelayed ? 'delayed' : "/ " + delta + "ms delay") : ''
    ]; });
    if (!shouldDelay) {
      if (scrollState.scrollTimer) {
        clearTimeout(scrollState.scrollTimer);
        scrollState.scrollTimer = null;
      }
      done();
      return;
    }
    if (!alreadyDelayed) {
      scrollState.scrollTimer = setTimeout(function () {
        logger.log(function () {
          var curr = Scroll.getScrollEvent(scroller.viewport.scrollPosition, scrollState.current);
          return [
            curr.direction === Direction.backward ? '\u2934' : '\u2935',
            curr.position,
            (curr.time - time) + 'ms',
            'triggered by timer set on',
            position
          ];
        });
        scrollState.scrollTimer = null;
        done();
      }, delta);
    }
  };
  Scroll.getScrollEvent = function (position, previous) {
    var time = Number(new Date());
    var direction = Direction.forward;
    if (previous) {
      if (position === previous.position) {
        direction = previous.direction;
      }
      else if (position < previous.position) {
        direction = Direction.backward;
      }
    }
    return { position: position, direction: direction, time: time };
  };
  Scroll.onScroll = function (scroller, workflow) {
    var _a = scroller.state, scrollState = _a.scrollState, cycle = _a.cycle;
    scrollState.previous = __assign({}, scrollState.current);
    scrollState.current = null;
    if (cycle.busy.get()) {
      scroller.logger.log(function () { return ['skipping scroll', scrollState.previous.position, '[pending]']; });
      return;
    }
    workflow.call({
      process: Scroll.process,
      status: ProcessStatus.next
    });
  };
  return Scroll;
}(BaseProcessFactory(CommonProcess.scroll)));
export default Scroll;
//# sourceMappingURL=scroll.js.map