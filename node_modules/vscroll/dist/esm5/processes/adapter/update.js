import { __extends, __read, __spreadArray } from "tslib";
import { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';
import { Item } from '../../classes/item';
import { Direction } from '../../inputs/index';
var Update = /** @class */ (function (_super) {
  __extends(Update, _super);
  function Update() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Update.run = function (scroller, options) {
    var params = Update.parseInput(scroller, options).params;
    if (!params) {
      return;
    }
    var shouldUpdate = Update.doUpdate(scroller, params);
    scroller.workflow.call({
      process: Update.process,
      status: shouldUpdate ? ProcessStatus.next : ProcessStatus.done
    });
  };
  Update.doUpdate = function (scroller, params) {
    var buffer = scroller.buffer, viewport = scroller.viewport, fetch = scroller.state.fetch, routines = scroller.routines, logger = scroller.logger;
    if (!buffer.items) {
      logger.log(function () { return 'no items in Buffer'; });
      return false;
    }
    var before = __spreadArray([], __read(buffer.items));
    var _a = viewport.getEdgeVisibleItem(buffer.items, Direction.backward), firstItem = _a.item, firstIndex = _a.index, firstItemDiff = _a.diff;
    var trackedIndex = buffer.updateItems(params.predicate, function (index, data) { return new Item(index, data, routines); }, firstIndex, !!params.fixRight);
    var delta = 0;
    var trackedItem = buffer.get(trackedIndex);
    if (firstItem && firstItem === trackedItem) {
      delta = -buffer.getSizeByIndex(trackedIndex) + firstItemDiff;
    }
    var itemsToRemove = before.filter(function (_a) {
      var toRemove = _a.toRemove;
      return toRemove;
    });
    itemsToRemove.forEach(function (item) { return item.hide(); });
    logger.log(function () { return itemsToRemove.length
      ? 'items to remove: [' + itemsToRemove.map(function (_a) {
        var $index = _a.$index;
        return $index;
      }).join(',') + ']'
      : 'no items to remove'; });
    var itemsToRender = buffer.items.filter(function (_a) {
      var toInsert = _a.toInsert;
      return toInsert;
    });
    logger.log(function () { return itemsToRender.length
      ? 'items to render: [' + itemsToRender.map(function (_a) {
        var $index = _a.$index;
        return $index;
      }).join(',') + ']'
      : 'no items to render'; });
    fetch.update(trackedIndex, delta, itemsToRender, itemsToRemove);
    return !!itemsToRemove.length || !!itemsToRender.length;
  };
  return Update;
}(BaseAdapterProcessFactory(AdapterProcess.update)));
export default Update;
//# sourceMappingURL=update.js.map