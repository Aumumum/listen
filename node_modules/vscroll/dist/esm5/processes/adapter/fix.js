import { __extends, __read, __spreadArray } from "tslib";
import { AdapterMethods } from '../../inputs/index';
import { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';
var _a = AdapterMethods, _b = AdapterProcess.fix, FixParams = _a[_b];
var Fix = /** @class */ (function (_super) {
  __extends(Fix, _super);
  function Fix() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Fix.run = function (scroller, options) {
    var workflow = scroller.workflow;
    var _a = Fix.parseInput(scroller, options), data = _a.data, params = _a.params;
    if (!params) {
      return;
    }
    Object.entries(data.params).forEach(function (_a) {
      var _b = __read(_a, 2), key = _b[0], value = _b[1];
      if (value.isSet && value.isValid) {
        Fix.runByType(scroller, key, value.value, data);
      }
    });
    workflow.call({
      process: Fix.process,
      status: ProcessStatus.done
    });
  };
  Fix.runByType = function (scroller, token, value, methodData) {
    switch (token) {
      case FixParams.scrollPosition:
        return Fix.setScrollPosition(scroller, value);
      case FixParams.minIndex:
        return Fix.setMinIndex(scroller, value);
      case FixParams.maxIndex:
        return Fix.setMaxIndex(scroller, value);
      case FixParams.updater:
        return Fix.updateItems(scroller, value);
      case FixParams.scrollToItem:
        if (methodData.params) {
          var scrollToItemOpt = methodData.params[FixParams.scrollToItemOpt];
          var options = scrollToItemOpt ? scrollToItemOpt.value : void 0;
          return Fix.scrollToItem(scroller, value, options);
        }
        return;
      case FixParams.scrollToItemOpt:
        return;
    }
  };
  Fix.setScrollPosition = function (_a, value) {
    var viewport = _a.viewport;
    var result = value;
    if (value === -Infinity) {
      result = 0;
    }
    else if (value === Infinity) {
      result = viewport.getScrollableSize();
    }
    viewport.setPosition(result);
  };
  Fix.setMinIndex = function (_a, value) {
    var buffer = _a.buffer, settings = _a.settings;
    settings.minIndex = value;
    buffer.absMinIndex = value;
  };
  Fix.setMaxIndex = function (_a, value) {
    var buffer = _a.buffer, settings = _a.settings;
    settings.maxIndex = value;
    buffer.absMaxIndex = value;
  };
  Fix.updateItems = function (_a, value) {
    var buffer = _a.buffer, logger = _a.logger;
    var updateReference = false;
    var updater = function () { return updateReference = true; };
    buffer.items.forEach(function (item) { return value(item.get(), updater); });
    if (updateReference) {
      logger.log(function () { return 'update Buffer.items reference'; });
      buffer.items = __spreadArray([], __read(buffer.items));
    }
  };
  Fix.scrollToItem = function (scroller, value, options) {
    var found = scroller.buffer.items.find(function (item) { return value(item.get()); });
    if (!found) {
      scroller.logger.log(function () { return 'scrollToItem cancelled, item not found'; });
      return;
    }
    found.scrollTo(options);
  };
  return Fix;
}(BaseAdapterProcessFactory(AdapterProcess.fix)));
export default Fix;
//# sourceMappingURL=fix.js.map