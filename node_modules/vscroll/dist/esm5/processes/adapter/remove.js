import { __extends } from "tslib";
import { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';
import { Direction } from '../../inputs/index';
var Remove = /** @class */ (function (_super) {
  __extends(Remove, _super);
  function Remove() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Remove.run = function (scroller, options) {
    var params = Remove.parseInput(scroller, options).params;
    if (!params) {
      return;
    }
    var shouldRemove = Remove.doRemove(scroller, params);
    scroller.workflow.call({
      process: Remove.process,
      status: shouldRemove ? ProcessStatus.next : ProcessStatus.done
    });
  };
  Remove.doRemove = function (scroller, params, sequenceOnly) {
    if (sequenceOnly === void 0) { sequenceOnly = false; }
    var fetch = scroller.state.fetch;
    fetch.firstVisibleIndex = NaN;
    var bufferRemoveList = Remove.removeBufferedItems(scroller, params);
    if (params.indexes && params.indexes.length) { // to avoid duplicate buffer-virtual removals
      params.indexes = params.indexes.filter(function (i) { return !bufferRemoveList.includes(i); });
    }
    var shouldRemoveBuffered = bufferRemoveList.length > 0;
    var shouldRemoveVirtual = Remove.removeVirtualItems(scroller, params, sequenceOnly);
    if (!shouldRemoveBuffered && !shouldRemoveVirtual) {
      return false;
    }
    if (!isNaN(fetch.firstVisibleIndex)) {
      fetch.remove();
    }
    scroller.logger.stat('after remove');
    return true;
  };
  Remove.removeBufferedItems = function (scroller, options) {
    var predicate = options.predicate, indexes = options.indexes, increase = options.increase;
    var result = [];
    if (predicate) {
      result = Remove.runPredicateOverBuffer(scroller, predicate, !!increase);
    }
    if (indexes) {
      var indexPredicate = function (_a) {
        var $index = _a.$index;
        return indexes.indexOf($index) >= 0;
      };
      result = Remove.runPredicateOverBuffer(scroller, indexPredicate, !!increase);
    }
    return result;
  };
  Remove.runPredicateOverBuffer = function (scroller, predicate, increase) {
    var viewport = scroller.viewport, buffer = scroller.buffer, items = scroller.buffer.items, fetch = scroller.state.fetch;
    // get items to remove
    var clipList = [];
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (predicate(item.get())) {
        clipList.push(item);
        item.toRemove = true;
      }
      else if (clipList.length) {
        break; // allow only first strict uninterrupted sequence
      }
    }
    if (!clipList.length) {
      return [];
    }
    // what item should be shown after remove (1-4)
    var firstClipIndex = clipList[0].$index, lastClipIndex = clipList[clipList.length - 1].$index;
    // 1) current first visible item will remain
    var _a = viewport.getEdgeVisibleItem(buffer.items, Direction.backward), firstIndex = _a.index, diff = _a.diff;
    if (firstIndex < firstClipIndex || firstIndex > lastClipIndex) {
      fetch.firstVisibleIndex = firstIndex;
      fetch.firstVisibleItemDelta = -buffer.getSizeByIndex(firstIndex) + diff;
    }
    // 2) next after the last removed item
    if (isNaN(fetch.firstVisibleIndex) && lastClipIndex < buffer.finiteAbsMaxIndex) {
      fetch.firstVisibleIndex = lastClipIndex + 1;
    }
    // 3) prev before the first removed item
    if (isNaN(fetch.firstVisibleIndex) && firstClipIndex > buffer.finiteAbsMinIndex) {
      fetch.firstVisibleIndex = firstClipIndex - 1;
    }
    // 4) prev before the first removed item
    if (isNaN(fetch.firstVisibleIndex)) {
      fetch.firstVisibleIndex = buffer.finiteAbsMinIndex;
    }
    // logical removal
    var indexListToRemove = clipList.map(function (item) { return item.$index; });
    scroller.logger.log(function () {
      return "going to remove " + clipList.length + " item(s) from Buffer: [" + indexListToRemove.join(',') + "]";
    });
    buffer.removeItems(indexListToRemove, increase, false);
    buffer.checkDefaultSize();
    Remove.shiftFirstVisibleIndex(scroller, indexListToRemove, increase);
    // physical removal (hiding)
    clipList.forEach(function (item) { return item.hide(); });
    return indexListToRemove;
  };
  Remove.removeVirtualItems = function (scroller, params, sequenceOnly) {
    var indexes = params.indexes, increase = params.increase;
    if (!indexes || !indexes.length) {
      return false;
    }
    var buffer = scroller.buffer, viewport = scroller.viewport, fetch = scroller.state.fetch;
    // get items to remove
    var finiteAbsMinIndex = buffer.finiteAbsMinIndex, firstIndex = buffer.firstIndex, finiteAbsMaxIndex = buffer.finiteAbsMaxIndex, lastIndex = buffer.lastIndex;
    var toRemove = [];
    var last = NaN;
    for (var i = 0, len = indexes.length; i < len; i++) {
      var index = indexes[i];
      if (index >= finiteAbsMinIndex && !isNaN(firstIndex) && index < firstIndex) {
        toRemove.push(index); // backward;
      }
      else if (index <= finiteAbsMaxIndex && !isNaN(lastIndex) && index > lastIndex) {
        toRemove.push(index); // forward;
      }
      else {
        continue;
      }
      if (sequenceOnly && !isNaN(last) && Math.abs(last - index) > 1) {
        // allow only first strict uninterrupted sequence
        break;
      }
      last = index;
    }
    if (!toRemove.length) {
      return false;
    }
    // what should be shown after remove; Buffer removal has priority
    if (isNaN(fetch.firstVisibleIndex)) {
      var _a = viewport.getEdgeVisibleItem(buffer.items, Direction.backward), index = _a.index, diff = _a.diff;
      if (!isNaN(index)) {
        fetch.firstVisibleIndex = index;
        fetch.firstVisibleItemDelta = -buffer.getSizeByIndex(index) + diff;
      }
    }
    // virtual removal
    scroller.logger.log(function () { return "going to remove " + toRemove.length + " item(s) virtually"; });
    buffer.removeItems(toRemove, !!increase, true);
    buffer.checkDefaultSize();
    Remove.shiftFirstVisibleIndex(scroller, toRemove, !!increase);
    return true;
  };
  Remove.shiftFirstVisibleIndex = function (_a, listToRemove, increase) {
    var fetch = _a.state.fetch;
    if (isNaN(fetch.firstVisibleIndex)) {
      return;
    }
    var shift = listToRemove.reduce(function (acc, index) { return acc + (((increase && index > fetch.firstVisibleIndex) || (!increase && index < fetch.firstVisibleIndex)) ? 1 : 0); }, 0);
    fetch.firstVisibleIndex = fetch.firstVisibleIndex + (increase ? shift : -shift);
  };
  return Remove;
}(BaseAdapterProcessFactory(AdapterProcess.remove)));
export default Remove;
//# sourceMappingURL=remove.js.map