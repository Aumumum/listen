import { __extends } from "tslib";
import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';
import { Item } from '../classes/item';
var PostFetch = /** @class */ (function (_super) {
  __extends(PostFetch, _super);
  function PostFetch() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PostFetch.run = function (scroller) {
    var workflow = scroller.workflow;
    if (PostFetch.setItems(scroller)) {
      PostFetch.setBufferLimits(scroller);
      workflow.call({
        process: PostFetch.process,
        status: scroller.state.fetch.hasNewItems
          ? ProcessStatus.next
          : ProcessStatus.done
      });
    }
    else {
      workflow.call({
        process: PostFetch.process,
        status: ProcessStatus.error,
        payload: { error: 'Can\'t set buffer items' }
      });
    }
  };
  PostFetch.setBufferLimits = function (scroller) {
    var buffer = scroller.buffer, _a = scroller.state, fetch = _a.fetch, items = _a.fetch.items, innerLoop = _a.cycle.innerLoop;
    var first = fetch.first.index;
    var last = fetch.last.index;
    if (!items.length) {
      if (last < buffer.minIndex || innerLoop.isInitial) {
        buffer.absMinIndex = buffer.minIndex;
      }
      if (first > buffer.maxIndex || innerLoop.isInitial) {
        buffer.absMaxIndex = buffer.maxIndex;
      }
    }
    else {
      var lastIndex = items.length - 1;
      if (first < items[0].$index) {
        buffer.absMinIndex = items[0].$index;
      }
      if (last > items[lastIndex].$index) {
        buffer.absMaxIndex = items[lastIndex].$index;
      }
    }
  };
  PostFetch.setItems = function (scroller) {
    var buffer = scroller.buffer, _a = scroller.state, fetch = _a.fetch, cycle = _a.cycle;
    var items = fetch.newItemsData;
    if (!items || !items.length) { // empty result
      return true;
    }
    // eof/bof case, need to shift fetch index if bof
    var fetchIndex = fetch.index;
    if (items.length < fetch.count) {
      if (cycle.innerLoop.isInitial) {
        // let's treat initial poor fetch as startIndex-bof
        fetchIndex = buffer.startIndex;
      }
      else if (fetch.first.index < buffer.minIndex) { // normal bof
        fetchIndex = buffer.minIndex - items.length;
      }
    }
    fetch.items = items.map(function (item, index) {
      return new Item(fetchIndex + index, item, scroller.routines);
    });
    fetch.isPrepend = !!buffer.items.length && buffer.items[0].$index > fetch.items[fetch.items.length - 1].$index;
    return buffer.setItems(fetch.items);
  };
  return PostFetch;
}(BaseProcessFactory(CommonProcess.postFetch)));
export default PostFetch;
//# sourceMappingURL=postFetch.js.map