import { __extends } from "tslib";
import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';
var Render = /** @class */ (function (_super) {
  __extends(Render, _super);
  function Render() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Render.run = function (scroller) {
    var workflow = scroller.workflow, _a = scroller.state, cycle = _a.cycle, render = _a.render, scrollState = _a.scrollState, viewport = scroller.viewport;
    scroller.logger.stat('before new items render');
    if (scrollState.positionBeforeAsync === null) {
      scrollState.positionBeforeAsync = viewport.scrollPosition;
    }
    render.renderTimer = setTimeout(function () {
      render.renderTimer = null;
      if (Render.doRender(scroller)) {
        workflow.call({
          process: Render.process,
          status: render.noSize ? ProcessStatus.done : ProcessStatus.next,
          payload: { process: cycle.initiator }
        });
      }
      else {
        workflow.call({
          process: Render.process,
          status: ProcessStatus.error,
          payload: { error: 'Can\'t associate item with element' }
        });
      }
    }, 0);
  };
  Render.doRender = function (scroller) {
    var _a = scroller.state, fetch = _a.fetch, render = _a.render, viewport = scroller.viewport, buffer = scroller.buffer, logger = scroller.logger;
    render.positionBefore = viewport.scrollPosition;
    if (!fetch.isCheck) {
      render.sizeBefore = viewport.getScrollableSize();
      if (fetch.items.map(function (item) { return Render.processElement(scroller, item); }).some(function (x) { return !x; })) {
        return false;
      }
    }
    buffer.checkDefaultSize();
    render.sizeAfter = viewport.getScrollableSize();
    logger.stat('after new items render');
    logger.log(function () { return render.noSize ? 'viewport size has not been changed' : void 0; });
    return true;
  };
  Render.processElement = function (scroller, item) {
    var fetch = scroller.state.fetch, viewport = scroller.viewport, buffer = scroller.buffer;
    var element = viewport.element.querySelector("[data-sid=\"" + item.nodeId + "\"]");
    if (!element) {
      return false;
    }
    item.element = element;
    item.element.style.left = '';
    item.element.style.top = '';
    item.element.style.position = '';
    item.invisible = false;
    item.setSize();
    buffer.cacheItem(item);
    if (item.$index < fetch.minIndex) {
      fetch.negativeSize += item.size;
    }
    return true;
  };
  return Render;
}(BaseProcessFactory(CommonProcess.render)));
export default Render;
//# sourceMappingURL=render.js.map