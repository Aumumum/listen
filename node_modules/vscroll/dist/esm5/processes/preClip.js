import { __extends } from "tslib";
import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';
import { Direction } from '../inputs/index';
var PreClip = /** @class */ (function (_super) {
  __extends(PreClip, _super);
  function PreClip() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PreClip.run = function (scroller) {
    PreClip.prepareClip(scroller);
    scroller.workflow.call({
      process: PreClip.process,
      status: ProcessStatus.next,
      payload: {
        doClip: scroller.state.clip.doClip
      }
    });
  };
  PreClip.prepareClip = function (scroller) {
    var _a = scroller.state, fetch = _a.fetch, clip = _a.clip;
    if (PreClip.shouldNotClip(scroller)) {
      return;
    }
    var firstIndex = fetch.first.indexBuffer;
    var lastIndex = fetch.last.indexBuffer;
    scroller.logger.log(function () {
      return "looking for " + (fetch.direction ? 'anti-' + fetch.direction + ' ' : '') + "items " +
        ("that are out of [" + firstIndex + ".." + lastIndex + "] range");
    });
    if (PreClip.isBackward(scroller, firstIndex)) {
      PreClip.prepareClipByDirection(scroller, Direction.backward, firstIndex);
    }
    if (PreClip.isForward(scroller, lastIndex)) {
      PreClip.prepareClipByDirection(scroller, Direction.forward, lastIndex);
    }
    if (!clip.doClip) {
      scroller.logger.log('skipping clip [no items to clip]');
    }
    return;
  };
  PreClip.shouldNotClip = function (scroller) {
    var settings = scroller.settings, buffer = scroller.buffer, state = scroller.state;
    if (settings.infinite && !state.clip.force) {
      scroller.logger.log('skipping clip [infinite mode]');
      return true;
    }
    if (!buffer.size) {
      scroller.logger.log('skipping clip [empty buffer]');
      return true;
    }
    if (state.cycle.isInitial) {
      scroller.logger.log('skipping clip [initial cycle]');
      return true;
    }
    return false;
  };
  PreClip.isBackward = function (scroller, firstIndex) {
    var buffer = scroller.buffer, _a = scroller.state, clip = _a.clip, fetch = _a.fetch;
    if (clip.force) {
      return clip.forceBackward;
    }
    if (fetch.direction !== Direction.backward) {
      if (firstIndex - 1 >= buffer.absMinIndex) {
        return true;
      }
    }
    return false;
  };
  PreClip.isForward = function (scroller, lastIndex) {
    var buffer = scroller.buffer, _a = scroller.state, clip = _a.clip, fetch = _a.fetch;
    if (clip.force) {
      return clip.forceForward;
    }
    if (fetch.direction !== Direction.forward) {
      if (lastIndex + 1 <= buffer.absMaxIndex) {
        return true;
      }
    }
    return false;
  };
  PreClip.prepareClipByDirection = function (scroller, direction, edgeIndex) {
    var forward = direction === Direction.forward;
    scroller.buffer.items.forEach(function (item) {
      if ((!forward && item.$index < edgeIndex) ||
        (forward && item.$index > edgeIndex)) {
        item.toRemove = true;
        item.removeDirection = direction;
        scroller.state.clip.doClip = true;
      }
    });
  };
  return PreClip;
}(BaseProcessFactory(CommonProcess.preClip)));
export default PreClip;
//# sourceMappingURL=preClip.js.map