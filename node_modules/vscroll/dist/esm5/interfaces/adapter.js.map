{"version":3,"file":"adapter.js","sourceRoot":"","sources":["../../../src/interfaces/adapter.ts"],"names":[],"mappings":"","sourcesContent":["import { AdapterPropName, AdapterPropType } from '../classes/adapter/props';\r\nimport { Reactive } from '../classes/reactive';\r\nimport { IDatasourceOptional } from './datasource';\r\nimport { IValidatedData } from './validation';\r\n\r\nexport interface IReactivePropConfig {\r\n  source: unknown;\r\n  emit: (source: unknown, value: unknown) => void;\r\n}\r\n\r\ninterface IReactivePropStore extends IReactivePropConfig {\r\n  default: Reactive<unknown>;\r\n}\r\n\r\nexport type IReactivePropsConfig = {\r\n  [key in AdapterPropName]?: IReactivePropConfig;\r\n};\r\n\r\nexport type IReactivePropsStore = {\r\n  [key in AdapterPropName]?: IReactivePropStore;\r\n};\r\n\r\nexport interface IAdapterConfig {\r\n  mock: boolean;\r\n  reactive?: IReactivePropsConfig;\r\n}\r\n\r\nexport interface IAdapterProp {\r\n  name: AdapterPropName;\r\n  type: AdapterPropType;\r\n  value: unknown;\r\n  reactive?: AdapterPropName;\r\n  wanted?: boolean;\r\n  onDemand?: boolean;\r\n  permanent?: boolean;\r\n}\r\n\r\nexport interface ItemAdapter<Data = unknown> {\r\n  $index: number;\r\n  data: Data;\r\n  element?: HTMLElement;\r\n}\r\n\r\nexport type ItemsPredicate<T = unknown> = (item: ItemAdapter<T>) => boolean;\r\nexport type ItemsUpdater<T = unknown> = (item: ItemAdapter<T>, update: () => void) => void;\r\nexport type ItemsProcessor<T = unknown> = (items: ItemAdapter<T>[]) => void;\r\nexport type BufferUpdater<T = unknown> = (item: ItemAdapter<T>) => unknown;\r\n\r\nexport interface IPackage {\r\n  name: string;\r\n  version: string;\r\n}\r\n\r\nexport interface IPackages {\r\n  core: IPackage;\r\n  consumer: IPackage;\r\n}\r\n\r\nexport interface IBufferInfo {\r\n  firstIndex: number;\r\n  lastIndex: number;\r\n  minIndex: number;\r\n  maxIndex: number;\r\n  absMinIndex: number;\r\n  absMaxIndex: number;\r\n  defaultSize: number;\r\n}\r\n\r\nexport interface IAdapterInput<T> {\r\n  data: IValidatedData;\r\n  params?: T;\r\n}\r\n\r\nexport interface AdapterAppendOptions<Data = unknown> {\r\n  items: Data[];\r\n  eof?: boolean;\r\n}\r\n\r\nexport interface AdapterPrependOptions<Data = unknown> {\r\n  items: Data[];\r\n  bof?: boolean;\r\n}\r\n\r\nexport interface AdapterRemoveOptions<Data = unknown> {\r\n  predicate?: ItemsPredicate<Data>;\r\n  indexes?: number[];\r\n  increase?: boolean;\r\n}\r\n\r\nexport interface AdapterClipOptions {\r\n  forwardOnly?: boolean;\r\n  backwardOnly?: boolean;\r\n}\r\n\r\nexport interface AdapterInsertOptions<Data = unknown> {\r\n  items: Data[];\r\n  before?: ItemsPredicate<Data>;\r\n  after?: ItemsPredicate<Data>;\r\n  decrease?: boolean;\r\n}\r\n\r\nexport interface AdapterReplaceOptions<Data = unknown> {\r\n  items: Data[];\r\n  predicate: ItemsPredicate<Data>;\r\n  fixRight?: boolean;\r\n}\r\n\r\nexport interface AdapterUpdateOptions<Data = unknown> {\r\n  predicate: BufferUpdater<Data>;\r\n  fixRight?: boolean;\r\n}\r\n\r\nexport interface AdapterFixOptions<Data = unknown> {\r\n  scrollPosition?: number;\r\n  minIndex?: number;\r\n  maxIndex?: number;\r\n  updater?: ItemsUpdater<Data>;\r\n  scrollToItem?: ItemsPredicate<Data>;\r\n  scrollToItemOpt?: boolean | ScrollIntoViewOptions;\r\n}\r\n\r\nexport interface AdapterMethodResult {\r\n  success: boolean;\r\n  immediate: boolean;\r\n  details: string | null;\r\n}\r\ntype MethodResult = Promise<AdapterMethodResult>;\r\n\r\nexport interface IAdapter<Data = unknown> {\r\n  readonly id: number;\r\n  readonly mock: boolean;\r\n  readonly augmented: boolean;\r\n  readonly version: string;\r\n  readonly init: boolean;\r\n  readonly init$: Reactive<boolean>;\r\n  readonly packageInfo: IPackages;\r\n  readonly itemsCount: number;\r\n  readonly bufferInfo: IBufferInfo;\r\n  readonly isLoading: boolean;\r\n  readonly isLoading$: Reactive<boolean>;\r\n  readonly loopPending: boolean;\r\n  readonly loopPending$: Reactive<boolean>;\r\n  readonly firstVisible: ItemAdapter<Data>;\r\n  readonly firstVisible$: Reactive<ItemAdapter<Data>>;\r\n  readonly lastVisible: ItemAdapter<Data>;\r\n  readonly lastVisible$: Reactive<ItemAdapter<Data>>;\r\n  readonly bof: boolean;\r\n  readonly bof$: Reactive<boolean>;\r\n  readonly eof: boolean;\r\n  readonly eof$: Reactive<boolean>;\r\n  reset(datasource?: IDatasourceOptional): MethodResult;\r\n  reload(reloadIndex?: number | string): MethodResult;\r\n  append(options: AdapterAppendOptions<Data>): MethodResult;\r\n  append(items: Data | Data[], eof?: boolean): MethodResult; // old signature\r\n  prepend(options: AdapterPrependOptions<Data>): MethodResult;\r\n  prepend(items: Data | Data[], bof?: boolean): MethodResult; // old signature\r\n  check(): MethodResult;\r\n  remove(args: AdapterRemoveOptions<Data>): MethodResult;\r\n  remove(args: ItemsPredicate<Data>): MethodResult; // old signature\r\n  clip(options?: AdapterClipOptions): MethodResult;\r\n  insert(options: AdapterInsertOptions<Data>): MethodResult;\r\n  replace(options: AdapterReplaceOptions<Data>): MethodResult;\r\n  update(options: AdapterUpdateOptions<Data>): MethodResult;\r\n  fix(options: AdapterFixOptions<Data>): MethodResult; // experimental\r\n  relax(callback?: () => void): MethodResult;\r\n  showLog(): void;\r\n}\r\n"]}