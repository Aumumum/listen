import { DefaultSize } from './defaultSize';
var ItemCache = /** @class */ (function () {
  function ItemCache(item, saveData) {
    this.$index = item.$index;
    this.nodeId = item.nodeId;
    this.data = saveData ? item.data : null;
    this.size = item.size;
  }
  ItemCache.prototype.changeIndex = function (value) {
    this.$index = value;
    this.nodeId = String(value);
  };
  return ItemCache;
}());
export { ItemCache };
var Cache = /** @class */ (function () {
  function Cache(_a, logger) {
    var itemSize = _a.itemSize, cacheData = _a.cacheData, cacheOnReload = _a.cacheOnReload, sizeStrategy = _a.sizeStrategy;
    this.itemSize = itemSize;
    this.saveData = cacheData;
    this.cacheOnReload = cacheOnReload;
    this.sizeStrategy = sizeStrategy;
    this.logger = logger;
    this.items = new Map();
    this.defaultSize = new DefaultSize(itemSize, sizeStrategy);
    this.reset(true);
  }
  Cache.prototype.reset = function (force) {
    force = force || !this.cacheOnReload;
    if (force) {
      this.minIndex = +Infinity;
      this.maxIndex = -Infinity;
      this.items.clear();
    }
    this.defaultSize.reset(force);
  };
  Object.defineProperty(Cache.prototype, "size", {
    get: function () {
      return this.items.size;
    },
    enumerable: false,
    configurable: true
  });
  Cache.prototype.get = function (index) {
    return this.items.get(index);
  };
  Cache.prototype.getItemSize = function (index) {
    var item = this.get(index);
    return item ? item.size : 0;
  };
  Cache.prototype.getDefaultSize = function () {
    return this.defaultSize.get();
  };
  Cache.prototype.recalculateDefaultSize = function () {
    var _this = this;
    if (this.defaultSize.recalculate(this.size)) {
      this.logger.log(function () { return "default size has been updated: " + _this.defaultSize.get(); });
      return true;
    }
    return false;
  };
  /**
   * Adds item to Set by $index, replaces existed item if $index matches.
   * Maintains min/max indexes and default item size.
   *
   * @param {Item<Data>} item A Buffer item to be cached, an objects with { $index, data, size } props.
   *
   * @returns {ItemCache<Data>} Cached item.
   */
  Cache.prototype.add = function (item) {
    var itemCache = this.get(item.$index);
    if (itemCache) { // adding item is already cached
      if (this.saveData) {
        itemCache.data = item.data;
      }
      if (itemCache.size !== item.size) { // size changes
        if (itemCache.size !== void 0) {
          this.defaultSize.setExisted(itemCache, item);
        }
        else {
          this.defaultSize.setNew(item);
        }
        itemCache.size = item.size;
      }
    }
    else {
      itemCache = new ItemCache(item, this.saveData);
      this.items.set(item.$index, itemCache);
      this.defaultSize.setNew(itemCache);
    }
    if (item.$index < this.minIndex) {
      this.minIndex = item.$index;
    }
    if (item.$index > this.maxIndex) {
      this.maxIndex = item.$index;
    }
    return itemCache;
  };
  /**
   * Removes items from Set, shifts $indexes of items that remain.
   * Replaces current Set with a new one with new regular $indexes.
   * Maintains min/max indexes and default item size.
   *
   * @param {number[]} toRemove List of indexes to be removed.
   * @param {boolean} fixRight Defines indexes shifting strategy.
   * If false, indexes that are greater than the removed ones will be decreased.
   * If true, indexes that are less than than the removed ones will be increased.
   */
  Cache.prototype.removeItems = function (toRemove, fixRight) {
    var _this = this;
    var items = new Map();
    var min = Infinity, max = -Infinity;
    this.items.forEach(function (item) {
      if (toRemove.some(function (index) { return index === item.$index; })) {
        if (item.size !== void 0) {
          _this.defaultSize.setRemoved(item);
        }
        return;
      }
      var diff = fixRight
        ? toRemove.reduce(function (acc, index) { return acc + (item.$index < index ? 1 : 0); }, 0)
        : toRemove.reduce(function (acc, index) { return acc - (item.$index > index ? 1 : 0); }, 0);
      item.changeIndex(item.$index + diff);
      items.set(item.$index, item);
      min = item.$index < min ? item.$index : min;
      max = item.$index > max ? item.$index : max;
    });
    this.items = items;
    this.minIndex = min;
    this.maxIndex = max;
  };
  /**
   * Destructively updates Set based on subset (before-after) changes.
   * Replaces current Set with a new one with new regular $indexes.
   * Maintains min/max indexes. Maintains default item size on remove only.
   * Inserted and replaced items will be taken into account on Cache.add async calls after render.
   *
   * @param {number[]} before Initial subset of indexes to be replaced by "after". Must be incremental.
   * @param {Item<Data>[]} after Transformed subset that replaces "before". Must be be $index-incremental.
   * Must contain at least 1 $index from "before" or be empty.
   * @param {boolean} fixRight This is to fix right indexes during subset collapsing. Acts only if "after" is empty.
   */
  Cache.prototype.updateSubset = function (before, after, fixRight) {
    var _this = this;
    if (!this.size || !before.length) {
      return;
    }
    var minB = before[0], maxB = before[before.length - 1];
    var leftDiff, rightDiff, found;
    if (after.length) {
      var minA = after[0].$index, maxA = after[after.length - 1].$index;
      leftDiff = minA - minB;
      rightDiff = maxA - maxB;
    }
    else {
      leftDiff = fixRight ? maxB - minB + 1 : 0;
      rightDiff = fixRight ? 0 : minB - maxB - 1;
    }
    var items = new Map();
    this.items.forEach(function (item) {
      if (item.$index < minB) { // items to the left of the subset
        item.changeIndex(item.$index + leftDiff);
        items.set(item.$index, item);
        return;
      }
      else if (item.$index > maxB) { // items to the right of the subset
        item.changeIndex(item.$index + rightDiff);
        items.set(item.$index, item);
        return;
      }
    });
    after.forEach(function (item) {
      return items.set(item.$index, new ItemCache(item, _this.saveData));
    });
    before.forEach(function (index) {
      if (!after.some(function (_a) {
        var $index = _a.$index;
        return index === $index;
      }) && (found = _this.get(index))) {
        _this.defaultSize.setRemoved(found);
      }
    });
    this.minIndex += leftDiff;
    this.maxIndex += rightDiff;
    this.items = items;
  };
  return Cache;
}());
export { Cache };
//# sourceMappingURL=cache.js.map