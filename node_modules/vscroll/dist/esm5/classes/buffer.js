import { __read, __spreadArray } from "tslib";
import { Cache } from './buffer/cache';
import { Reactive } from './reactive';
import { Direction } from '../inputs/index';
var Buffer = /** @class */ (function () {
  function Buffer(settings, onDataChanged, logger) {
    this._items = [];
    this.logger = logger;
    this.changeItems = onDataChanged;
    this.bof = new Reactive(false);
    this.eof = new Reactive(false);
    this.cache = new Cache(settings, logger);
    this.startIndexUser = settings.startIndex;
    this.minIndexUser = settings.minIndex;
    this.maxIndexUser = settings.maxIndex;
    this.reset(true);
  }
  Buffer.prototype.dispose = function () {
    this.bof.dispose();
    this.eof.dispose();
    this._items.forEach(function (item) { return item.dispose(); });
    this._items = [];
  };
  Buffer.prototype.reset = function (force, startIndex) {
    this.items.forEach(function (item) { return item.hide(); });
    this.pristine = true;
    this.items = [];
    this.cache.reset(force);
    this.absMinIndex = this.minIndexUser;
    this.absMaxIndex = this.maxIndexUser;
    this.setCurrentStartIndex(startIndex);
    this.bof.set(false);
    this.eof.set(false);
    this.pristine = false;
  };
  Buffer.prototype.setCurrentStartIndex = function (newStartIndex) {
    var min = this.minIndexUser;
    var max = this.maxIndexUser;
    var start = this.startIndexUser;
    var index = Number(newStartIndex);
    if (Number.isNaN(index)) {
      this.logger.log(function () { return "fallback startIndex to settings.startIndex (" + start + ")"; });
      index = start;
    }
    if (index < min) {
      this.logger.log(function () { return "setting startIndex to settings.minIndex (" + min + ") because " + index + " < " + min; });
      index = min;
    }
    if (index > max) {
      this.logger.log(function () { return "setting startIndex to settings.maxIndex (" + max + ") because " + index + " > " + max; });
      index = max;
    }
    this.startIndex = index;
  };
  Object.defineProperty(Buffer.prototype, "items", {
    get: function () {
      return this._items;
    },
    set: function (items) {
      this._items = items;
      this.changeItems(items);
      if (!this.pristine) {
        this.checkBOF();
        this.checkEOF();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "absMinIndex", {
    get: function () {
      return this._absMinIndex;
    },
    set: function (value) {
      if (this._absMinIndex !== value) {
        this._absMinIndex = Number.isFinite(this._absMaxIndex) && value > this._absMaxIndex ? this._absMaxIndex : value;
      }
      if (!this.pristine) {
        this.checkBOF();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "absMaxIndex", {
    get: function () {
      return this._absMaxIndex;
    },
    set: function (value) {
      if (this._absMaxIndex !== value) {
        this._absMaxIndex = Number.isFinite(this._absMinIndex) && value < this._absMinIndex ? this._absMinIndex : value;
      }
      if (!this.pristine) {
        this.checkEOF();
      }
    },
    enumerable: false,
    configurable: true
  });
  Buffer.prototype.checkBOF = function () {
    // since bof has no setter, need to call checkBOF() on items and absMinIndex change
    var bof = this.items.length
      ? (this.items[0].$index === this.absMinIndex)
      : isFinite(this.absMinIndex);
    this.bof.set(bof);
  };
  Buffer.prototype.checkEOF = function () {
    // since eof has no setter, need to call checkEOF() on items and absMaxIndex change
    var eof = this.items.length
      ? (this.items[this.items.length - 1].$index === this.absMaxIndex)
      : isFinite(this.absMaxIndex);
    this.eof.set(eof);
  };
  Object.defineProperty(Buffer.prototype, "size", {
    get: function () {
      return this._items.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "cacheSize", {
    get: function () {
      return this.cache.size;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "defaultSize", {
    get: function () {
      return this.cache.getDefaultSize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "minIndex", {
    get: function () {
      return isFinite(this.cache.minIndex) ? this.cache.minIndex : this.startIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "maxIndex", {
    get: function () {
      return isFinite(this.cache.maxIndex) ? this.cache.maxIndex : this.startIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "firstIndex", {
    get: function () {
      return this.items.length ? this.items[0].$index : NaN;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "lastIndex", {
    get: function () {
      return this.items.length ? this.items[this.items.length - 1].$index : NaN;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "finiteAbsMinIndex", {
    get: function () {
      return isFinite(this.absMinIndex) ? this.absMinIndex : this.minIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Buffer.prototype, "finiteAbsMaxIndex", {
    get: function () {
      return isFinite(this.absMaxIndex) ? this.absMaxIndex : this.maxIndex;
    },
    enumerable: false,
    configurable: true
  });
  Buffer.prototype.get = function ($index) {
    return this.items.find(function (item) { return item.$index === $index; });
  };
  Buffer.prototype.setItems = function (items) {
    if (!this.items.length) {
      this.items = __spreadArray([], __read(items));
    }
    else if (this.items[0].$index > items[items.length - 1].$index) {
      this.items = __spreadArray(__spreadArray([], __read(items)), __read(this.items));
    }
    else if (items[0].$index > this.items[this.items.length - 1].$index) {
      this.items = __spreadArray(__spreadArray([], __read(this.items)), __read(items));
    }
    else {
      return false;
    }
    return true;
  };
  Buffer.prototype.clip = function () {
    this.items = this.items.filter(function (_a) {
      var toRemove = _a.toRemove;
      return !toRemove;
    });
  };
  Buffer.prototype.append = function (items) {
    this.items = __spreadArray(__spreadArray([], __read(this.items)), __read(items));
  };
  Buffer.prototype.prepend = function (items) {
    this.items = __spreadArray(__spreadArray([], __read(items)), __read(this.items));
  };
  Buffer.prototype.shiftExtremum = function (amount, fixRight) {
    if (!fixRight) {
      this.absMaxIndex += amount;
    }
    else {
      this.absMinIndex -= amount;
      this.startIndex -= amount;
    }
    if (this.startIndex > this.absMaxIndex) {
      this.startIndex = this.absMaxIndex;
    }
    else if (this.startIndex < this.absMinIndex) {
      this.startIndex = this.absMinIndex;
    }
  };
  Buffer.prototype.removeItems = function (indexes, fixRight, virtual) {
    if (virtual === void 0) { virtual = false; }
    var result = [];
    var toRemove = virtual ? indexes : [];
    var length = this.items.length;
    var shifted = false;
    var _loop_1 = function (i) {
      var item = this_1.items[i];
      if (!virtual && indexes.indexOf(item.$index) >= 0) {
        toRemove.push(item.$index);
        return "continue";
      }
      var diff = toRemove.reduce(function (acc, index) { return acc + (fixRight
        ? (item.$index < index ? 1 : 0)
        : (item.$index > index ? -1 : 0)); }, 0);
      shifted = shifted || !!diff;
      item.updateIndex(item.$index + diff);
      if (!virtual) {
        if (fixRight) {
          result.unshift(item);
        }
        else {
          result.push(item);
        }
      }
    };
    var this_1 = this;
    for (var i = fixRight ? length - 1 : 0; fixRight ? i >= 0 : i < length; fixRight ? i-- : i++) {
      _loop_1(i);
    }
    this.shiftExtremum(-toRemove.length, fixRight);
    if (!virtual) {
      this.items = result;
    }
    else if (shifted) {
      this.items = __spreadArray([], __read(this.items));
    }
    this.cache.removeItems(toRemove, fixRight);
  };
  Buffer.prototype.updateItems = function (predicate, generator, indexToTrack, fixRight) {
    var _this = this;
    if (!this.size || Number.isNaN(this.firstIndex)) {
      return NaN;
    }
    var _indexToTrack = indexToTrack;
    var index = fixRight ? this.lastIndex : this.firstIndex;
    var items = [];
    var diff = fixRight ? -1 : 1;
    var initialIndexList = this.items.map(function (_a) {
      var $index = _a.$index;
      return $index;
    });
    (fixRight ? this.items.reverse() : this.items).forEach(function (item) {
      var result = predicate(item);
      // if predicate result is falsy or empty array -> delete
      if (!result || (Array.isArray(result) && !result.length)) {
        item.toRemove = true;
        _indexToTrack += item.$index >= indexToTrack ? (fixRight ? 1 : 0) : (fixRight ? 0 : -1);
        _this.shiftExtremum(-1, fixRight);
        return;
      }
      // if predicate result is truthy but not array -> leave
      if (!Array.isArray(result)) {
        item.updateIndex(index);
        items.push(item);
        index += diff;
        return;
      }
      // if predicate result is non-empty array -> insert/replace
      if (item.$index < indexToTrack) {
        _indexToTrack += fixRight ? 0 : result.length - 1;
      }
      else if (item.$index > indexToTrack) {
        _indexToTrack += fixRight ? 1 - result.length : 0;
      }
      var toRemove = true;
      var newItems = [];
      (fixRight ? __spreadArray([], __read(result)).reverse() : result).forEach(function (data, i) {
        var newItem;
        if (item.data === data) {
          if (indexToTrack === item.$index) {
            _indexToTrack = index + i * diff;
          }
          item.updateIndex(index + i * diff);
          newItem = item;
          toRemove = false; // insert case
        }
        else {
          newItem = generator(index + i * diff, data);
          newItem.toInsert = true;
        }
        newItems.push(newItem);
      });
      item.toRemove = toRemove;
      items.push.apply(items, __spreadArray([], __read(newItems)));
      index += diff * result.length;
      if (result.length > 1) {
        _this.shiftExtremum(result.length - 1, fixRight);
      }
    });
    this.items = fixRight ? items.reverse() : items;
    this.cache.updateSubset(initialIndexList, this.items, fixRight);
    if (this.finiteAbsMinIndex === this.finiteAbsMaxIndex) {
      _indexToTrack = NaN;
    }
    else if (_indexToTrack > this.finiteAbsMaxIndex) {
      _indexToTrack = this.finiteAbsMaxIndex;
    }
    else if (_indexToTrack < this.finiteAbsMinIndex) {
      _indexToTrack = this.finiteAbsMinIndex;
    }
    return _indexToTrack;
  };
  Buffer.prototype.cacheItem = function (item) {
    this.cache.add(item);
  };
  Buffer.prototype.getFirstVisibleItemIndex = function () {
    var length = this.items.length;
    for (var i = 0; i < length; i++) {
      if (!this.items[i].invisible) {
        return i;
      }
    }
    return -1;
  };
  Buffer.prototype.getLastVisibleItemIndex = function () {
    for (var i = this.items.length - 1; i >= 0; i--) {
      if (!this.items[i].invisible) {
        return i;
      }
    }
    return -1;
  };
  Buffer.prototype.getFirstVisibleItem = function () {
    var index = this.getFirstVisibleItemIndex();
    if (index >= 0) {
      return this.items[index];
    }
  };
  Buffer.prototype.getLastVisibleItem = function () {
    var index = this.getLastVisibleItemIndex();
    if (index >= 0) {
      return this.items[index];
    }
  };
  Buffer.prototype.getEdgeVisibleItem = function (direction, opposite) {
    return direction === (!opposite ? Direction.forward : Direction.backward) ?
      this.getLastVisibleItem() : this.getFirstVisibleItem();
  };
  Buffer.prototype.getVisibleItemsCount = function () {
    return this.items.reduce(function (acc, item) { return acc + (item.invisible ? 0 : 1); }, 0);
  };
  Buffer.prototype.getSizeByIndex = function (index) {
    var item = this.cache.get(index);
    return item ? item.size : this.defaultSize;
  };
  Buffer.prototype.checkDefaultSize = function () {
    return this.cache.recalculateDefaultSize();
  };
  Buffer.prototype.getIndexToAppend = function (eof) {
    return (!eof
      ? (this.size ? this.items[this.size - 1].$index : this.maxIndex)
      : this.absMaxIndex) + (this.size ? 1 : 0);
  };
  Buffer.prototype.getIndexToPrepend = function (bof) {
    return (!bof
      ? (this.size ? this.items[0].$index : this.minIndex)
      : this.absMinIndex) - (this.size ? 1 : 0);
  };
  Buffer.prototype.getIndexToAdd = function (eof, prepend) {
    return prepend ? this.getIndexToPrepend(eof) : this.getIndexToAppend(eof);
  };
  return Buffer;
}());
export { Buffer };
//# sourceMappingURL=buffer.js.map