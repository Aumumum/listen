import { __read, __spreadArray } from "tslib";
import { Paddings } from './paddings';
import { Direction } from '../inputs/index';
var Viewport = /** @class */ (function () {
  function Viewport(element, settings, routines, state, logger) {
    this.element = element;
    this.settings = settings;
    this.routines = routines;
    this.state = state;
    this.logger = logger;
    this.disabled = false;
    if (settings.windowViewport) {
      this.hostElement = document.documentElement;
      this.scrollEventReceiver = window;
    }
    else {
      this.hostElement = settings.viewport || this.element.parentElement;
      this.scrollEventReceiver = this.hostElement;
    }
    this.paddings = new Paddings(this.element, this.routines, settings);
    if (settings.windowViewport && 'scrollRestoration' in history) {
      history.scrollRestoration = 'manual';
    }
    if (settings.dismissOverflowAnchor) {
      this.hostElement.style.overflowAnchor = 'none';
    }
  }
  Viewport.prototype.reset = function (startIndex) {
    this.setOffset();
    this.paddings.reset(this.getSize(), startIndex, this.offset);
    this.scrollPosition = this.paddings.backward.size || 0;
    this.state.scrollState.reset();
  };
  Viewport.prototype.setPosition = function (value) {
    var oldPosition = this.scrollPosition;
    if (oldPosition === value) {
      this.logger.log(function () { return ['setting scroll position at', value, '[cancelled]']; });
      return value;
    }
    this.routines.setScrollPosition(this.hostElement, value);
    var position = this.scrollPosition;
    this.logger.log(function () { return __spreadArray([
      'setting scroll position at', position
    ], __read((position !== value ? ["(" + value + ")"] : []))); });
    return position;
  };
  Object.defineProperty(Viewport.prototype, "scrollPosition", {
    get: function () {
      return this.routines.getScrollPosition(this.hostElement);
    },
    set: function (value) {
      this.setPosition(value);
    },
    enumerable: false,
    configurable: true
  });
  Viewport.prototype.disableScrollForOneLoop = function () {
    var _this = this;
    if (this.disabled) {
      return;
    }
    var style = this.hostElement.style;
    if (style.overflowY === 'hidden') {
      return;
    }
    this.disabled = true;
    var overflow = style.overflowY;
    setTimeout(function () {
      _this.disabled = false;
      style.overflowY = overflow;
    });
    style.overflowY = 'hidden';
  };
  Viewport.prototype.getSize = function () {
    return this.routines.getSize(this.hostElement, true);
  };
  Viewport.prototype.getScrollableSize = function () {
    return this.routines.getSize(this.element);
  };
  Viewport.prototype.getBufferPadding = function () {
    return this.getSize() * this.settings.padding;
  };
  Viewport.prototype.getEdge = function (direction) {
    return this.routines.getEdge(this.hostElement, direction, true);
  };
  Viewport.prototype.setOffset = function () {
    this.offset = this.routines.getOffset(this.element);
    if (!this.settings.windowViewport) {
      this.offset -= this.routines.getOffset(this.hostElement);
    }
  };
  Viewport.prototype.getEdgeVisibleItem = function (items, direction) {
    var bwd = direction === Direction.backward;
    var opposite = bwd ? Direction.forward : Direction.backward;
    var viewportEdge = this.getEdge(direction);
    var item, diff = 0;
    for (var i = bwd ? 0 : items.length - 1; bwd ? i <= items.length - 1 : i >= 0; i += bwd ? 1 : -1) {
      var itemEdge = this.routines.getEdge(items[i].element, opposite);
      diff = itemEdge - viewportEdge;
      if (bwd && diff > 0 || !bwd && diff < 0) {
        item = items[i];
        break;
      }
    }
    return { item: item, index: item ? item.$index : NaN, diff: diff };
  };
  return Viewport;
}());
export { Viewport };
//# sourceMappingURL=viewport.js.map