import { __read } from "tslib";
import { SETTINGS, DEV_SETTINGS, validate, validateOne, VALIDATORS } from '../inputs/index';
var Settings = /** @class */ (function () {
  function Settings(settings, devSettings, instanceIndex) {
    this.parseInput(settings, SETTINGS);
    this.parseInput(devSettings, DEV_SETTINGS);
    this.instanceIndex = instanceIndex;
    this.initializeDelay = this.getInitializeDelay();
    this.viewport = this.getViewport();
    // todo: min/max indexes must be ignored if infinite mode is enabled ??
  }
  Settings.prototype.parseInput = function (input, props) {
    var _this = this;
    var result = validate(input, props);
    if (!result.isValid) {
      throw new Error('Invalid settings');
    }
    Object.entries(result.params).forEach(function (_a) {
      var _b;
      var _c = __read(_a, 2), key = _c[0], par = _c[1];
      return Object.assign(_this, (_b = {}, _b[key] = par.value, _b));
    });
  };
  Settings.prototype.getInitializeDelay = function () {
    var result = 0;
    if (this.windowViewport && this.initWindowDelay && !('scrollRestoration' in history)) {
      result = this.initWindowDelay;
    }
    if (this.initDelay > 0) {
      result = Math.max(result, this.initDelay);
    }
    return result;
  };
  Settings.prototype.getViewport = function () {
    if (typeof this.viewportElement !== 'function') {
      return this.viewportElement;
    }
    var value = this.viewportElement();
    var result = validateOne({ value: value }, 'value', { validators: [VALIDATORS.ELEMENT] });
    if (!result.isValid) {
      return null; // fallback to default (null) if Function didn't return HTML element synchronously
    }
    return result.value;
  };
  return Settings;
}());
export { Settings };
//# sourceMappingURL=settings.js.map