import { __assign } from "tslib";
import { AdapterPropName, AdapterPropType, getDefaultAdapterProps, reactiveConfigStorage } from './props';
import core from '../../version';
var instanceCount = 0;
var AdapterContext = /** @class */ (function () {
  function AdapterContext(config) {
    var _this = this;
    var mock = config.mock, reactive = config.reactive;
    var id = ++instanceCount;
    var conf = { configurable: true };
    var reactivePropsStore = {};
    // set up permanent props
    Object.defineProperty(this, AdapterPropName.id, __assign({ get: function () { return id; } }, conf));
    Object.defineProperty(this, AdapterPropName.mock, __assign({ get: function () { return mock; } }, conf));
    Object.defineProperty(this, AdapterPropName.augmented, __assign({ get: function () { return false; } }, conf));
    Object.defineProperty(this, AdapterPropName.version, __assign({ get: function () { return core.version; } }, conf));
    // set up default props, they will be reassigned during the Adapter instantiation
    getDefaultAdapterProps()
      .filter(function (_a) {
      var permanent = _a.permanent;
      return !permanent;
    })
      .forEach(function (_a) {
      var name = _a.name, value = _a.value, type = _a.type;
      // reactive props might be reconfigured by the vscroll consumer
      if (reactive && type === AdapterPropType.Reactive) {
        var react = reactive[name];
        if (react) {
          // here we have a configured reactive property that came from the outer config
          // this prop must be exposed via Adapter, but at the same time we need to
          // persist the original default value as it will be used by the Adapter internally
          reactivePropsStore[name] = __assign(__assign({}, react), { default: value // persisting the default native Reactive prop
           });
          value = react.source; // exposing the configured prop instead of the default one
        }
      }
      Object.defineProperty(_this, name, __assign({ get: function () { return value; } }, conf));
    });
    if (reactive) { // save both configured and default reactive props in the store
      reactiveConfigStorage.set(id, reactivePropsStore);
    }
  }
  return AdapterContext;
}());
export { AdapterContext };
//# sourceMappingURL=context.js.map