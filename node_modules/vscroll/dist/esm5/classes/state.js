import { __assign } from "tslib";
import { WorkflowCycleModel } from './state/cycle';
import { FetchModel } from './state/fetch';
import { ClipModel } from './state/clip';
import { RenderModel } from './state/render';
import { ScrollState } from './state/scroll';
var State = /** @class */ (function () {
  function State(packageInfo, settings, state) {
    this.packageInfo = packageInfo;
    this.settings = settings;
    this.initTime = Number(new Date());
    this.cycle = new WorkflowCycleModel(this.settings.instanceIndex, state ? state.cycle : void 0);
    this.fetch = new FetchModel();
    this.clip = new ClipModel();
    this.render = new RenderModel();
    this.scrollState = new ScrollState();
  }
  Object.defineProperty(State.prototype, "time", {
    get: function () {
      return Number(new Date()) - this.initTime;
    },
    enumerable: false,
    configurable: true
  });
  State.prototype.endInnerLoop = function () {
    var _a = this, fetch = _a.fetch, render = _a.render, cycle = _a.cycle;
    if (fetch.cancel) {
      fetch.cancel();
      fetch.cancel = null;
    }
    if (render.renderTimer) {
      clearTimeout(render.renderTimer);
      render.renderTimer = null;
    }
    cycle.innerLoop.done();
  };
  State.prototype.startInnerLoop = function () {
    var _a = this, cycle = _a.cycle, scroll = _a.scrollState, fetch = _a.fetch, render = _a.render, clip = _a.clip;
    cycle.innerLoop.start();
    scroll.positionBeforeAsync = null;
    if (!fetch.simulate) {
      fetch.reset();
    }
    clip.reset(clip.force);
    render.reset();
    return __assign({}, (cycle.innerLoop.first ? {
      process: cycle.initiator,
      doRender: fetch.simulate && fetch.items.length > 0
    } : {}));
  };
  State.prototype.dispose = function () {
    this.cycle.dispose();
    this.endInnerLoop();
    this.scrollState.cleanupTimers();
  };
  return State;
}());
export { State };
//# sourceMappingURL=state.js.map