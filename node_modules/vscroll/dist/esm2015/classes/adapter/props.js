import { Reactive } from '../reactive';
export var AdapterPropName;
(function (AdapterPropName) {
  AdapterPropName["id"] = "id";
  AdapterPropName["mock"] = "mock";
  AdapterPropName["augmented"] = "augmented";
  AdapterPropName["version"] = "version";
  AdapterPropName["init"] = "init";
  AdapterPropName["init$"] = "init$";
  AdapterPropName["packageInfo"] = "packageInfo";
  AdapterPropName["itemsCount"] = "itemsCount";
  AdapterPropName["bufferInfo"] = "bufferInfo";
  AdapterPropName["isLoading"] = "isLoading";
  AdapterPropName["isLoading$"] = "isLoading$";
  AdapterPropName["loopPending"] = "loopPending";
  AdapterPropName["loopPending$"] = "loopPending$";
  AdapterPropName["firstVisible"] = "firstVisible";
  AdapterPropName["firstVisible$"] = "firstVisible$";
  AdapterPropName["lastVisible"] = "lastVisible";
  AdapterPropName["lastVisible$"] = "lastVisible$";
  AdapterPropName["bof"] = "bof";
  AdapterPropName["bof$"] = "bof$";
  AdapterPropName["eof"] = "eof";
  AdapterPropName["eof$"] = "eof$";
  AdapterPropName["reset"] = "reset";
  AdapterPropName["reload"] = "reload";
  AdapterPropName["append"] = "append";
  AdapterPropName["prepend"] = "prepend";
  AdapterPropName["check"] = "check";
  AdapterPropName["remove"] = "remove";
  AdapterPropName["clip"] = "clip";
  AdapterPropName["insert"] = "insert";
  AdapterPropName["replace"] = "replace";
  AdapterPropName["update"] = "update";
  AdapterPropName["fix"] = "fix";
  AdapterPropName["relax"] = "relax";
  AdapterPropName["showLog"] = "showLog";
})(AdapterPropName || (AdapterPropName = {}));
export var AdapterPropType;
(function (AdapterPropType) {
  AdapterPropType[AdapterPropType["Scalar"] = 0] = "Scalar";
  AdapterPropType[AdapterPropType["Reactive"] = 1] = "Reactive";
  AdapterPropType[AdapterPropType["WorkflowRunner"] = 2] = "WorkflowRunner";
  AdapterPropType[AdapterPropType["Function"] = 3] = "Function";
})(AdapterPropType || (AdapterPropType = {}));
const Name = AdapterPropName;
const Type = AdapterPropType;
const noop = () => null;
export const methodPreResult = {
  immediate: true,
  success: true,
  details: 'Adapter is not initialized'
};
const noopWF = () => Promise.resolve(methodPreResult);
const emptyPackageInfo = {
  core: {
    name: '',
    version: ''
  },
  consumer: {
    name: '',
    version: ''
  }
};
const bufferInfoDefault = {
  firstIndex: NaN,
  lastIndex: NaN,
  minIndex: NaN,
  maxIndex: NaN,
  absMinIndex: -Infinity,
  absMaxIndex: +Infinity,
  defaultSize: NaN,
};
export const EMPTY_ITEM = {
  data: {},
  element: {}
};
export const getDefaultAdapterProps = () => [
  {
    type: Type.Scalar,
    name: Name.id,
    value: 0,
    permanent: true
  },
  {
    type: Type.Scalar,
    name: Name.mock,
    value: true,
    permanent: true
  },
  {
    type: Type.Scalar,
    name: Name.augmented,
    value: false,
    permanent: true
  },
  {
    type: Type.Scalar,
    name: Name.version,
    value: '',
    permanent: true
  },
  {
    type: Type.Scalar,
    name: Name.init,
    value: false,
    reactive: Name.init$
  },
  {
    type: Type.Scalar,
    name: Name.packageInfo,
    value: emptyPackageInfo,
    onDemand: true
  },
  {
    type: Type.Scalar,
    name: Name.itemsCount,
    value: 0,
    onDemand: true
  },
  {
    type: Type.Scalar,
    name: Name.bufferInfo,
    value: bufferInfoDefault,
    onDemand: true
  },
  {
    type: Type.Scalar,
    name: Name.isLoading,
    value: false,
    reactive: Name.isLoading$
  },
  {
    type: Type.Scalar,
    name: Name.loopPending,
    value: false,
    reactive: Name.loopPending$
  },
  {
    type: Type.Scalar,
    name: Name.firstVisible,
    value: EMPTY_ITEM,
    reactive: Name.firstVisible$,
    wanted: true
  },
  {
    type: Type.Scalar,
    name: Name.lastVisible,
    value: EMPTY_ITEM,
    reactive: Name.lastVisible$,
    wanted: true
  },
  {
    type: Type.Scalar,
    name: Name.bof,
    value: false,
    reactive: Name.bof$
  },
  {
    type: Type.Scalar,
    name: Name.eof,
    value: false,
    reactive: Name.eof$
  },
  {
    type: Type.WorkflowRunner,
    name: Name.reset,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.reload,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.append,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.prepend,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.check,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.remove,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.clip,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.insert,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.replace,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.update,
    value: noopWF
  },
  {
    type: Type.WorkflowRunner,
    name: Name.fix,
    value: noopWF
  },
  {
    type: Type.Function,
    name: Name.relax,
    value: noop
  },
  {
    type: Type.Function,
    name: Name.showLog,
    value: noop
  },
  {
    type: Type.Reactive,
    name: Name.init$,
    value: new Reactive()
  },
  {
    type: Type.Reactive,
    name: Name.isLoading$,
    value: new Reactive()
  },
  {
    type: Type.Reactive,
    name: Name.loopPending$,
    value: new Reactive()
  },
  {
    type: Type.Reactive,
    name: Name.firstVisible$,
    value: new Reactive(EMPTY_ITEM, { emitOnSubscribe: true })
  },
  {
    type: Type.Reactive,
    name: Name.lastVisible$,
    value: new Reactive(EMPTY_ITEM, { emitOnSubscribe: true })
  },
  {
    type: Type.Reactive,
    name: Name.bof$,
    value: new Reactive()
  },
  {
    type: Type.Reactive,
    name: Name.eof$,
    value: new Reactive()
  }
];
export const reactiveConfigStorage = new Map();
//# sourceMappingURL=props.js.map