{"version":3,"file":"context.js","sourceRoot":"","sources":["../../../../src/classes/adapter/context.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,eAAe,EAAE,sBAAsB,EAAE,qBAAqB,EAAE,MAAM,SAAS,CAAC;AAC1G,OAAO,IAAI,MAAM,eAAe,CAAC;AAIjC,IAAI,aAAa,GAAG,CAAC,CAAC;AAEtB,MAAM,OAAO,cAAc;IAEzB,YAAY,MAAsB;QAChC,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,MAAM,CAAC;QAClC,MAAM,EAAE,GAAG,EAAE,aAAa,CAAC;QAC3B,MAAM,IAAI,GAAG,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC;QACpC,MAAM,kBAAkB,GAAwB,EAAE,CAAC;QAEnD,yBAAyB;QACzB,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,eAAe,CAAC,EAAE,kBAAI,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,IAAK,IAAI,EAAG,CAAC;QAC5E,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,kBAAI,GAAG,EAAE,GAAG,EAAE,CAAC,IAAI,IAAK,IAAI,EAAG,CAAC;QAChF,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,eAAe,CAAC,SAAS,kBAAI,GAAG,EAAE,GAAG,EAAE,CAAC,KAAK,IAAK,IAAI,EAAG,CAAC;QACtF,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,eAAe,CAAC,OAAO,kBAAI,GAAG,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,IAAK,IAAI,EAAG,CAAC;QAE3F,iFAAiF;QACjF,sBAAsB,EAAE;aACrB,MAAM,CAAC,CAAC,EAAE,SAAS,EAAE,EAAE,EAAE,CAAC,CAAC,SAAS,CAAC;aACrC,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,EAAE;YAEjC,+DAA+D;YAC/D,IAAI,QAAQ,IAAI,IAAI,KAAK,eAAe,CAAC,QAAQ,EAAE;gBACjD,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;gBAC7B,IAAI,KAAK,EAAE;oBACT,8EAA8E;oBAC9E,yEAAyE;oBACzE,kFAAkF;oBAClF,kBAAkB,CAAC,IAAI,CAAC,mCACnB,KAAK,KACR,OAAO,EAAE,KAA0B,CAAC,8CAA8C;uBACnF,CAAC;oBACF,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,0DAA0D;iBACjF;aACF;YAED,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,IAAI,kBAC9B,GAAG,EAAE,GAAG,EAAE,CAAC,KAAK,IACb,IAAI,EACP,CAAC;QACL,CAAC,CAAC,CAAC;QAEL,IAAI,QAAQ,EAAE,EAAE,+DAA+D;YAC7E,qBAAqB,CAAC,GAAG,CAAC,EAAE,EAAE,kBAAkB,CAAC,CAAC;SACnD;IACH,CAAC;CACF","sourcesContent":["import { AdapterPropName, AdapterPropType, getDefaultAdapterProps, reactiveConfigStorage } from './props';\nimport core from '../../version';\nimport { Reactive } from '../reactive';\nimport { IReactivePropsStore, IAdapterConfig } from '../../interfaces/index';\n\nlet instanceCount = 0;\n\nexport class AdapterContext {\n\n  constructor(config: IAdapterConfig) {\n    const { mock, reactive } = config;\n    const id = ++instanceCount;\n    const conf = { configurable: true };\n    const reactivePropsStore: IReactivePropsStore = {};\n\n    // set up permanent props\n    Object.defineProperty(this, AdapterPropName.id, { get: () => id, ...conf });\n    Object.defineProperty(this, AdapterPropName.mock, { get: () => mock, ...conf });\n    Object.defineProperty(this, AdapterPropName.augmented, { get: () => false, ...conf });\n    Object.defineProperty(this, AdapterPropName.version, { get: () => core.version, ...conf });\n\n    // set up default props, they will be reassigned during the Adapter instantiation\n    getDefaultAdapterProps()\n      .filter(({ permanent }) => !permanent)\n      .forEach(({ name, value, type }) => {\n\n        // reactive props might be reconfigured by the vscroll consumer\n        if (reactive && type === AdapterPropType.Reactive) {\n          const react = reactive[name];\n          if (react) {\n            // here we have a configured reactive property that came from the outer config\n            // this prop must be exposed via Adapter, but at the same time we need to\n            // persist the original default value as it will be used by the Adapter internally\n            reactivePropsStore[name] = {\n              ...react,\n              default: value as Reactive<unknown> // persisting the default native Reactive prop\n            };\n            value = react.source; // exposing the configured prop instead of the default one\n          }\n        }\n\n        Object.defineProperty(this, name, {\n          get: () => value,\n          ...conf\n        });\n      });\n\n    if (reactive) { // save both configured and default reactive props in the store\n      reactiveConfigStorage.set(id, reactivePropsStore);\n    }\n  }\n}\n"]}