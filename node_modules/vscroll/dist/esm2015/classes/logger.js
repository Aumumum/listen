import { CommonProcess, AdapterProcess, ProcessStatus as Status } from '../processes/index';
export class Logger {
  constructor(scroller, packageInfo, adapter) {
    this.logs = [];
    this.logAdapterMethod = (methodName, args, add) => {
      if (!this.debug) {
        return;
      }
      const params = (args === void 0 ? [] : (Array.isArray(args) ? args : [args]))
        .map((arg) => {
        if (typeof arg === 'function') {
          return 'func';
        }
        else if (typeof arg !== 'object' || !arg) {
          return arg;
        }
        else if (Array.isArray(arg)) {
          return `[of ${arg.length}]`;
        }
        return '{ ' + Object.keys(arg).join(', ') + ' }';
      })
        .join(', ');
      this.log(`adapter: ${methodName}(${params || ''})${add || ''}`);
    };
    const { settings } = scroller;
    this.debug = settings.debug;
    this.immediateLog = settings.immediateLog;
    this.logTime = settings.logTime;
    this.getTime = () => scroller.state && ` // time: ${scroller.state.time}`;
    this.getStat = () => {
      const { buffer, viewport } = scroller;
      const first = buffer.getFirstVisibleItem();
      const last = buffer.getLastVisibleItem();
      return 'pos: ' + viewport.scrollPosition + ', ' +
        'size: ' + viewport.getScrollableSize() + ', ' +
        'bwd_p: ' + viewport.paddings.backward.size + ', ' +
        'fwd_p: ' + viewport.paddings.forward.size + ', ' +
        'default: ' + (buffer.defaultSize || 'no') + ', ' +
        'items: ' + buffer.getVisibleItemsCount() + ', ' +
        'range: ' + (first && last ? `[${first.$index}..${last.$index}]` : 'no');
    };
    this.getFetchRange = () => {
      const { first: { index: first }, last: { index: last } } = scroller.state.fetch;
      return !Number.isNaN(first) && !Number.isNaN(last)
        ? `[${first}..${last}]`
        : 'no';
    };
    this.getLoopId = () => scroller.state.cycle.loopId;
    this.getLoopIdNext = () => scroller.state.cycle.loopIdNext;
    this.getWorkflowCycleData = () => `${settings.instanceIndex}-${scroller.state.cycle.count}`;
    this.getScrollPosition = (element) => scroller.routines.getScrollPosition(element);
    this.log(() => 'vscroll Workflow has been started, ' +
      `core: ${packageInfo.core.name} v${packageInfo.core.version}, ` +
      `consumer: ${packageInfo.consumer.name} v${packageInfo.consumer.version}, ` +
      `workflow instance: ${settings.instanceIndex}, adapter ` +
      (!adapter ? 'is not instantiated' : `instance: ${adapter.id}`));
  }
  object(str, obj, stringify) {
    this.log(() => [
      str,
      stringify
        ? JSON.stringify(obj, (k, v) => {
          if (Number.isNaN(v)) {
            return 'NaN';
          }
          if (v === Infinity) {
            return 'Infinity';
          }
          if (v === -Infinity) {
            return '-Infinity';
          }
          if (v instanceof Element) {
            return 'HTMLElement';
          }
          if (v instanceof HTMLDocument) {
            return 'HTMLDocument';
          }
          if (typeof v === 'function') {
            return 'Function';
          }
          return v;
        })
          .replace(/"/g, '')
          .replace(/(\{|:|,)/g, '$1 ')
          .replace(/(\})/g, ' $1')
        : obj
    ]);
  }
  stat(str) {
    if (this.debug) {
      const logStyles = [
        'color: #888; border: dashed #888 0; border-bottom-width: 0px',
        'color: #000; border-width: 0'
      ];
      this.log(() => ['%cstat' + (str ? ` ${str}` : '') + ',%c ' + this.getStat(), ...logStyles]);
    }
  }
  fetch(str) {
    if (this.debug) {
      const _text = 'fetch interval' + (str ? ` ${str}` : '');
      const logStyles = ['color: #888', 'color: #000'];
      this.log(() => [`%c${_text}: %c${this.getFetchRange()}`, ...logStyles]);
    }
  }
  prepareForLog(data) {
    return data instanceof Event && data.target
      ? this.getScrollPosition(data.target)
      : data;
  }
  logProcess(data) {
    if (!this.debug) {
      return;
    }
    const { process, status, payload } = data;
    // inner loop start-end log
    const loopLog = [];
    if (process === CommonProcess.init && status === Status.next) {
      loopLog.push(`%c---=== loop ${this.getLoopIdNext()} start`);
    }
    else if (process === CommonProcess.end) {
      loopLog.push(`%c---=== loop ${this.getLoopId()} done`);
      const parent = payload && payload.process;
      if (status === Status.next && (parent !== AdapterProcess.reset && parent !== AdapterProcess.reload)) {
        loopLog[0] += `, loop ${this.getLoopIdNext()} start`;
      }
    }
    if (loopLog.length) {
      this.log(() => [...loopLog, 'color: #006600;']);
    }
  }
  logCycle(start = true) {
    const logData = this.getWorkflowCycleData();
    const border = start ? '1px 0 0 1px' : '0 0 1px 1px';
    const logStyles = `color: #0000aa; border: solid #555 1px; border-width: ${border}; margin-left: -2px`;
    this.log(() => [`%c   ~~~ WF Cycle ${logData} ${start ? 'STARTED' : 'FINALIZED'} ~~~  `, logStyles]);
  }
  logError(str) {
    if (this.debug) {
      const logStyles = ['color: #a00;', 'color: #000'];
      this.log(() => ['error:%c' + (str ? ` ${str}` : '') + `%c (loop ${this.getLoopIdNext()})`, ...logStyles]);
    }
  }
  log(...args) {
    if (this.debug) {
      if (typeof args[0] === 'function') {
        args = args[0]();
        if (!Array.isArray(args)) {
          args = [args];
        }
      }
      if (args.every(item => item === void 0)) {
        return;
      }
      if (this.logTime) {
        args = [...args, this.getTime()];
      }
      args = args.map((arg) => this.prepareForLog(arg));
      if (this.immediateLog) {
        console.log.apply(this, args);
      }
      else {
        this.logs.push(args);
      }
    }
  }
  // logNow(...args: any[]) {
  //   const immediateLog = this.immediateLog;
  //   const debug = this.debug;
  //   (this as any).debug = true;
  //   (this as any).immediateLog = true;
  //   this.log.apply(this, args);
  //   (this as any).debug = debug;
  //   (this as any).immediateLog = immediateLog;
  // }
  logForce(...args) {
    if (this.debug) {
      if (!this.immediateLog && this.logs.length) {
        this.logs.forEach(logArgs => console.log.apply(this, logArgs));
        this.logs = [];
      }
      if (args.length) {
        console.log.apply(this, args);
      }
    }
  }
}
//# sourceMappingURL=logger.js.map