{"version":3,"file":"reactive.js","sourceRoot":"","sources":["../../../src/classes/reactive.ts"],"names":[],"mappings":"AAaA,MAAM,OAAO,QAAQ;IAQnB,YAAY,KAAS,EAAE,OAAiB;QACtC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;QACZ,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;YACpB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;YACnB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;SAC3B;QACD,IAAI,CAAC,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;QAC7B,IAAI,CAAC,aAAa,GAAG,IAAI,GAAG,EAAE,CAAC;IACjC,CAAC;IAED,GAAG,CAAC,KAAQ;QACV,IAAI,IAAI,CAAC,KAAK,KAAK,KAAK,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE;YACnD,OAAO;SACR;QACD,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,KAAK,MAAM,CAAC,EAAE,GAAG,CAAC,IAAI,IAAI,CAAC,aAAa,EAAE;YACxC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAChB,IAAI,IAAI,CAAC,KAAK,KAAK,KAAK,EAAE;gBACxB,MAAM;aACP;SACF;IACH,CAAC;IAED,GAAG;QACD,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED,EAAE,CAAC,IAAW;QACZ,MAAM,EAAE,GAAG,IAAI,CAAC,EAAE,EAAE,CAAC;QACrB,MAAM,YAAY,GAAoB;YACpC,IAAI,EAAE,IAAI;YACV,GAAG,EAAE,GAAG,EAAE;gBACR,YAAY,CAAC,IAAI,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC;gBAC/B,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YAChC,CAAC;SACF,CAAC;QACF,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,EAAE,EAAE,YAAY,CAAC,CAAC;QACzC,IAAI,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE;YAChC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SAC/B;QACD,OAAO,GAAG,EAAE,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC;IAClC,CAAC;IAED,IAAI,CAAC,IAAW;QACd,MAAM,GAAG,GAAG,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;YACtB,GAAG,EAAE,CAAC;YACN,IAAI,CAAC,CAAC,CAAC,CAAC;QACV,CAAC,CAAC,CAAC;QACH,OAAO,GAAG,CAAC;IACb,CAAC;IAED,KAAK;QACH,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAC9B,CAAC;IAED,OAAO;QACL,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;IAC/C,CAAC;CACF","sourcesContent":["type On<T> = (value: T) => void;\ntype Off = () => void;\n\ninterface Subscription<T> {\n  emit: On<T>;\n  off: Off;\n}\n\ninterface Options {\n  emitOnSubscribe?: boolean; // if set, emit right on subscribe (like rxjs BehaviorSubject)\n  emitEqual?: boolean; // if set, emit when new value is equal to the old one\n}\n\nexport class Reactive<T> {\n\n  private initialValue: T;\n  private value: T;\n  private id: number;\n  private options: Options;\n  private subscriptions: Map<number, Subscription<T>>;\n\n  constructor(value?: T, options?: Options) {\n    this.id = 0;\n    if (value !== void 0) {\n      this.value = value;\n      this.initialValue = value;\n    }\n    this.options = options || {};\n    this.subscriptions = new Map();\n  }\n\n  set(value: T): void {\n    if (this.value === value && !this.options.emitEqual) {\n      return;\n    }\n    this.value = value;\n    for (const [, sub] of this.subscriptions) {\n      sub.emit(value);\n      if (this.value !== value) {\n        break;\n      }\n    }\n  }\n\n  get(): T {\n    return this.value;\n  }\n\n  on(func: On<T>): Off {\n    const id = this.id++;\n    const subscription: Subscription<T> = {\n      emit: func,\n      off: () => {\n        subscription.emit = () => null;\n        this.subscriptions.delete(id);\n      }\n    };\n    this.subscriptions.set(id, subscription);\n    if (this.options.emitOnSubscribe) {\n      subscription.emit(this.value);\n    }\n    return () => subscription.off();\n  }\n\n  once(func: On<T>): Off {\n    const off = this.on(v => {\n      off();\n      func(v);\n    });\n    return off;\n  }\n\n  reset(): void {\n    this.set(this.initialValue);\n  }\n\n  dispose(): void {\n    this.subscriptions.forEach(sub => sub.off());\n  }\n}\n"]}