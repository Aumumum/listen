{"version":3,"file":"settings.js","sourceRoot":"","sources":["../../../src/classes/settings.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,YAAY,EAAE,QAAQ,EAAE,WAAW,EAAE,UAAU,EAAgB,MAAM,iBAAiB,CAAC;AAG1G,MAAM,OAAO,QAAQ;IAoCnB,YACE,QAAqC,EAAE,WAAqC,EAAE,aAAqB;QAEnG,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACpC,IAAI,CAAC,UAAU,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;QAC3C,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;QACjD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;QACnC,uEAAuE;IACzE,CAAC;IAED,UAAU,CAAC,KAAiD,EAAE,KAAgC;QAC5F,MAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QACtC,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;YACnB,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;SACrC;QACD,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,EAAE,CACnD,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,KAAK,EAAE,CAAC,CAC1C,CAAC;IACJ,CAAC;IAED,kBAAkB;QAChB,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,eAAe,IAAI,CAAC,CAAC,mBAAmB,IAAI,OAAO,CAAC,EAAE;YACpF,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC;SAC/B;QACD,IAAI,IAAI,CAAC,SAAS,GAAG,CAAC,EAAE;YACtB,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;SAC3C;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,WAAW;QACT,IAAI,OAAO,IAAI,CAAC,eAAe,KAAK,UAAU,EAAE;YAC9C,OAAO,IAAI,CAAC,eAAe,CAAC;SAC7B;QACD,MAAM,KAAK,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC;QACrC,MAAM,MAAM,GAAG,WAAW,CAAC,EAAE,KAAK,EAAE,EAAE,OAAO,EAAE,EAAE,UAAU,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QACrF,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;YACnB,OAAO,IAAI,CAAC,CAAC,kFAAkF;SAChG;QACD,OAAO,MAAM,CAAC,KAAoB,CAAC;IACrC,CAAC;CACF","sourcesContent":["import { SETTINGS, DEV_SETTINGS, validate, validateOne, VALIDATORS, SizeStrategy } from '../inputs/index';\nimport { Settings as ISettings, DevSettings as IDevSettings, ICommonProps, ItemsProcessor } from '../interfaces/index';\n\nexport class Settings<Data = unknown> implements ISettings, IDevSettings {\n\n  // user settings\n  adapter: boolean;\n  startIndex: number;\n  minIndex: number;\n  maxIndex: number;\n  itemSize: number;\n  bufferSize: number;\n  padding: number;\n  infinite: boolean;\n  horizontal: boolean;\n  windowViewport: boolean;\n  viewportElement: HTMLElement | (() => void) | null;\n  inverse: boolean; // if true, bwd padding element will have a priority when filling the viewport (if lack of items)\n  onBeforeClip: ItemsProcessor | null; // if set, it will be run before clipping items from Buffer after they are hidden\n  sizeStrategy: SizeStrategy; // \"average\" | \"frequent\", determines behavior of unknown items\n\n  // development settings\n  debug: boolean; // if true, logging is enabled; need to turn off when release\n  immediateLog: boolean; // if false, logging is not immediate and could be done via Workflow.logForce call\n  logTime: boolean; // if true, time differences will be logged\n  logProcessRun: boolean; // if true, process fire/run info will be logged\n  throttle: number; // if > 0, scroll event handling is throttled (ms)\n  initDelay: number; // if set, the Workflow initialization will be postponed (ms)\n  initWindowDelay: number; // if set and the entire window is scrollable, the Workflow init will be postponed (ms)\n  cacheData: boolean; // if true, item's data will be cached along with item's size and index\n  cacheOnReload: boolean; // if true, cache will not be flushed on reload\n  changeOverflow: boolean; // if true, scroll will be disabled per each item's average size change\n  dismissOverflowAnchor: boolean; // if true, the viewport will receive \"overflowAnchor: none\"\n\n  // internal settings, managed by scroller itself\n  instanceIndex: number;\n  initializeDelay: number;\n  viewport: HTMLElement | null;\n\n  constructor(\n    settings: ISettings<Data> | undefined, devSettings: IDevSettings | undefined, instanceIndex: number\n  ) {\n    this.parseInput(settings, SETTINGS);\n    this.parseInput(devSettings, DEV_SETTINGS);\n    this.instanceIndex = instanceIndex;\n    this.initializeDelay = this.getInitializeDelay();\n    this.viewport = this.getViewport();\n    // todo: min/max indexes must be ignored if infinite mode is enabled ??\n  }\n\n  parseInput(input: ISettings<Data> | IDevSettings | undefined, props: ICommonProps<PropertyKey>): void {\n    const result = validate(input, props);\n    if (!result.isValid) {\n      throw new Error('Invalid settings');\n    }\n    Object.entries(result.params).forEach(([key, par]) =>\n      Object.assign(this, { [key]: par.value })\n    );\n  }\n\n  getInitializeDelay(): number {\n    let result = 0;\n    if (this.windowViewport && this.initWindowDelay && !('scrollRestoration' in history)) {\n      result = this.initWindowDelay;\n    }\n    if (this.initDelay > 0) {\n      result = Math.max(result, this.initDelay);\n    }\n    return result;\n  }\n\n  getViewport(): HTMLElement | null {\n    if (typeof this.viewportElement !== 'function') {\n      return this.viewportElement;\n    }\n    const value = this.viewportElement();\n    const result = validateOne({ value }, 'value', { validators: [VALIDATORS.ELEMENT] });\n    if (!result.isValid) {\n      return null; // fallback to default (null) if Function didn't return HTML element synchronously\n    }\n    return result.value as HTMLElement;\n  }\n}\n"]}