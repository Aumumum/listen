import { Direction } from '../../inputs/index';
class Positions {
  constructor() {
    this.reset();
  }
  reset() {
    this.startDelta = 0;
    this.before = 0;
  }
}
class First {
  constructor() {
    this.reset();
  }
  reset() {
    this.index = NaN;
    this.indexBuffer = NaN;
    this.position = NaN;
  }
}
class Last {
  constructor() {
    this.reset();
  }
  reset() {
    this.index = NaN;
    this.indexBuffer = NaN;
  }
}
export class FetchModel {
  constructor() {
    this.callCount = 0;
    this.positions = new Positions();
    this.first = new First();
    this.last = new Last();
    this.reset();
  }
  reset() {
    this._newItemsData = null;
    this.items = [];
    this.positions.reset();
    this.first.reset();
    this.last.reset();
    this.hasAnotherPack = false;
    this.firstVisibleIndex = NaN;
    this.firstVisibleItemDelta = NaN;
    this.negativeSize = 0;
    this.direction = null;
    this.cancel = null;
    this.simulate = false;
    this.isPrepend = false;
    this.isCheck = false;
    this.doRemove = false;
  }
  get newItemsData() {
    return this._newItemsData;
  }
  set newItemsData(items) {
    this._newItemsData = items;
    if (items && items.length) {
      this.callCount++;
    }
  }
  get shouldFetch() {
    return !!this.count;
  }
  get hasNewItems() {
    return !!((this._newItemsData && this._newItemsData.length));
  }
  get index() {
    return this.first.index;
  }
  get count() {
    return !isNaN(this.first.index) && !isNaN(this.last.index) ? this.last.index - this.first.index + 1 : 0;
  }
  startSimulate(items) {
    this.simulate = true;
    this._newItemsData = items.map(item => item.data);
    this.items = items;
    this.hasAnotherPack = false;
    this.negativeSize = 0;
  }
  stopSimulate() {
    this.simulate = false;
    this.isPrepend = false;
    this.isCheck = false;
    this.doRemove = false;
  }
  append(items) {
    this.startSimulate(items);
    this.last.index = items[items.length - 1].$index;
    this.first.index = items[0].$index;
    this.direction = Direction.forward;
  }
  prepend(items) {
    this.startSimulate(items);
    this.last.index = items[0].$index;
    this.first.index = items[items.length - 1].$index;
    this.direction = Direction.backward;
    this.isPrepend = true;
  }
  check(items) {
    this.startSimulate(items);
    this.last.index = items[0].$index;
    this.first.index = items[items.length - 1].$index;
    this.isCheck = true;
  }
  remove() {
    this.startSimulate([]);
    this.doRemove = true;
    // firstVisibleIndex & delta should be set inside process
  }
  update(index, delta, items, itemsToRemove) {
    this.startSimulate(items);
    this.firstVisibleIndex = index;
    this.firstVisibleItemDelta = delta;
    this.doRemove = itemsToRemove.length > 0;
  }
}
//# sourceMappingURL=fetch.js.map