{"version":3,"file":"preFetch.js","sourceRoot":"","sources":["../../../src/processes/preFetch.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAE,aAAa,EAAE,cAAc,EAAE,aAAa,EAAE,MAAM,cAAc,CAAC;AAEhG,OAAO,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAC;AAE5C,MAAM,CAAC,OAAO,OAAO,QAAS,SAAQ,kBAAkB,CAAC,aAAa,CAAC,QAAQ,CAAC;IAE9E,MAAM,CAAC,GAAG,CAAC,QAAkB;QAC3B,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,GAAG,QAAQ,CAAC;QAC/D,KAAK,CAAC,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;QAEjC,+CAA+C;QAC/C,QAAQ,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;QAE1C,kCAAkC;QAClC,QAAQ,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAErC,IAAI,QAAQ,CAAC,QAAQ,CAAC,QAAQ,EAAE;YAC9B,4CAA4C;YAC5C,QAAQ,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;SACpC;QAED,iEAAiE;QACjE,QAAQ,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QAEtC,sBAAsB;QACtB,QAAQ,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAErC,QAAQ,CAAC,IAAI,CAAC;YACZ,OAAO,EAAE,QAAQ,CAAC,OAAO;YACzB,MAAM,EAAE,QAAQ,CAAC,SAAS,CAAC,QAAQ,CAAC;YACpC,OAAO,EAAE,EAAE,OAAO,EAAE,KAAK,CAAC,SAAS,EAAE;SACtC,CAAC,CAAC;IACL,CAAC;IAED,MAAM,CAAC,sBAAsB,CAAC,QAAkB;QAC9C,QAAQ,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAChC,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;QACjC,QAAQ,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAChC,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;IAC1B,CAAC;IAED,MAAM,CAAC,YAAY,CAAC,QAAkB;QACpC,MAAM,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE,SAAS,EAAE,EAAE,EAAE,QAAQ,EAAE,GAAG,QAAQ,CAAC;QAC/D,MAAM,YAAY,GAAG,QAAQ,CAAC,gBAAgB,EAAE,CAAC;QACjD,SAAS,CAAC,MAAM,GAAG,QAAQ,CAAC,cAAc,CAAC;QAC3C,SAAS,CAAC,UAAU,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;QACxD,SAAS,CAAC,QAAQ,GAAG,SAAS,CAAC,MAAM,GAAG,SAAS,CAAC,UAAU,CAAC;QAC7D,SAAS,CAAC,KAAK,GAAG,SAAS,CAAC,QAAQ,GAAG,YAAY,CAAC;QACpD,SAAS,CAAC,GAAG,GAAG,SAAS,CAAC,QAAQ,GAAG,QAAQ,CAAC,OAAO,EAAE,GAAG,YAAY,CAAC;IACzE,CAAC;IAED,MAAM,CAAC,aAAa,CAAC,QAAkB;QACrC,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,EAAE,MAAM,EAAE,EAAE,GAAG,QAAQ,CAAC;QAClD,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,IAAI,MAAM,EAAE;YACV,UAAU,IAAI,MAAM,CAAC;SACtB;QACD,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE;YACvB,OAAO,UAAU,CAAC;SACnB;QACD,KAAK,IAAI,KAAK,GAAG,MAAM,CAAC,iBAAiB,EAAE,KAAK,GAAG,MAAM,CAAC,UAAU,EAAE,KAAK,EAAE,EAAE;YAC7E,UAAU,IAAI,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;SAC5C;QACD,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;YACxB,kBAAkB,UAAU,EAAE,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,MAAM,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;SAC5E,CAAC,CAAC;QACH,OAAO,UAAU,CAAC;IACpB,CAAC;IAED,MAAM,CAAC,aAAa,CAAC,QAAkB;QACrC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC;QACnC,MAAM,EAAE,SAAS,EAAE,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,GAAG,KAAK,CAAC,KAAK,CAAC;QACpD,IAAI,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC;QACnC,IAAI,kBAAkB,GAAG,CAAC,CAAC;QAC3B,IAAI,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,SAAS,EAAE;YACnC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,kDAAkD,CAAC,CAAC;SACzE;aAAM,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE;YAC9B,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,kDAAkD,CAAC,CAAC;SACzE;aAAM;YACL,IAAI,QAAQ,GAAG,kBAAkB,CAAC;YAClC,IAAI,KAAK,GAAG,UAAU,CAAC;YACvB,OAAO,CAAC,EAAE,EAAE,4CAA4C;gBACtD,IAAI,KAAK,IAAI,CAAC,EAAE;oBACd,MAAM,IAAI,GAAG,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;oBAC1C,MAAM,IAAI,GAAG,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,KAAK,CAAC;oBACvC,IAAI,IAAI,GAAG,CAAC,EAAE;wBACZ,UAAU,GAAG,KAAK,CAAC;wBACnB,kBAAkB,GAAG,QAAQ,CAAC;wBAC9B,MAAM;qBACP;oBACD,QAAQ,IAAI,IAAI,CAAC;oBACjB,KAAK,EAAE,CAAC;oBACR,IAAI,KAAK,GAAG,MAAM,CAAC,WAAW,EAAE;wBAC9B,MAAM;qBACP;iBACF;gBACD,IAAI,KAAK,GAAG,CAAC,EAAE;oBACb,KAAK,EAAE,CAAC;oBACR,IAAI,KAAK,GAAG,MAAM,CAAC,WAAW,EAAE;wBAC9B,MAAM;qBACP;oBACD,QAAQ,IAAI,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;oBACzC,MAAM,IAAI,GAAG,QAAQ,GAAG,KAAK,CAAC;oBAC9B,UAAU,GAAG,KAAK,CAAC;oBACnB,kBAAkB,GAAG,QAAQ,CAAC;oBAC9B,IAAI,IAAI,IAAI,CAAC,EAAE;wBACb,MAAM;qBACP;iBACF;aACF;SACF;QACD,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC;QAC3E,KAAK,CAAC,QAAQ,GAAG,kBAAkB,CAAC;IACtC,CAAC;IAED,MAAM,CAAC,YAAY,CAAC,QAAkB;QACpC,MAAM,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ,CAAC;QAC/D,MAAM,EAAE,SAAS,EAAE,EAAE,QAAQ,EAAE,GAAG,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,KAAK,CAAC;QAC5D,IAAI,SAAS,CAAC;QACd,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE;YACvB,6FAA6F;YAC7F,SAAS,GAAG,MAAM,CAAC,UAAU,GAAG,QAAQ,CAAC,UAAU,GAAG,CAAC,CAAC;YACxD,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,gDAAgD,CAAC,CAAC;SACvE;aAAM;YACL,IAAI,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC;YAC9B,IAAI,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;YAC9B,SAAS,GAAG,KAAK,CAAC;YAClB,OAAO,CAAC,EAAE,EAAE,4CAA4C;gBACtD,SAAS,GAAG,KAAK,CAAC;gBAClB,MAAM,IAAI,GAAG,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;gBAC1C,QAAQ,IAAI,IAAI,CAAC;gBACjB,IAAI,KAAK,CAAC,KAAK,CAAC,iBAAiB,CAAC,IAAI,QAAQ,GAAG,QAAQ,EAAE;oBACzD,KAAK,CAAC,iBAAiB,GAAG,KAAK,CAAC;oBAChC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,SAAS,EAAE;wBAC9B,KAAK,CAAC,qBAAqB,GAAG,QAAQ,GAAG,IAAI,GAAG,QAAQ,CAAC;qBAC1D;iBACF;gBACD,IAAI,QAAQ,IAAI,GAAG,EAAE;oBACnB,MAAM;iBACP;gBACD,IAAI,KAAK,EAAE,GAAG,MAAM,CAAC,WAAW,EAAE;oBAChC,MAAM;iBACP;aACF;SACF;QACD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC;IAC1E,CAAC;IAED,MAAM,CAAC,iBAAiB,CAAC,QAAkB;QACzC,MAAM,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC;QAC5B,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;YAChB,OAAO;SACR;QACD,MAAM,EAAE,KAAK,EAAE,GAAG,QAAQ,CAAC,KAAK,CAAC;QACjC,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC;QACrC,MAAM,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;QACnC,MAAM,KAAK,GAAe,CAAC,EAAE,CAAC,CAAC;QAC/B,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,KAAK,IAAI,CAAC,GAAG,UAAU,EAAE,CAAC,IAAI,SAAS,EAAE,CAAC,EAAE,EAAE;YAC5C,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;gBAClB,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;aAClB;iBAAM,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;gBAC1B,KAAK,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC;aACjB;SACF;QACD,IAAI,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACpB,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;YAClD,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC;YAC5B,sDAAsD;YACtD,sEAAsE;YACtE,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE;gBACtC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;aACjB;SACF;QACD,KAAK,CAAC,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC;QAC1D,KAAK,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC;QACvE,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,KAAK,UAAU,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE;YACtE,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAC;SAChD;IACH,CAAC;IAED,MAAM,CAAC,eAAe,CAAC,QAAkB;QACvC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE,GAAG,QAAQ,CAAC;QAC9C,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;YAChB,OAAO;SACR;QACD,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC;QACrC,MAAM,UAAU,GAAG,MAAM,CAAC,SAAS,CAAC;QACpC,IAAI,UAAU,GAAG,UAAU,EAAE;YAC3B,KAAK,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,WAAW,GAAG,UAAU,GAAG,CAAC,CAAC;SAC9D;QACD,MAAM,WAAW,GAAG,MAAM,CAAC,UAAU,CAAC;QACtC,MAAM,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;QACnC,IAAI,SAAS,GAAG,WAAW,EAAE;YAC3B,KAAK,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,WAAW,GAAG,WAAW,GAAG,CAAC,CAAC;SAC7D;QACD,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,KAAK,UAAU,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE;YACtE,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,qCAAqC,CAAC,CAAC;SAC9D;IACH,CAAC;IAED,MAAM,CAAC,kBAAkB,CAAC,QAAkB;QAC1C,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE,GAAG,QAAQ,CAAC;QAC9C,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;YACtB,OAAO;SACR;QACD,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC;QACrC,MAAM,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;QACnC,MAAM,IAAI,GAAG,QAAQ,CAAC,QAAQ,CAAC,UAAU,GAAG,CAAC,SAAS,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC;QACzE,IAAI,IAAI,IAAI,CAAC,EAAE;YACb,OAAO;SACR;QACD,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,SAAS,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,EAAE,UAAU;YAClE,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,GAAG,IAAI,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC;YACpE,IAAI,YAAY,GAAG,SAAS,EAAE;gBAC5B,KAAK,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,WAAW,GAAG,YAAY,CAAC;aAC1D;SACF;aAAM;YACL,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,GAAG,IAAI,EAAE,MAAM,CAAC,WAAW,CAAC,CAAC;YACtE,IAAI,aAAa,GAAG,UAAU,EAAE;gBAC9B,KAAK,CAAC,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,WAAW,GAAG,aAAa,CAAC;aAC7D;SACF;QACD,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,KAAK,UAAU,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE;YACtE,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,6BAA6B,CAAC,CAAC;YACrD,QAAQ,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;SACtC;IACH,CAAC;IAED,MAAM,CAAC,iBAAiB,CAAC,QAAkB;QACzC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,KAAK,EAAE,EAAE,GAAG,QAAQ,CAAC;QAC9C,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE;YACpB,IAAI,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC;YAClC,IAAI,MAAM,CAAC,IAAI,EAAE;gBACf,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC;aAChG;YACD,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;YAC5B,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,uBAAuB,SAAS,GAAG,CAAC,CAAC;SAChE;IACH,CAAC;IAED,MAAM,CAAC,SAAS,CAAC,QAAkB;QACjC,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,QAAQ,CAAC,KAAK,CAAC;QACxC,IAAI,KAAK,CAAC,SAAS,KAAK,cAAc,CAAC,IAAI,EAAE;YAC3C,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,+BAA+B,cAAc,CAAC,IAAI,WAAW,CAAC,CAAC;YACzF,OAAO,aAAa,CAAC,IAAI,CAAC;SAC3B;QACD,IAAI,KAAK,CAAC,WAAW,EAAE;YACrB,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,kBAAkB,KAAK,CAAC,KAAK,6BAA6B,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC;YACnG,OAAO,aAAa,CAAC,IAAI,CAAC;SAC3B;QACD,OAAO,aAAa,CAAC,IAAI,CAAC;IAC5B,CAAC;CAEF","sourcesContent":["import { BaseProcessFactory, CommonProcess, AdapterProcess, ProcessStatus } from './misc/index';\nimport { Scroller } from '../scroller';\nimport { Direction } from '../inputs/index';\n\nexport default class PreFetch extends BaseProcessFactory(CommonProcess.preFetch) {\n\n  static run(scroller: Scroller): void {\n    const { workflow, buffer, state: { fetch, cycle } } = scroller;\n    fetch.minIndex = buffer.minIndex;\n\n    // set first and last indexes of items to fetch\n    PreFetch.setPositionsAndIndexes(scroller);\n\n    // skip indexes that are in buffer\n    PreFetch.skipBufferedItems(scroller);\n\n    if (scroller.settings.infinite) {\n      // fill indexes to include buffer if no clip\n      PreFetch.checkBufferGaps(scroller);\n    }\n\n    // add indexes if there are too few items to fetch (clip padding)\n    PreFetch.checkFetchPackSize(scroller);\n\n    // set fetch direction\n    PreFetch.setFetchDirection(scroller);\n\n    workflow.call({\n      process: PreFetch.process,\n      status: PreFetch.getStatus(scroller),\n      payload: { process: cycle.initiator }\n    });\n  }\n\n  static setPositionsAndIndexes(scroller: Scroller): void {\n    PreFetch.setPositions(scroller);\n    PreFetch.setFirstIndex(scroller);\n    PreFetch.setLastIndex(scroller);\n    scroller.logger.fetch();\n  }\n\n  static setPositions(scroller: Scroller): void {\n    const { state: { fetch: { positions } }, viewport } = scroller;\n    const paddingDelta = viewport.getBufferPadding();\n    positions.before = viewport.scrollPosition;\n    positions.startDelta = PreFetch.getStartDelta(scroller);\n    positions.relative = positions.before - positions.startDelta;\n    positions.start = positions.relative - paddingDelta;\n    positions.end = positions.relative + viewport.getSize() + paddingDelta;\n  }\n\n  static getStartDelta(scroller: Scroller): number { // calculate size before start index\n    const { buffer, viewport: { offset } } = scroller;\n    let startDelta = 0;\n    if (offset) {\n      startDelta += offset;\n    }\n    if (!buffer.defaultSize) {\n      return startDelta;\n    }\n    for (let index = buffer.finiteAbsMinIndex; index < buffer.startIndex; index++) {\n      startDelta += buffer.getSizeByIndex(index);\n    }\n    scroller.logger.log(() => [\n      `start delta is ${startDelta}`, ...(offset ? [` (+${offset} offset)`] : [])\n    ]);\n    return startDelta;\n  }\n\n  static setFirstIndex(scroller: Scroller): void {\n    const { state, buffer } = scroller;\n    const { positions: { start }, first } = state.fetch;\n    let firstIndex = buffer.startIndex;\n    let firstIndexPosition = 0;\n    if (state.cycle.innerLoop.isInitial) {\n      scroller.logger.log('skipping fetch backward direction [initial loop]');\n    } else if (!buffer.defaultSize) {\n      scroller.logger.log('skipping fetch backward direction [no item size]');\n    } else {\n      let position = firstIndexPosition;\n      let index = firstIndex;\n      while (1) { // eslint-disable-line no-constant-condition\n        if (start >= 0) {\n          const size = buffer.getSizeByIndex(index);\n          const diff = (position + size) - start;\n          if (diff > 0) {\n            firstIndex = index;\n            firstIndexPosition = position;\n            break;\n          }\n          position += size;\n          index++;\n          if (index < buffer.absMinIndex) {\n            break;\n          }\n        }\n        if (start < 0) {\n          index--;\n          if (index < buffer.absMinIndex) {\n            break;\n          }\n          position -= buffer.getSizeByIndex(index);\n          const diff = position - start;\n          firstIndex = index;\n          firstIndexPosition = position;\n          if (diff <= 0) {\n            break;\n          }\n        }\n      }\n    }\n    first.index = first.indexBuffer = Math.max(firstIndex, buffer.absMinIndex);\n    first.position = firstIndexPosition;\n  }\n\n  static setLastIndex(scroller: Scroller): void {\n    const { state: { fetch, cycle }, buffer, settings } = scroller;\n    const { positions: { relative, end }, first, last } = fetch;\n    let lastIndex;\n    if (!buffer.defaultSize) {\n      // just to fetch forward bufferSize items if neither averageItemSize nor itemSize are present\n      lastIndex = buffer.startIndex + settings.bufferSize - 1;\n      scroller.logger.log('forcing fetch forward direction [no item size]');\n    } else {\n      let index = first.indexBuffer;\n      let position = first.position;\n      lastIndex = index;\n      while (1) { // eslint-disable-line no-constant-condition\n        lastIndex = index;\n        const size = buffer.getSizeByIndex(index);\n        position += size;\n        if (isNaN(fetch.firstVisibleIndex) && position > relative) {\n          fetch.firstVisibleIndex = index;\n          if (!cycle.innerLoop.isInitial) {\n            fetch.firstVisibleItemDelta = position - size - relative;\n          }\n        }\n        if (position >= end) {\n          break;\n        }\n        if (index++ > buffer.absMaxIndex) {\n          break;\n        }\n      }\n    }\n    last.index = last.indexBuffer = Math.min(lastIndex, buffer.absMaxIndex);\n  }\n\n  static skipBufferedItems(scroller: Scroller): void {\n    const { buffer } = scroller;\n    if (!buffer.size) {\n      return;\n    }\n    const { fetch } = scroller.state;\n    const firstIndex = fetch.first.index;\n    const lastIndex = fetch.last.index;\n    const packs: number[][] = [[]];\n    let p = 0;\n    for (let i = firstIndex; i <= lastIndex; i++) {\n      if (!buffer.get(i)) {\n        packs[p].push(i);\n      } else if (packs[p].length) {\n        packs[++p] = [];\n      }\n    }\n    let pack = packs[0];\n    if (packs[0].length && packs[1] && packs[1].length) {\n      fetch.hasAnotherPack = true;\n      // todo: need to look for biggest pack in visible area\n      // todo: or think about merging two requests in a single Fetch process\n      if (packs[1].length >= packs[0].length) {\n        pack = packs[1];\n      }\n    }\n    fetch.first.index = Math.max(pack[0], buffer.absMinIndex);\n    fetch.last.index = Math.min(pack[pack.length - 1], buffer.absMaxIndex);\n    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {\n      scroller.logger.fetch('after Buffer flushing');\n    }\n  }\n\n  static checkBufferGaps(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (!buffer.size) {\n      return;\n    }\n    const fetchFirst = fetch.first.index;\n    const bufferLast = buffer.lastIndex;\n    if (fetchFirst > bufferLast) {\n      fetch.first.index = fetch.first.indexBuffer = bufferLast + 1;\n    }\n    const bufferFirst = buffer.firstIndex;\n    const fetchLast = fetch.last.index;\n    if (fetchLast < bufferFirst) {\n      fetch.last.index = fetch.last.indexBuffer = bufferFirst - 1;\n    }\n    if (fetch.first.index !== fetchFirst || fetch.last.index !== fetchLast) {\n      scroller.logger.fetch('after Buffer filling (no clip case)');\n    }\n  }\n\n  static checkFetchPackSize(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (!fetch.shouldFetch) {\n      return;\n    }\n    const firstIndex = fetch.first.index;\n    const lastIndex = fetch.last.index;\n    const diff = scroller.settings.bufferSize - (lastIndex - firstIndex + 1);\n    if (diff <= 0) {\n      return;\n    }\n    if (!buffer.size || lastIndex > buffer.items[0].$index) { // forward\n      const newLastIndex = Math.min(lastIndex + diff, buffer.absMaxIndex);\n      if (newLastIndex > lastIndex) {\n        fetch.last.index = fetch.last.indexBuffer = newLastIndex;\n      }\n    } else {\n      const newFirstIndex = Math.max(firstIndex - diff, buffer.absMinIndex);\n      if (newFirstIndex < firstIndex) {\n        fetch.first.index = fetch.first.indexBuffer = newFirstIndex;\n      }\n    }\n    if (fetch.first.index !== firstIndex || fetch.last.index !== lastIndex) {\n      scroller.logger.fetch('after bufferSize adjustment');\n      PreFetch.skipBufferedItems(scroller);\n    }\n  }\n\n  static setFetchDirection(scroller: Scroller): void {\n    const { buffer, state: { fetch } } = scroller;\n    if (fetch.last.index) {\n      let direction = Direction.forward;\n      if (buffer.size) {\n        direction = fetch.last.index < buffer.items[0].$index ? Direction.backward : Direction.forward;\n      }\n      fetch.direction = direction;\n      scroller.logger.log(() => `fetch direction is \"${direction}\"`);\n    }\n  }\n\n  static getStatus(scroller: Scroller): ProcessStatus {\n    const { cycle, fetch } = scroller.state;\n    if (cycle.initiator === AdapterProcess.clip) {\n      scroller.logger.log(() => `going to skip fetch due to \"${AdapterProcess.clip}\" process`);\n      return ProcessStatus.next;\n    }\n    if (fetch.shouldFetch) {\n      scroller.logger.log(() => `going to fetch ${fetch.count} items started from index ${fetch.index}`);\n      return ProcessStatus.next;\n    }\n    return ProcessStatus.done;\n  }\n\n}\n"]}