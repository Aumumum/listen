import { AdapterMethods } from '../../inputs/index';
import { BaseAdapterProcessFactory, AdapterProcess, ProcessStatus } from '../misc/index';
const { [AdapterProcess.fix]: FixParams } = AdapterMethods;
export default class Fix extends BaseAdapterProcessFactory(AdapterProcess.fix) {
  static run(scroller, options) {
    const { workflow } = scroller;
    const { data, params } = Fix.parseInput(scroller, options);
    if (!params) {
      return;
    }
    Object.entries(data.params).forEach(([key, value]) => {
      if (value.isSet && value.isValid) {
        Fix.runByType(scroller, key, value.value, data);
      }
    });
    workflow.call({
      process: Fix.process,
      status: ProcessStatus.done
    });
  }
  static runByType(scroller, token, value, methodData) {
    switch (token) {
      case FixParams.scrollPosition:
        return Fix.setScrollPosition(scroller, value);
      case FixParams.minIndex:
        return Fix.setMinIndex(scroller, value);
      case FixParams.maxIndex:
        return Fix.setMaxIndex(scroller, value);
      case FixParams.updater:
        return Fix.updateItems(scroller, value);
      case FixParams.scrollToItem:
        if (methodData.params) {
          const scrollToItemOpt = methodData.params[FixParams.scrollToItemOpt];
          const options = scrollToItemOpt ? scrollToItemOpt.value : void 0;
          return Fix.scrollToItem(scroller, value, options);
        }
        return;
      case FixParams.scrollToItemOpt:
        return;
    }
  }
  static setScrollPosition({ viewport }, value) {
    let result = value;
    if (value === -Infinity) {
      result = 0;
    }
    else if (value === Infinity) {
      result = viewport.getScrollableSize();
    }
    viewport.setPosition(result);
  }
  static setMinIndex({ buffer, settings }, value) {
    settings.minIndex = value;
    buffer.absMinIndex = value;
  }
  static setMaxIndex({ buffer, settings }, value) {
    settings.maxIndex = value;
    buffer.absMaxIndex = value;
  }
  static updateItems({ buffer, logger }, value) {
    let updateReference = false;
    const updater = () => updateReference = true;
    buffer.items.forEach(item => value(item.get(), updater));
    if (updateReference) {
      logger.log(() => 'update Buffer.items reference');
      buffer.items = [...buffer.items];
    }
  }
  static scrollToItem(scroller, value, options) {
    const found = scroller.buffer.items.find(item => value(item.get()));
    if (!found) {
      scroller.logger.log(() => 'scrollToItem cancelled, item not found');
      return;
    }
    found.scrollTo(options);
  }
}
//# sourceMappingURL=fix.js.map