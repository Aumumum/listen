import { BaseProcessFactory, CommonProcess, ProcessStatus } from './misc/index';
export default class Fetch extends BaseProcessFactory(CommonProcess.fetch) {
  static run(scroller) {
    const { workflow } = scroller;
    const box = {
      success: (data) => {
        scroller.logger.log(() => `resolved ${data.length} items ` +
          `(index = ${scroller.state.fetch.index}, count = ${scroller.state.fetch.count})`);
        scroller.state.fetch.newItemsData = data;
        workflow.call({
          process: Fetch.process,
          status: ProcessStatus.next
        });
      },
      fail: (error) => workflow.call({
        process: Fetch.process,
        status: ProcessStatus.error,
        payload: { error }
      })
    };
    const result = Fetch.get(scroller);
    Fetch.complete(scroller, box, result);
  }
  static complete(scroller, box, result) {
    if (Object.prototype.hasOwnProperty.call(result, 'data')) {
      const { data, error, isError } = result;
      if (!isError) {
        box.success(data || []);
      }
      else {
        box.fail(error);
      }
    }
    else {
      const { state: { scrollState, fetch }, viewport } = scroller;
      if (scrollState.positionBeforeAsync === null) {
        scrollState.positionBeforeAsync = viewport.scrollPosition;
      }
      fetch.cancel = () => {
        box.success = () => null;
        box.fail = () => null;
      };
      result.then((data) => box.success(data), (error) => box.fail(error));
    }
  }
  static get(scroller) {
    const _get = scroller.datasource.get;
    const { index, count } = scroller.state.fetch;
    let immediateData, immediateError;
    let resolve, reject;
    const done = (data) => {
      if (!resolve) {
        immediateData = data || null;
        return;
      }
      resolve(data);
    };
    const fail = (error) => {
      if (!reject) {
        immediateError = error || null;
        return;
      }
      reject(error);
    };
    const getResult = _get(index, count, done, fail);
    if (getResult && typeof getResult === 'object' && getResult !== null) {
      if (typeof getResult.then === 'function') {
        return getResult;
      }
      else if (typeof getResult.subscribe === 'function') {
        const sub = getResult.subscribe(done, fail, () => {
          if (sub && typeof sub === 'object' && typeof sub.unsubscribe === 'function') {
            sub.unsubscribe();
          }
        });
      }
    }
    if (immediateData || immediateError) { // callback case or immediate observable
      return {
        data: immediateError ? null : (immediateData || []),
        error: immediateError,
        isError: !!immediateError
      };
    }
    return new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    });
  }
}
//# sourceMappingURL=fetch.js.map